// DO NOT EDIT THIS FILE MANUALLY

/** REST API endpoint based on given `ChainName` and `OperationId`. */
export type RestApiEndpoint<N extends ChainName, I extends OperationId> =
    RestApi[I] extends { endpoint: { [chainName in N]: infer E } } ? E : never

/** REST API path parameters based on given `ChainName` and `OperationId`. */
export type RestApiPathParams<N extends ChainName, I extends OperationId> =
    RestApi[I] extends { params: { path: { [chainName in N]: infer E } } } ? E : never

/** REST API query parameters based on given `ChainName` and `OperationId`. */
export type RestApiQueryParams<N extends ChainName, I extends OperationId> =
    RestApi[I] extends { params: { query: { [chainName in N]: infer E } } } ? E : never

/** REST API body parameters based on given `ChainName` and `OperationId`. */
export type RestApiBodyParams<N extends ChainName, I extends OperationId> =
    RestApi[I] extends { params: { body: { [chainName in N]: infer E } } } ? E : never

/** REST API successful response type based on given `ChainName` and `OperationId`. */
export type RestApiSuccessResponse<N extends ChainName, I extends OperationId> =
    RestApi[I] extends { response: { success: { [chainName in N]: infer E } } } ? E : never

/** REST API error response type based on given `ChainName` and `OperationId`. */
export type RestApiErrorResponse<N extends ChainName, I extends OperationId> =
    RestApi[I] extends { response: { error: { [chainName in N]: infer E } } } ? E : never

/** Stores everything related to Rest API. */
export interface RestApi {
    /** Parameters queries the parameters of the module. */
    BundlesParams: {
        method: 'get'
        endpoint: {
            /** '/kyve/bundles/v1beta1/params' */
            kyve: `/kyve/bundles/v1beta1/params`
        }
        params: {
            path: {
                kyve: undefined
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryParamsResponse is response type for the Query/Params RPC method. */
                {
                    /** params holds all the parameters of this module. */
                    params: {
                        /** upload_timeout ... */
                        upload_timeout: string
                        /** storage_cost ... */
                        storage_cost: string
                        /** network_fee ... */
                        network_fee: string
                        /** max_points ... */
                        max_points: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Parameters queries the parameters of the module. */
    DelegationParams: {
        method: 'get'
        endpoint: {
            /** '/kyve/delegation/v1beta1/params' */
            kyve: `/kyve/delegation/v1beta1/params`
        }
        params: {
            path: {
                kyve: undefined
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryParamsResponse is response type for the Query/Params RPC method. */
                {
                    /** params holds all the parameters of this module. */
                    params: {
                        /** unbonding_delegation_time ... */
                        unbonding_delegation_time: string
                        /** unbonding_delegation_time ... */
                        redelegation_cooldown: string
                        /** unbonding_delegation_time ... */
                        redelegation_max_amount: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Slashes ... */
    Slashes: {
        method: 'get'
        endpoint: {
            /** '/kyve/delegation/v1beta1/slashes' */
            kyve: `/kyve/delegation/v1beta1/slashes`
        }
        params: {
            path: {
                kyve: undefined
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryParamsResponse is response type for the Query/Params RPC method. */
                {
                    /** slashes ... */
                    slashes: Array<{
                        /** staker ... */
                        staker: string
                        /** k_index ... */
                        k_index: string
                        /** fraction ... */
                        fraction: string
                    }>
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Parameters queries the parameters of the module. */
    FeesParams: {
        method: 'get'
        endpoint: {
            /** '/kyve/fees/v1beta1/params' */
            kyve: `/kyve/fees/v1beta1/params`
        }
        params: {
            path: {
                kyve: undefined
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryParamsResponse is response type for the Query/Params RPC method. */
                {
                    /** params holds all the parameters of this module. */
                    params: {
                        /** min_gas_price defines the minimum gas price value for all transactions. */
                        min_gas_price: string
                        /** burn_ratio defines the ratio of transaction fees burnt. */
                        burn_ratio: string
                        /** gas_adjustments ... */
                        gas_adjustments: Array<{
                            /** type ... */
                            type: string
                            /** amount ... */
                            amount: string
                        }>
                        /** gas_refunds ... */
                        gas_refunds: Array<{
                            /** type ... */
                            type: string
                            /** fraction ... */
                            fraction: string
                        }>
                        /** min_initial_deposit_ratio ... */
                        min_initial_deposit_ratio: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** AccountAssets returns an overview of the sum of all balances for a given user. e.g. balance, staking, funding, etc. */
    AccountAssets: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/account_assets/{address}' */
            kyve: `/kyve/query/v1beta1/account_assets/${string}`
        }
        params: {
            path: {
                kyve: {
                    /** address ... */
                    address: string
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryAccountAssetsResponse is the response type for the Query/AccountAssets RPC method. */
                {
                    /** balance ... */
                    balance: string
                    /** protocol_staking ... */
                    protocol_self_delegation: string
                    /** protocol_staking_unbonding */
                    protocol_self_delegation_unbonding: string
                    /** protocol_delegation ... */
                    protocol_delegation: string
                    /** protocol_delegation_unbonding */
                    protocol_delegation_unbonding: string
                    /** protocol_rewards ... */
                    protocol_rewards: string
                    /** protocol_funding ... */
                    protocol_funding: string
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** AccountDelegationUnbondings ... */
    AccountDelegationUnbondings: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/account_delegation_unbondings/{address}' */
            kyve: `/kyve/query/v1beta1/account_delegation_unbondings/${string}`
        }
        params: {
            path: {
                kyve: {
                    /** address ... */
                    address: string
                }
            }

            query: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                kyve: /** QueryAccountAssetsResponse is the response type for the Query/AccountAssets RPC method. */
                {
                    /** balance ... */
                    unbondings: Array<{
                        /** amount */
                        amount: string
                        /** creation_time */
                        creation_time: string
                        /** staker */
                        staker: {
                            /** address of the staker */
                            address: string
                            /** StakerMetadata contains static information for a staker */
                            metadata: {
                                /** commission is the percentage of the rewards that will
                                get transferred to the staker before the remaining
                                rewards are split across all delegators */
                                commission: string
                                /** moniker is a human-readable name for displaying
                                the staker in the UI */
                                moniker: string
                                /** website is a https-link to the website of the staker */
                                website: string
                                /** logo is a link to an image file (like jpg or png) */
                                logo: string
                                /** CommissionChangeEntry shows when the old commission
                                of a staker will change to the new commission */
                                pending_commission_change: {
                                    /** commission is the new commission that will
                                    become active once the change-time is over */
                                    commission: string
                                    /** creation_date is the UNIX-timestamp (in seconds)
                                    of when the entry was created. */
                                    creation_date: string
                                }
                            }
                            /** amount the staker has delegated to himself */
                            self_delegation: string
                            /** unbonding_amount is the amount the staker is currently unbonding
                            from the self-delegation.
                            This amount can be larger than `amount` when the staker
                            got slashed during unbonding. However, at the end of
                            the unbonding period this amount is double checked with the
                            remaining amount. */
                            self_delegation_unbonding: string
                            /** total_delegation returns the sum of all $KYVE users
                            have delegated to this staker */
                            total_delegation: string
                            /** delegator_count is the total number of individual
                            delegator addresses for that user. */
                            delegator_count: string
                            /** pools is a list of all pools the staker is currently
                            participating, i.e. allowed to vote and upload data. */
                            pools: Array<{
                                /** pool contains useful information about the pool */
                                pool: {
                                    /** id is the ID of the pool */
                                    id: string
                                    /** name of the pool */
                                    name: string
                                    /** runtime for the protocol nodes
                                    like evm, bitcoin, etc. */
                                    runtime: string
                                    /** logo of the pool */
                                    logo: string
                                    /** operating_cost is the base payout for each bundle reward */
                                    operating_cost: string
                                    /** upload_interval is the interval bundles get created */
                                    upload_interval: string
                                    /** total_funds of the pool. If the pool runs
                                    out of funds no more bundles will be produced */
                                    total_funds: string
                                    /** total_delegation of the pool */
                                    total_delegation: string
                                    /** status of the pool if pool is able
                                    to produce bundles, etc. */
                                    status: string
                                }
                                /** points indicates if the staker is inactive
                                If the staker misses a vote, a point is added.
                                After 5 points the staker is removed from
                                the stakers set. */
                                points: string
                                /** is_leaving indicates if a user has scheduled a
                                a PoolLeave entry. After the leave-time is over
                                the staker will no longer participate in that pool */
                                is_leaving: boolean
                                /** Valaddress is the address which is authorized to vote
                                and submit bundles. If the server gets compromised
                                the staker can just change the valaddress. */
                                valaddress: string
                                /** balance is the valaddress account balance and indicates
                                whether or not the valaccount needs additional funds to
                                pay for gas fees */
                                balance: string
                            }>
                        }
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently. It will be empty if
                        there are no more results. */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** AccountFundedList returns all pools the given user has funded into. */
    AccountFundedList: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/account_funded_list/{address}' */
            kyve: `/kyve/query/v1beta1/account_funded_list/${string}`
        }
        params: {
            path: {
                kyve: {
                    /** address ... */
                    address: string
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryAccountFundedListResponse is the response type for the Query/AccountFundedList RPC method. */
                {
                    /** funded ... */
                    funded: Array<{
                        /** amount ... */
                        amount: string
                        /** BasicPool contains the necessary properties need for a pool
                        to be displayed in the UI */
                        pool: {
                            /** id is the ID of the pool */
                            id: string
                            /** name of the pool */
                            name: string
                            /** runtime for the protocol nodes
                            like evm, bitcoin, etc. */
                            runtime: string
                            /** logo of the pool */
                            logo: string
                            /** operating_cost is the base payout for each bundle reward */
                            operating_cost: string
                            /** upload_interval is the interval bundles get created */
                            upload_interval: string
                            /** total_funds of the pool. If the pool runs
                            out of funds no more bundles will be produced */
                            total_funds: string
                            /** total_delegation of the pool */
                            total_delegation: string
                            /** status of the pool if pool is able
                            to produce bundles, etc. */
                            status: string
                        }
                    }>
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** AccountRedelegation ... */
    AccountRedelegation: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/account_redelegation/{address}' */
            kyve: `/kyve/query/v1beta1/account_redelegation/${string}`
        }
        params: {
            path: {
                kyve: {
                    /** address ... */
                    address: string
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryAccountDelegationListRequest is the response type for the Query/AccountDelegationList RPC method. */
                {
                    /** redelegation_cooldown_entries ... */
                    redelegation_cooldown_entries: Array<{
                        /** creation_date ... */
                        creation_date: string
                        /** finish_date ... */
                        finish_date: string
                    }>
                    /** availableSlots ... */
                    available_slots: string
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** CanPropose ... */
    CanPropose: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/can_propose/{pool_id}/{staker}/{proposer}/{from_index}' */
            kyve: `/kyve/query/v1beta1/can_propose/${number}/${string}/${string}/${number}`
        }
        params: {
            path: {
                kyve: {
                    /** pool_id defines the unique ID of the pool. */
                    pool_id: number
                    /** staker ... */
                    staker: string
                    /** proposer ... */
                    proposer: string
                    /** from_index ... */
                    from_index: number
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryCanProposeResponse is the response type for the Query/CanPropose RPC method. */
                {
                    /** possible ... */
                    possible: boolean
                    /** reason ... */
                    reason: string
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** CanValidate ... */
    CanValidate: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/can_validate/{pool_id}/{valaddress}' */
            kyve: `/kyve/query/v1beta1/can_validate/${number}/${string}`
        }
        params: {
            path: {
                kyve: {
                    /** pool_id defines the unique ID of the pool. */
                    pool_id: number
                    /** valaddress ... */
                    valaddress: string
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryCanProposeResponse is the response type for the Query/CanPropose RPC method. */
                {
                    /** possible ... */
                    possible: boolean
                    /** reason ... */
                    reason: string
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** CanVote checks if voter on pool can still vote for the given bundle */
    CanVote: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/can_vote/{pool_id}/{staker}/{voter}/{storage_id}' */
            kyve: `/kyve/query/v1beta1/can_vote/${number}/${string}/${string}/${string}`
        }
        params: {
            path: {
                kyve: {
                    /** pool_id defines the unique ID of the pool. */
                    pool_id: number
                    /** staker ... */
                    staker: string
                    /** voter ... */
                    voter: string
                    /** storage_id ... */
                    storage_id: string
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryCanVoteResponse is the response type for the Query/CanVote RPC method. */
                {
                    /** possible ... */
                    possible: boolean
                    /** reason ... */
                    reason: string
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** CurrentVoteStatus ... */
    CurrentVoteStatus: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/current_vote_status/{pool_id}' */
            kyve: `/kyve/query/v1beta1/current_vote_status/${number}`
        }
        params: {
            path: {
                kyve: {
                    /** pool_id ... */
                    pool_id: number
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryCurrentVoteStatusResponse is the response type for the Query/Staker RPC method. */
                {
                    /** valid ... */
                    valid: string
                    /** invalid ... */
                    invalid: string
                    /** abstain ... */
                    abstain: string
                    /** total ... */
                    total: string
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** FinalizedBundle ... */
    FinalizedBundle: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/finalized_bundle/{pool_id}/{id}' */
            kyve: `/kyve/query/v1beta1/finalized_bundle/${number}/${number}`
        }
        params: {
            path: {
                kyve: {
                    /** pool_id ... */
                    pool_id: number
                    /** id ... */
                    id: number
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryFinalizedBundleResponse is the response type for the Query/Staker RPC method. */
                {
                    /** finalized_bundle ... */
                    finalized_bundle: {
                        /** pool_id ... */
                        pool_id: string
                        /** id ... */
                        id: string
                        /** storage_id ... */
                        storage_id: string
                        /** uploader ... */
                        uploader: string
                        /** from_index ... */
                        from_index: string
                        /** to_index ... */
                        to_index: string
                        /** to_key ... */
                        to_key: string
                        /** bundle_summary ... */
                        bundle_summary: string
                        /** bundle_hash ... */
                        data_hash: string
                        /** finalized_at ... */
                        finalized_at: string
                        /** from_key ... */
                        from_key: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Queries the bundle which contains the data given height */
    FinalizedBundlesByHeight: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/finalized_bundle_by_height/{pool_id}/{height}' */
            kyve: `/kyve/query/v1beta1/finalized_bundle_by_height/${number}/${number}`
        }
        params: {
            path: {
                kyve: {
                    /** pool_id ... */
                    pool_id: number
                    /** id ... */
                    height: number
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryFinalizedBundleResponse is the response type for the Query/Staker RPC method. */
                {
                    /** finalized_bundle ... */
                    finalized_bundle: {
                        /** pool_id ... */
                        pool_id: string
                        /** id ... */
                        id: string
                        /** storage_id ... */
                        storage_id: string
                        /** uploader ... */
                        uploader: string
                        /** from_index ... */
                        from_index: string
                        /** to_index ... */
                        to_index: string
                        /** to_key ... */
                        to_key: string
                        /** bundle_summary ... */
                        bundle_summary: string
                        /** bundle_hash ... */
                        data_hash: string
                        /** finalized_at ... */
                        finalized_at: string
                        /** from_key ... */
                        from_key: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** StorageID -> single */
    FinalizedBundleByStorageId: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/finalized_bundle_by_storage_id/{storage_id}' */
            kyve: `/kyve/query/v1beta1/finalized_bundle_by_storage_id/${string}`
        }
        params: {
            path: {
                kyve: {
                    /** pool_id ... */
                    storage_id: string
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryFinalizedBundleResponse is the response type for the Query/Staker RPC method. */
                {
                    /** finalized_bundle ... */
                    finalized_bundle: {
                        /** pool_id ... */
                        pool_id: string
                        /** id ... */
                        id: string
                        /** storage_id ... */
                        storage_id: string
                        /** uploader ... */
                        uploader: string
                        /** from_index ... */
                        from_index: string
                        /** to_index ... */
                        to_index: string
                        /** to_key ... */
                        to_key: string
                        /** bundle_summary ... */
                        bundle_summary: string
                        /** bundle_hash ... */
                        data_hash: string
                        /** finalized_at ... */
                        finalized_at: string
                        /** from_key ... */
                        from_key: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** FinalizedBundles ... */
    FinalizedBundles: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/finalized_bundles/{pool_id}' */
            kyve: `/kyve/query/v1beta1/finalized_bundles/${number}`
        }
        params: {
            path: {
                kyve: {
                    /** pool_id ... */
                    pool_id: number
                }
            }

            query: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                kyve: /** QueryStakersByPoolResponse is the response type for the Query/Staker RPC method. */
                {
                    /** finalized_bundles ... */
                    finalized_bundles: Array<{
                        /** pool_id ... */
                        pool_id: string
                        /** id ... */
                        id: string
                        /** storage_id ... */
                        storage_id: string
                        /** uploader ... */
                        uploader: string
                        /** from_index ... */
                        from_index: string
                        /** to_index ... */
                        to_index: string
                        /** to_key ... */
                        to_key: string
                        /** bundle_summary ... */
                        bundle_summary: string
                        /** bundle_hash ... */
                        data_hash: string
                        /** finalized_at ... */
                        finalized_at: string
                        /** from_key ... */
                        from_key: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently. It will be empty if
                        there are no more results. */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Delegator returns delegation information for a specific delegator of a specific staker. */
    Delegator: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/delegator/{staker}/{delegator}' */
            kyve: `/kyve/query/v1beta1/delegator/${string}/${string}`
        }
        params: {
            path: {
                kyve: {
                    /** staker ... */
                    staker: string
                    /** delegator ... */
                    delegator: string
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryDelegatorResponse is the response type for the Query/Delegator RPC method. */
                {
                    /** delegator ... */
                    delegator: {
                        /** delegator ... */
                        delegator: string
                        /** current_reward ... */
                        current_reward: string
                        /** delegation_amount ... */
                        delegation_amount: string
                        /** staker ... */
                        staker: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** DelegatorsByStaker returns all delegators that have delegated to the given staker
    This query is paginated. */
    DelegatorsByStaker: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/delegators_by_staker/{staker}' */
            kyve: `/kyve/query/v1beta1/delegators_by_staker/${string}`
        }
        params: {
            path: {
                kyve: {
                    /** staker ... */
                    staker: string
                }
            }

            query: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                kyve: /** QueryDelegatorsByStakerResponse ... */
                {
                    /** delegators ... */
                    delegators: Array<{
                        /** delegator ... */
                        delegator: string
                        /** current_reward ... */
                        current_reward: string
                        /** delegation_amount ... */
                        delegation_amount: string
                        /** staker ... */
                        staker: string
                    }>
                    /** total_delegation ... (consider metadata object) */
                    total_delegation: string
                    /** total_delegation ... */
                    total_delegator_count: string
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently. It will be empty if
                        there are no more results. */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** StakersByPoolAndDelegator returns all stakers the given delegator has delegated to.
    This query is paginated. */
    StakersByDelegator: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/stakers_by_delegator/{delegator}' */
            kyve: `/kyve/query/v1beta1/stakers_by_delegator/${string}`
        }
        params: {
            path: {
                kyve: {
                    /** delegator ... */
                    delegator: string
                }
            }

            query: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                kyve: /** QueryStakersByDelegatorResponse ... */
                {
                    /** delegator ... */
                    delegator: string
                    /** stakers ... */
                    stakers: Array<{
                        /** FullStaker aggregates information from the staker and its delegators
                        as well as pending queue entries into one object.
                        It contains almost all needed information for a convenient usage */
                        staker: {
                            /** address of the staker */
                            address: string
                            /** StakerMetadata contains static information for a staker */
                            metadata: {
                                /** commission is the percentage of the rewards that will
                                get transferred to the staker before the remaining
                                rewards are split across all delegators */
                                commission: string
                                /** moniker is a human-readable name for displaying
                                the staker in the UI */
                                moniker: string
                                /** website is a https-link to the website of the staker */
                                website: string
                                /** logo is a link to an image file (like jpg or png) */
                                logo: string
                                /** CommissionChangeEntry shows when the old commission
                                of a staker will change to the new commission */
                                pending_commission_change: {
                                    /** commission is the new commission that will
                                    become active once the change-time is over */
                                    commission: string
                                    /** creation_date is the UNIX-timestamp (in seconds)
                                    of when the entry was created. */
                                    creation_date: string
                                }
                            }
                            /** amount the staker has delegated to himself */
                            self_delegation: string
                            /** unbonding_amount is the amount the staker is currently unbonding
                            from the self-delegation.
                            This amount can be larger than `amount` when the staker
                            got slashed during unbonding. However, at the end of
                            the unbonding period this amount is double checked with the
                            remaining amount. */
                            self_delegation_unbonding: string
                            /** total_delegation returns the sum of all $KYVE users
                            have delegated to this staker */
                            total_delegation: string
                            /** delegator_count is the total number of individual
                            delegator addresses for that user. */
                            delegator_count: string
                            /** pools is a list of all pools the staker is currently
                            participating, i.e. allowed to vote and upload data. */
                            pools: Array<{
                                /** pool contains useful information about the pool */
                                pool: {
                                    /** id is the ID of the pool */
                                    id: string
                                    /** name of the pool */
                                    name: string
                                    /** runtime for the protocol nodes
                                    like evm, bitcoin, etc. */
                                    runtime: string
                                    /** logo of the pool */
                                    logo: string
                                    /** operating_cost is the base payout for each bundle reward */
                                    operating_cost: string
                                    /** upload_interval is the interval bundles get created */
                                    upload_interval: string
                                    /** total_funds of the pool. If the pool runs
                                    out of funds no more bundles will be produced */
                                    total_funds: string
                                    /** total_delegation of the pool */
                                    total_delegation: string
                                    /** status of the pool if pool is able
                                    to produce bundles, etc. */
                                    status: string
                                }
                                /** points indicates if the staker is inactive
                                If the staker misses a vote, a point is added.
                                After 5 points the staker is removed from
                                the stakers set. */
                                points: string
                                /** is_leaving indicates if a user has scheduled a
                                a PoolLeave entry. After the leave-time is over
                                the staker will no longer participate in that pool */
                                is_leaving: boolean
                                /** Valaddress is the address which is authorized to vote
                                and submit bundles. If the server gets compromised
                                the staker can just change the valaddress. */
                                valaddress: string
                                /** balance is the valaddress account balance and indicates
                                whether or not the valaccount needs additional funds to
                                pay for gas fees */
                                balance: string
                            }>
                        }
                        /** current_reward ... */
                        current_reward: string
                        /** delegation_amount ... */
                        delegation_amount: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently. It will be empty if
                        there are no more results. */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Pools queries for all pools. */
    Params: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/params' */
            kyve: `/kyve/query/v1beta1/params`
        }
        params: {
            path: {
                kyve: undefined
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryParamsResponse ... */
                {
                    /** bundles_params ... */
                    bundles_params: {
                        /** upload_timeout ... */
                        upload_timeout: string
                        /** storage_cost ... */
                        storage_cost: string
                        /** network_fee ... */
                        network_fee: string
                        /** max_points ... */
                        max_points: string
                    }
                    /** delegation_params ... */
                    delegation_params: {
                        /** unbonding_delegation_time ... */
                        unbonding_delegation_time: string
                        /** unbonding_delegation_time ... */
                        redelegation_cooldown: string
                        /** unbonding_delegation_time ... */
                        redelegation_max_amount: string
                    }
                    /** fees_params ... */
                    fees_params: {
                        /** min_gas_price defines the minimum gas price value for all transactions. */
                        min_gas_price: string
                        /** burn_ratio defines the ratio of transaction fees burnt. */
                        burn_ratio: string
                        /** gas_adjustments ... */
                        gas_adjustments: Array<{
                            /** type ... */
                            type: string
                            /** amount ... */
                            amount: string
                        }>
                        /** gas_refunds ... */
                        gas_refunds: Array<{
                            /** type ... */
                            type: string
                            /** fraction ... */
                            fraction: string
                        }>
                        /** min_initial_deposit_ratio ... */
                        min_initial_deposit_ratio: string
                    }
                    /** gov_params ... */
                    gov_params: {
                        /** Deprecated: Prefer to use `params` instead.
                        voting_params defines the parameters related to voting. */
                        voting_params: {
                            /** Length of the voting period. */
                            voting_period: string
                        }
                        /** Deprecated: Prefer to use `params` instead.
                        deposit_params defines the parameters related to deposit. */
                        deposit_params: {
                            /** Minimum deposit for a proposal to enter voting period. */
                            min_deposit: Array<{
                                denom: string
                                amount: string
                            }>
                            /** Maximum period for Atom holders to deposit on a proposal. Initial value: 2
                             months. */
                            max_deposit_period: string
                        }
                        /** Deprecated: Prefer to use `params` instead.
                        tally_params defines the parameters related to tally. */
                        tally_params: {
                            /** Minimum percentage of total stake needed to vote for a result to be
                             considered valid. */
                            quorum: string
                            /** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
                            threshold: string
                            /** Minimum value of Veto votes to Total votes ratio for proposal to be
                             vetoed. Default value: 1/3. */
                            veto_threshold: string
                        }
                        /** params defines all the paramaters of x/gov module.
                        
                        Since: cosmos-sdk 0.47 */
                        params: {
                            /** Minimum deposit for a proposal to enter voting period. */
                            min_deposit: Array<{
                                denom: string
                                amount: string
                            }>
                            /** Maximum period for Atom holders to deposit on a proposal. Initial value: 2
                             months. */
                            max_deposit_period: string
                            /** Length of the voting period. */
                            voting_period: string
                            /** Minimum percentage of total stake needed to vote for a result to be
                             considered valid. */
                            quorum: string
                            /** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
                            threshold: string
                            /** Minimum value of Veto votes to Total votes ratio for proposal to be
                             vetoed. Default value: 1/3. */
                            veto_threshold: string
                            /** The ratio representing the proportion of the deposit value that must be paid at proposal submission. */
                            min_initial_deposit_ratio: string
                        }
                    }
                    /** stakers_params ... */
                    stakers_params: {
                        /** vote_slash ... */
                        vote_slash: string
                        /** upload_slash ... */
                        upload_slash: string
                        /** timeout_slash ... */
                        timeout_slash: string
                        /** unbonding_staking_time ... */
                        unbonding_staking_time: string
                        /** commission_change_time ... */
                        commission_change_time: string
                        /** commission_change_time ... */
                        leave_pool_time: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Pool queries the pool info. */
    Pool: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/pool' */
            evmos: `/cosmos/staking/v1beta1/pool`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryPoolResponse is response type for the Query/Pool RPC method. */
                {
                    /** pool defines the pool info. */
                    pool: {
                        not_bonded_tokens: string
                        bonded_tokens: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Pools queries for all pools. */
    Pools: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/pools' */
            kyve: `/kyve/query/v1beta1/pools`
        }
        params: {
            path: {
                kyve: undefined
            }

            query: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                    /** search ... */
                    search: string
                    /** runtime ... */
                    runtime: string
                    /** paused ... */
                    paused: string
                }
            }
            body: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                    /** search ... */
                    search: string
                    /** runtime ... */
                    runtime: string
                    /** paused ... */
                    paused: string
                }
            }
        }
        response: {
            success: {
                kyve: /** QueryPoolsResponse is the response type for the Query/Pools RPC method. */
                {
                    /** pools ... */
                    pools: Array<{
                        /** id ... */
                        id: string
                        /** data ... */
                        data: {
                            /** id ... */
                            id: string
                            /** name ... */
                            name: string
                            /** runtime ... */
                            runtime: string
                            /** logo ... */
                            logo: string
                            /** config ... */
                            config: string
                            /** start_key ... */
                            start_key: string
                            /** current_key ... */
                            current_key: string
                            /** current_summary ... */
                            current_summary: string
                            /** current_index ... */
                            current_index: string
                            /** total_bundles ... */
                            total_bundles: string
                            /** upload_interval ... */
                            upload_interval: string
                            /** operating_cost ... */
                            operating_cost: string
                            /** min_delegation ... */
                            min_delegation: string
                            /** max_bundle_size ... */
                            max_bundle_size: string
                            /** paused ... */
                            paused: boolean
                            /** funders ... */
                            funders: Array<{
                                /** address ... */
                                address: string
                                /** amount ... */
                                amount: string
                            }>
                            /** total_funds ... */
                            total_funds: string
                            /** protocol ... */
                            protocol: {
                                /** version ... */
                                version: string
                                /** binaries ... */
                                binaries: string
                                /** last_upgrade ... */
                                last_upgrade: string
                            }
                            /** upgrade_plan ... */
                            upgrade_plan: {
                                /** version ... */
                                version: string
                                /** binaries ... */
                                binaries: string
                                /** scheduled_at ... */
                                scheduled_at: string
                                /** duration ... */
                                duration: string
                            }
                        }
                        /** bundle_proposal ... */
                        bundle_proposal: {
                            /** pool_id ... */
                            pool_id: string
                            /** storage_id ... */
                            storage_id: string
                            /** uploader ... */
                            uploader: string
                            /** next_uploader ... */
                            next_uploader: string
                            /** data_size ... */
                            data_size: string
                            /** bundle_size ... */
                            bundle_size: string
                            /** to_key ... */
                            to_key: string
                            /** bundle_summary ... */
                            bundle_summary: string
                            /** data_hash ... */
                            data_hash: string
                            /** updated_at ... */
                            updated_at: string
                            /** voters_valid ... */
                            voters_valid: Array<string>
                            /** voters_invalid ... */
                            voters_invalid: Array<string>
                            /** voters_abstain ... */
                            voters_abstain: Array<string>
                            /** from_key ... */
                            from_key: string
                        }
                        /** stakers ... */
                        stakers: Array<string>
                        /** total_stake ... */
                        total_self_delegation: string
                        /** total_delegation ... */
                        total_delegation: string
                        /** status ... */
                        status: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently. It will be empty if
                        there are no more results. */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Staker queries for all stakers. */
    Staker: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/staker/{address}' */
            kyve: `/kyve/query/v1beta1/staker/${string}`
        }
        params: {
            path: {
                kyve: {
                    /** address ... */
                    address: string
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryStakerResponse is the response type for the Query/Staker RPC method. */
                {
                    /** FullStaker aggregates information from the staker and its delegators
                    as well as pending queue entries into one object.
                    It contains almost all needed information for a convenient usage */
                    staker: {
                        /** address of the staker */
                        address: string
                        /** StakerMetadata contains static information for a staker */
                        metadata: {
                            /** commission is the percentage of the rewards that will
                            get transferred to the staker before the remaining
                            rewards are split across all delegators */
                            commission: string
                            /** moniker is a human-readable name for displaying
                            the staker in the UI */
                            moniker: string
                            /** website is a https-link to the website of the staker */
                            website: string
                            /** logo is a link to an image file (like jpg or png) */
                            logo: string
                            /** CommissionChangeEntry shows when the old commission
                            of a staker will change to the new commission */
                            pending_commission_change: {
                                /** commission is the new commission that will
                                become active once the change-time is over */
                                commission: string
                                /** creation_date is the UNIX-timestamp (in seconds)
                                of when the entry was created. */
                                creation_date: string
                            }
                        }
                        /** amount the staker has delegated to himself */
                        self_delegation: string
                        /** unbonding_amount is the amount the staker is currently unbonding
                        from the self-delegation.
                        This amount can be larger than `amount` when the staker
                        got slashed during unbonding. However, at the end of
                        the unbonding period this amount is double checked with the
                        remaining amount. */
                        self_delegation_unbonding: string
                        /** total_delegation returns the sum of all $KYVE users
                        have delegated to this staker */
                        total_delegation: string
                        /** delegator_count is the total number of individual
                        delegator addresses for that user. */
                        delegator_count: string
                        /** pools is a list of all pools the staker is currently
                        participating, i.e. allowed to vote and upload data. */
                        pools: Array<{
                            /** pool contains useful information about the pool */
                            pool: {
                                /** id is the ID of the pool */
                                id: string
                                /** name of the pool */
                                name: string
                                /** runtime for the protocol nodes
                                like evm, bitcoin, etc. */
                                runtime: string
                                /** logo of the pool */
                                logo: string
                                /** operating_cost is the base payout for each bundle reward */
                                operating_cost: string
                                /** upload_interval is the interval bundles get created */
                                upload_interval: string
                                /** total_funds of the pool. If the pool runs
                                out of funds no more bundles will be produced */
                                total_funds: string
                                /** total_delegation of the pool */
                                total_delegation: string
                                /** status of the pool if pool is able
                                to produce bundles, etc. */
                                status: string
                            }
                            /** points indicates if the staker is inactive
                            If the staker misses a vote, a point is added.
                            After 5 points the staker is removed from
                            the stakers set. */
                            points: string
                            /** is_leaving indicates if a user has scheduled a
                            a PoolLeave entry. After the leave-time is over
                            the staker will no longer participate in that pool */
                            is_leaving: boolean
                            /** Valaddress is the address which is authorized to vote
                            and submit bundles. If the server gets compromised
                            the staker can just change the valaddress. */
                            valaddress: string
                            /** balance is the valaddress account balance and indicates
                            whether or not the valaccount needs additional funds to
                            pay for gas fees */
                            balance: string
                        }>
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Stakers queries for all stakers. */
    Stakers: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/stakers' */
            kyve: `/kyve/query/v1beta1/stakers`
        }
        params: {
            path: {
                kyve: undefined
            }

            query: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                    /** status looks whether a staker is participating in pools or not.
                    
                     - STAKER_STATUS_UNSPECIFIED: STAKER_STATUS_UNSPECIFIED ...
                     - STAKER_STATUS_ACTIVE: STAKER_STATUS_ACTIVE ...
                     - STAKER_STATUS_INACTIVE: STAKER_STATUS_INACTIVE ... */
                    status: string
                    /** search searches for moniker OR address. */
                    search: string
                }
            }
            body: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                    /** status looks whether a staker is participating in pools or not.
                    
                     - STAKER_STATUS_UNSPECIFIED: STAKER_STATUS_UNSPECIFIED ...
                     - STAKER_STATUS_ACTIVE: STAKER_STATUS_ACTIVE ...
                     - STAKER_STATUS_INACTIVE: STAKER_STATUS_INACTIVE ... */
                    status: string
                    /** search searches for moniker OR address. */
                    search: string
                }
            }
        }
        response: {
            success: {
                kyve: /** QueryStakersResponse is the response type for the Query/Stakers RPC method. */
                {
                    /** stakers ... */
                    stakers: Array<{
                        /** address of the staker */
                        address: string
                        /** StakerMetadata contains static information for a staker */
                        metadata: {
                            /** commission is the percentage of the rewards that will
                            get transferred to the staker before the remaining
                            rewards are split across all delegators */
                            commission: string
                            /** moniker is a human-readable name for displaying
                            the staker in the UI */
                            moniker: string
                            /** website is a https-link to the website of the staker */
                            website: string
                            /** logo is a link to an image file (like jpg or png) */
                            logo: string
                            /** CommissionChangeEntry shows when the old commission
                            of a staker will change to the new commission */
                            pending_commission_change: {
                                /** commission is the new commission that will
                                become active once the change-time is over */
                                commission: string
                                /** creation_date is the UNIX-timestamp (in seconds)
                                of when the entry was created. */
                                creation_date: string
                            }
                        }
                        /** amount the staker has delegated to himself */
                        self_delegation: string
                        /** unbonding_amount is the amount the staker is currently unbonding
                        from the self-delegation.
                        This amount can be larger than `amount` when the staker
                        got slashed during unbonding. However, at the end of
                        the unbonding period this amount is double checked with the
                        remaining amount. */
                        self_delegation_unbonding: string
                        /** total_delegation returns the sum of all $KYVE users
                        have delegated to this staker */
                        total_delegation: string
                        /** delegator_count is the total number of individual
                        delegator addresses for that user. */
                        delegator_count: string
                        /** pools is a list of all pools the staker is currently
                        participating, i.e. allowed to vote and upload data. */
                        pools: Array<{
                            /** pool contains useful information about the pool */
                            pool: {
                                /** id is the ID of the pool */
                                id: string
                                /** name of the pool */
                                name: string
                                /** runtime for the protocol nodes
                                like evm, bitcoin, etc. */
                                runtime: string
                                /** logo of the pool */
                                logo: string
                                /** operating_cost is the base payout for each bundle reward */
                                operating_cost: string
                                /** upload_interval is the interval bundles get created */
                                upload_interval: string
                                /** total_funds of the pool. If the pool runs
                                out of funds no more bundles will be produced */
                                total_funds: string
                                /** total_delegation of the pool */
                                total_delegation: string
                                /** status of the pool if pool is able
                                to produce bundles, etc. */
                                status: string
                            }
                            /** points indicates if the staker is inactive
                            If the staker misses a vote, a point is added.
                            After 5 points the staker is removed from
                            the stakers set. */
                            points: string
                            /** is_leaving indicates if a user has scheduled a
                            a PoolLeave entry. After the leave-time is over
                            the staker will no longer participate in that pool */
                            is_leaving: boolean
                            /** Valaddress is the address which is authorized to vote
                            and submit bundles. If the server gets compromised
                            the staker can just change the valaddress. */
                            valaddress: string
                            /** balance is the valaddress account balance and indicates
                            whether or not the valaccount needs additional funds to
                            pay for gas fees */
                            balance: string
                        }>
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently. It will be empty if
                        there are no more results. */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** StakersByPool queries for all stakers that are currently participating in the given pool */
    StakersByPool: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/stakers_by_pool/{pool_id}' */
            kyve: `/kyve/query/v1beta1/stakers_by_pool/${number}`
        }
        params: {
            path: {
                kyve: {
                    /** pool_id ... */
                    pool_id: number
                }
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryStakersByPoolResponse is the response type for the Query/Staker RPC method. */
                {
                    /** stakers ... */
                    stakers: Array<{
                        /** FullStaker aggregates information from the staker and its delegators
                        as well as pending queue entries into one object.
                        It contains almost all needed information for a convenient usage */
                        staker: {
                            /** address of the staker */
                            address: string
                            /** StakerMetadata contains static information for a staker */
                            metadata: {
                                /** commission is the percentage of the rewards that will
                                get transferred to the staker before the remaining
                                rewards are split across all delegators */
                                commission: string
                                /** moniker is a human-readable name for displaying
                                the staker in the UI */
                                moniker: string
                                /** website is a https-link to the website of the staker */
                                website: string
                                /** logo is a link to an image file (like jpg or png) */
                                logo: string
                                /** CommissionChangeEntry shows when the old commission
                                of a staker will change to the new commission */
                                pending_commission_change: {
                                    /** commission is the new commission that will
                                    become active once the change-time is over */
                                    commission: string
                                    /** creation_date is the UNIX-timestamp (in seconds)
                                    of when the entry was created. */
                                    creation_date: string
                                }
                            }
                            /** amount the staker has delegated to himself */
                            self_delegation: string
                            /** unbonding_amount is the amount the staker is currently unbonding
                            from the self-delegation.
                            This amount can be larger than `amount` when the staker
                            got slashed during unbonding. However, at the end of
                            the unbonding period this amount is double checked with the
                            remaining amount. */
                            self_delegation_unbonding: string
                            /** total_delegation returns the sum of all $KYVE users
                            have delegated to this staker */
                            total_delegation: string
                            /** delegator_count is the total number of individual
                            delegator addresses for that user. */
                            delegator_count: string
                            /** pools is a list of all pools the staker is currently
                            participating, i.e. allowed to vote and upload data. */
                            pools: Array<{
                                /** pool contains useful information about the pool */
                                pool: {
                                    /** id is the ID of the pool */
                                    id: string
                                    /** name of the pool */
                                    name: string
                                    /** runtime for the protocol nodes
                                    like evm, bitcoin, etc. */
                                    runtime: string
                                    /** logo of the pool */
                                    logo: string
                                    /** operating_cost is the base payout for each bundle reward */
                                    operating_cost: string
                                    /** upload_interval is the interval bundles get created */
                                    upload_interval: string
                                    /** total_funds of the pool. If the pool runs
                                    out of funds no more bundles will be produced */
                                    total_funds: string
                                    /** total_delegation of the pool */
                                    total_delegation: string
                                    /** status of the pool if pool is able
                                    to produce bundles, etc. */
                                    status: string
                                }
                                /** points indicates if the staker is inactive
                                If the staker misses a vote, a point is added.
                                After 5 points the staker is removed from
                                the stakers set. */
                                points: string
                                /** is_leaving indicates if a user has scheduled a
                                a PoolLeave entry. After the leave-time is over
                                the staker will no longer participate in that pool */
                                is_leaving: boolean
                                /** Valaddress is the address which is authorized to vote
                                and submit bundles. If the server gets compromised
                                the staker can just change the valaddress. */
                                valaddress: string
                                /** balance is the valaddress account balance and indicates
                                whether or not the valaccount needs additional funds to
                                pay for gas fees */
                                balance: string
                            }>
                        }
                        /** valaccount ... */
                        valaccount: {
                            /** pool_id ... */
                            pool_id: string
                            /** staker ... */
                            staker: string
                            /** valaddress ... */
                            valaddress: string
                            /** points ... */
                            points: string
                            /** isLeaving ... */
                            is_leaving: boolean
                        }
                    }>
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** StakersByPool queries for all stakers and sorted them first by number of pools participating and
    then by delegation */
    StakersByPoolCount: {
        method: 'get'
        endpoint: {
            /** '/kyve/query/v1beta1/stakers_by_pool_count' */
            kyve: `/kyve/query/v1beta1/stakers_by_pool_count`
        }
        params: {
            path: {
                kyve: undefined
            }

            query: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                kyve: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                kyve: /** QueryStakersByPoolCountResponse ... */
                {
                    /** stakers ... */
                    stakers: Array<{
                        /** address of the staker */
                        address: string
                        /** StakerMetadata contains static information for a staker */
                        metadata: {
                            /** commission is the percentage of the rewards that will
                            get transferred to the staker before the remaining
                            rewards are split across all delegators */
                            commission: string
                            /** moniker is a human-readable name for displaying
                            the staker in the UI */
                            moniker: string
                            /** website is a https-link to the website of the staker */
                            website: string
                            /** logo is a link to an image file (like jpg or png) */
                            logo: string
                            /** CommissionChangeEntry shows when the old commission
                            of a staker will change to the new commission */
                            pending_commission_change: {
                                /** commission is the new commission that will
                                become active once the change-time is over */
                                commission: string
                                /** creation_date is the UNIX-timestamp (in seconds)
                                of when the entry was created. */
                                creation_date: string
                            }
                        }
                        /** amount the staker has delegated to himself */
                        self_delegation: string
                        /** unbonding_amount is the amount the staker is currently unbonding
                        from the self-delegation.
                        This amount can be larger than `amount` when the staker
                        got slashed during unbonding. However, at the end of
                        the unbonding period this amount is double checked with the
                        remaining amount. */
                        self_delegation_unbonding: string
                        /** total_delegation returns the sum of all $KYVE users
                        have delegated to this staker */
                        total_delegation: string
                        /** delegator_count is the total number of individual
                        delegator addresses for that user. */
                        delegator_count: string
                        /** pools is a list of all pools the staker is currently
                        participating, i.e. allowed to vote and upload data. */
                        pools: Array<{
                            /** pool contains useful information about the pool */
                            pool: {
                                /** id is the ID of the pool */
                                id: string
                                /** name of the pool */
                                name: string
                                /** runtime for the protocol nodes
                                like evm, bitcoin, etc. */
                                runtime: string
                                /** logo of the pool */
                                logo: string
                                /** operating_cost is the base payout for each bundle reward */
                                operating_cost: string
                                /** upload_interval is the interval bundles get created */
                                upload_interval: string
                                /** total_funds of the pool. If the pool runs
                                out of funds no more bundles will be produced */
                                total_funds: string
                                /** total_delegation of the pool */
                                total_delegation: string
                                /** status of the pool if pool is able
                                to produce bundles, etc. */
                                status: string
                            }
                            /** points indicates if the staker is inactive
                            If the staker misses a vote, a point is added.
                            After 5 points the staker is removed from
                            the stakers set. */
                            points: string
                            /** is_leaving indicates if a user has scheduled a
                            a PoolLeave entry. After the leave-time is over
                            the staker will no longer participate in that pool */
                            is_leaving: boolean
                            /** Valaddress is the address which is authorized to vote
                            and submit bundles. If the server gets compromised
                            the staker can just change the valaddress. */
                            valaddress: string
                            /** balance is the valaddress account balance and indicates
                            whether or not the valaccount needs additional funds to
                            pay for gas fees */
                            balance: string
                        }>
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently. It will be empty if
                        there are no more results. */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Parameters queries the parameters of the module. */
    StakersParams: {
        method: 'get'
        endpoint: {
            /** '/kyve/stakers/v1beta1/params' */
            kyve: `/kyve/stakers/v1beta1/params`
        }
        params: {
            path: {
                kyve: undefined
            }

            query: {
                kyve: undefined
            }
            body: {
                kyve: undefined
            }
        }
        response: {
            success: {
                kyve: /** QueryParamsResponse is response type for the Query/Params RPC method. */
                {
                    /** params holds all the parameters of this module. */
                    params: {
                        /** vote_slash ... */
                        vote_slash: string
                        /** upload_slash ... */
                        upload_slash: string
                        /** timeout_slash ... */
                        timeout_slash: string
                        /** unbonding_staking_time ... */
                        unbonding_staking_time: string
                        /** commission_change_time ... */
                        commission_change_time: string
                        /** commission_change_time ... */
                        leave_pool_time: string
                    }
                }
            }
            error: {
                kyve: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** ClaimsRecords returns all claims records */
    ClaimsRecords: {
        method: 'get'
        endpoint: {
            /** '/evmos/claims/v1/claims_records' */
            evmos: `/evmos/claims/v1/claims_records`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryClaimsRecordsResponse is the response type for the Query/ClaimsRecords
RPC method. */
                {
                    /** claims defines all claims records */
                    claims: Array<{
                        /** bech32 or hex address of claim user */
                        address: string
                        /** total initial claimable amount for the user */
                        initial_claimable_amount: string
                        /** slice of the available actions completed */
                        actions_completed: Array<boolean>
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** ClaimsRecord returns the claims record for a given address */
    ClaimsRecord: {
        method: 'get'
        endpoint: {
            /** '/evmos/claims/v1/claims_records/{address}' */
            evmos: `/evmos/claims/v1/claims_records/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** address defines the user to query claims record for */
                    address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryClaimsRecordResponse is the response type for the Query/ClaimsRecord RPC
method. */
                {
                    /** total initial claimable amount for the user */
                    initial_claimable_amount: string
                    /** the claims of the user */
                    claims: Array<{
                        /** action enum */
                        action: string
                        /** true if the action has been completed */
                        completed: boolean
                        /** claimable token amount for the action. Zero if completed */
                        claimable_amount: string
                    }>
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Params returns the claims module parameters */
    ClaimsParams: {
        method: 'get'
        endpoint: {
            /** '/evmos/claims/v1/params' */
            evmos: `/evmos/claims/v1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
                {
                    /** params defines the parameters of the module. */
                    params: {
                        /** enable claiming process */
                        enable_claims: boolean
                        /** timestamp of the airdrop start */
                        airdrop_start_time: string
                        /** duration until decay of claimable tokens begin */
                        duration_until_decay: string
                        /** duration of the token claim decay period */
                        duration_of_decay: string
                        /** denom of claimable coin */
                        claims_denom: string
                        /** list of authorized channel identifiers that can perform address
                        attestations via IBC. */
                        authorized_channels: Array<string>
                        /** list of channel identifiers from EVM compatible chains */
                        evm_channels: Array<string>
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** TotalUnclaimed queries the total unclaimed tokens from the airdrop */
    TotalUnclaimed: {
        method: 'get'
        endpoint: {
            /** '/evmos/claims/v1/total_unclaimed' */
            evmos: `/evmos/claims/v1/total_unclaimed`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryTotalUnclaimedResponse is the response type for the Query/TotalUnclaimed
RPC method. */
                {
                    /** coins defines the unclaimed coins */
                    coins: Array<{
                        denom: string
                        amount: string
                    }>
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** CurrentEpoch provide current epoch of specified identifier */
    CurrentEpoch: {
        method: 'get'
        endpoint: {
            /** '/evmos/epochs/v1/current_epoch' */
            evmos: `/evmos/epochs/v1/current_epoch`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    identifier: string
                }
            }
            body: {
                evmos: {
                    identifier: string
                }
            }
        }
        response: {
            success: {
                evmos: {
                    current_epoch: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** EpochInfos provide running epochInfos */
    EpochInfos: {
        method: 'get'
        endpoint: {
            /** '/evmos/epochs/v1/epochs' */
            evmos: `/evmos/epochs/v1/epochs`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: {
                    epochs: Array<{
                        identifier: string
                        start_time: string
                        duration: string
                        current_epoch: string
                        current_epoch_start_time: string
                        epoch_counting_started: boolean
                        current_epoch_start_height: string
                    }>
                    /** PageResponse is to be embedded in gRPC response messages where the
                    corresponding request message has used PageRequest.
                    
                     message SomeResponse {
                             repeated Bar results = 1;
                             PageResponse page = 2;
                     } */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Params retrieves the erc20 module params */
    ERC20Params: {
        method: 'get'
        endpoint: {
            /** '/evmos/erc20/v1/params' */
            evmos: `/evmos/erc20/v1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse is the response type for the Query/Params RPC
method. */
                {
                    /** Params defines the erc20 module params */
                    params: {
                        /** parameter to enable the conversion of Cosmos coins <--> ERC20 tokens. */
                        enable_erc20: boolean
                        /** parameter to enable the EVM hook that converts an ERC20 token to a Cosmos
                        Coin by transferring the Tokens through a MsgEthereumTx to the
                        ModuleAddress Ethereum address. */
                        enable_evm_hook: boolean
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** TokenPairs retrieves registered token pairs */
    TokenPairs: {
        method: 'get'
        endpoint: {
            /** '/evmos/erc20/v1/token_pairs' */
            evmos: `/evmos/erc20/v1/token_pairs`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryTokenPairsResponse is the response type for the Query/TokenPairs RPC
method. */
                {
                    token_pairs: Array<{
                        /** address of ERC20 contract token */
                        erc20_address: string
                        /** cosmos base denomination to be mapped to */
                        denom: string
                        /** shows token mapping enable status */
                        enabled: boolean
                        /** ERC20 owner address ENUM (0 invalid, 1 ModuleAccount, 2 external address) */
                        contract_owner: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** TokenPair retrieves a registered token pair */
    TokenPair: {
        method: 'get'
        endpoint: {
            /** '/evmos/erc20/v1/token_pairs/{token}' */
            evmos: `/evmos/erc20/v1/token_pairs/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** token identifier can be either the hex contract address of the ERC20 or the
                    Cosmos base denomination */
                    token: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryTokenPairResponse is the response type for the Query/TokenPair RPC
method. */
                {
                    /** TokenPair defines an instance that records a pairing consisting of a native
                     Cosmos Coin and an ERC20 token address. */
                    token_pair: {
                        /** address of ERC20 contract token */
                        erc20_address: string
                        /** cosmos base denomination to be mapped to */
                        denom: string
                        /** shows token mapping enable status */
                        enabled: boolean
                        /** ERC20 owner address ENUM (0 invalid, 1 ModuleAccount, 2 external address) */
                        contract_owner: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** AllocationMeters retrieves active allocation meters for a given
    denomination */
    AllocationMeters: {
        method: 'get'
        endpoint: {
            /** '/evmos/incentives/v1/allocation_meters' */
            evmos: `/evmos/incentives/v1/allocation_meters`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryAllocationMetersResponse is the response type for the
Query/AllocationMeters RPC method. */
                {
                    allocation_meters: Array<{
                        denom: string
                        amount: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** AllocationMeter Retrieves a active gas meter */
    AllocationMeter: {
        method: 'get'
        endpoint: {
            /** '/evmos/incentives/v1/allocation_meters/{denom}' */
            evmos: `/evmos/incentives/v1/allocation_meters/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** denom is the coin denom to query an allocation meter for. */
                    denom: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryAllocationMeterResponse is the response type for the
Query/AllocationMeter RPC method. */
                {
                    /** DecCoin defines a token with a denomination and a decimal amount.
                    
                    NOTE: The amount field is an Dec which implements the custom method
                    signatures required by gogoproto. */
                    allocation_meter: {
                        denom: string
                        amount: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** GasMeters retrieves active gas meters for a given contract */
    GasMeters: {
        method: 'get'
        endpoint: {
            /** '/evmos/incentives/v1/gas_meters/{contract}' */
            evmos: `/evmos/incentives/v1/gas_meters/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** contract is the hex contract address of a incentivized smart contract */
                    contract: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryGasMetersResponse is the response type for the Query/Incentives RPC
method. */
                {
                    gas_meters: Array<{
                        /** hex address of the incentivized contract */
                        contract: string
                        /** participant address that interacts with the incentive */
                        participant: string
                        /** cumulative gas spent during the epoch */
                        cumulative_gas: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** GasMeter Retrieves a active gas meter */
    GasMeter: {
        method: 'get'
        endpoint: {
            /** '/evmos/incentives/v1/gas_meters/{contract}/{participant}' */
            evmos: `/evmos/incentives/v1/gas_meters/${string}/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** contract identifier is the hex contract address of a contract */
                    contract: string
                    /** participant identifier is the hex address of a user */
                    participant: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryGasMeterResponse is the response type for the Query/Incentive RPC
method. */
                {
                    gas_meter: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Incentives retrieves registered incentives */
    Incentives: {
        method: 'get'
        endpoint: {
            /** '/evmos/incentives/v1/incentives' */
            evmos: `/evmos/incentives/v1/incentives`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryIncentivesResponse is the response type for the Query/Incentives RPC
method. */
                {
                    incentives: Array<{
                        /** contract address */
                        contract: string
                        /** denoms and percentage of rewards to be allocated */
                        allocations: Array<{
                            denom: string
                            amount: string
                        }>
                        /** number of remaining epochs */
                        epochs: number
                        /** distribution start time */
                        start_time: string
                        /** cumulative gas spent by all gasmeters of the incentive during the epoch */
                        total_gas: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Incentive retrieves a registered incentive */
    Incentive: {
        method: 'get'
        endpoint: {
            /** '/evmos/incentives/v1/incentives/{contract}' */
            evmos: `/evmos/incentives/v1/incentives/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** contract identifier is the hex contract address of a contract */
                    contract: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryIncentiveResponse is the response type for the Query/Incentive RPC
method. */
                {
                    /** Incentive defines an instance that organizes distribution conditions for a
                    given smart contract */
                    incentive: {
                        /** contract address */
                        contract: string
                        /** denoms and percentage of rewards to be allocated */
                        allocations: Array<{
                            denom: string
                            amount: string
                        }>
                        /** number of remaining epochs */
                        epochs: number
                        /** distribution start time */
                        start_time: string
                        /** cumulative gas spent by all gasmeters of the incentive during the epoch */
                        total_gas: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Params retrieves the incentives module params */
    IncentivesParams: {
        method: 'get'
        endpoint: {
            /** '/evmos/incentives/v1/params' */
            evmos: `/evmos/incentives/v1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse is the response type for the Query/Params RPC
method. */
                {
                    /** Params defines the incentives module params */
                    params: {
                        /** parameter to enable incentives */
                        enable_incentives: boolean
                        /** maximum percentage an incentive can allocate per denomination */
                        allocation_limit: string
                        /** identifier for the epochs module hooks */
                        incentives_epoch_identifier: string
                        /** scaling factor for capping rewards */
                        reward_scaler: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** CirculatingSupply retrieves the total number of tokens that are in
    circulation (i.e. excluding unvested tokens). */
    CirculatingSupply: {
        method: 'get'
        endpoint: {
            /** '/evmos/inflation/v1/circulating_supply' */
            evmos: `/evmos/inflation/v1/circulating_supply`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryCirculatingSupplyResponse is the response type for the
Query/CirculatingSupply RPC method. */
                {
                    /** total amount of coins in circulation */
                    circulating_supply: {
                        denom: string
                        amount: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** EpochMintProvision retrieves current minting epoch provision value. */
    EpochMintProvision: {
        method: 'get'
        endpoint: {
            /** '/evmos/inflation/v1/epoch_mint_provision' */
            evmos: `/evmos/inflation/v1/epoch_mint_provision`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryEpochMintProvisionResponse is the response type for the
Query/EpochMintProvision RPC method. */
                {
                    /** epoch_mint_provision is the current minting per epoch provision value. */
                    epoch_mint_provision: {
                        denom: string
                        amount: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** InflationRate retrieves the inflation rate of the current period. */
    InflationRate: {
        method: 'get'
        endpoint: {
            /** '/evmos/inflation/v1/inflation_rate' */
            evmos: `/evmos/inflation/v1/inflation_rate`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryInflationRateResponse is the response type for the Query/InflationRate
RPC method. */
                {
                    /** rate by which the total supply increases within one period */
                    inflation_rate: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Params retrieves the total set of minting parameters. */
    InflationParams: {
        method: 'get'
        endpoint: {
            /** '/evmos/inflation/v1/params' */
            evmos: `/evmos/inflation/v1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
                {
                    /** params defines the parameters of the module. */
                    params: {
                        /** type of coin to mint */
                        mint_denom: string
                        /** variables to calculate exponential inflation */
                        exponential_calculation: {
                            /** initial value */
                            a: string
                            /** reduction factor */
                            r: string
                            /** long term inflation */
                            c: string
                            /** bonding target */
                            bonding_target: string
                            /** max variance */
                            max_variance: string
                        }
                        /** inflation distribution of the minted denom */
                        inflation_distribution: {
                            /** staking_rewards defines the proportion of the minted minted_denom that is
                            to be allocated as staking rewards */
                            staking_rewards: string
                            /** usage_incentives defines the proportion of the minted minted_denom that is
                            to be allocated to the incentives module address */
                            usage_incentives: string
                            /** community_pool defines the proportion of the minted minted_denom that is to
                            be allocated to the community pool */
                            community_pool: string
                        }
                        /** parameter to enable inflation and halt increasing the skipped_epochs */
                        enable_inflation: boolean
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Period retrieves current period. */
    Period: {
        method: 'get'
        endpoint: {
            /** '/evmos/inflation/v1/period' */
            evmos: `/evmos/inflation/v1/period`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryPeriodResponse is the response type for the Query/Period RPC method. */
                {
                    /** period is the current minting per epoch provision value. */
                    period: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** SkippedEpochs retrieves the total number of skipped epochs. */
    SkippedEpochs: {
        method: 'get'
        endpoint: {
            /** '/evmos/inflation/v1/skipped_epochs' */
            evmos: `/evmos/inflation/v1/skipped_epochs`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QuerySkippedEpochsResponse is the response type for the Query/SkippedEpochs
RPC method. */
                {
                    /** number of epochs that the inflation module has been disabled. */
                    skipped_epochs: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Retrieves the unvested, vested and locked tokens for a vesting account */
    Balances: {
        method: 'get'
        endpoint: {
            /** '/evmos/vesting/v1/balances/{address}' */
            evmos: `/evmos/vesting/v1/balances/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** address of the clawback vesting account */
                    address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryBalancesResponse is the response type for the Query/Balances RPC
method. */
                {
                    /** current amount of locked tokens */
                    locked: Array<{
                        denom: string
                        amount: string
                    }>
                    /** current amount of unvested tokens */
                    unvested: Array<{
                        denom: string
                        amount: string
                    }>
                    /** current amount of vested tokens */
                    vested: Array<{
                        denom: string
                        amount: string
                    }>
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Params retrieves the total set of recovery parameters. */
    RecoveryParams: {
        method: 'get'
        endpoint: {
            /** '/evmos/recovery/v1/params' */
            evmos: `/evmos/recovery/v1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
                {
                    /** Params holds parameters for the recovery module */
                    params: {
                        /** enable recovery IBC middleware */
                        enable_recovery: boolean
                        /** duration added to timeout timestamp for balances recovered via IBC packets */
                        packet_timeout_duration: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Account queries an Ethereum account. */
    Account: {
        method: 'get'
        endpoint: {
            /** '/ethermint/evm/v1/account/{address}' */
            evmos: `/ethermint/evm/v1/account/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** address is the ethereum hex address to query the account for. */
                    address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryAccountResponse is the response type for the Query/Account RPC method. */
                {
                    /** balance is the balance of the EVM denomination. */
                    balance: string
                    /** code hash is the hex-formatted code bytes from the EOA. */
                    code_hash: string
                    /** nonce is the account's sequence number. */
                    nonce: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Balance queries the balance of a the EVM denomination for a single
    EthAccount. */
    Balance: {
        method: 'get'
        endpoint: {
            /** '/ethermint/evm/v1/balances/{address}' */
            evmos: `/ethermint/evm/v1/balances/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** address is the ethereum hex address to query the balance for. */
                    address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
                {
                    /** balance is the balance of the EVM denomination. */
                    balance: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** BaseFee queries the base fee of the parent block of the current block,
    it's similar to feemarket module's method, but also checks london hardfork status. */
    BaseFee: {
        method: 'get'
        endpoint: {
            /** '/ethermint/evm/v1/base_fee' */
            evmos: `/ethermint/evm/v1/base_fee`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** BaseFeeResponse returns the EIP1559 base fee. */
                {
                    base_fee: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Code queries the balance of all coins for a single account. */
    Code: {
        method: 'get'
        endpoint: {
            /** '/ethermint/evm/v1/codes/{address}' */
            evmos: `/ethermint/evm/v1/codes/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** address is the ethereum hex address to query the code for. */
                    address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryCodeResponse is the response type for the Query/Code RPC
method. */
                {
                    /** code represents the code bytes from an ethereum address. */
                    code: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** CosmosAccount queries an Ethereum account's Cosmos Address. */
    CosmosAccount: {
        method: 'get'
        endpoint: {
            /** '/ethermint/evm/v1/cosmos_account/{address}' */
            evmos: `/ethermint/evm/v1/cosmos_account/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** address is the ethereum hex address to query the account for. */
                    address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryCosmosAccountResponse is the response type for the Query/CosmosAccount
RPC method. */
                {
                    /** cosmos_address is the cosmos address of the account. */
                    cosmos_address: string
                    /** sequence is the account's sequence number. */
                    sequence: string
                    /** account_number is the account numbert */
                    account_number: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** EstimateGas implements the `eth_estimateGas` rpc api */
    EstimateGas: {
        method: 'get'
        endpoint: {
            /** '/ethermint/evm/v1/estimate_gas' */
            evmos: `/ethermint/evm/v1/estimate_gas`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** same json format as the json rpc api. */
                    args: string
                    /** the default gas cap to be used. */
                    gas_cap: number
                }
            }
            body: {
                evmos: {
                    /** same json format as the json rpc api. */
                    args: string
                    /** the default gas cap to be used. */
                    gas_cap: number
                }
            }
        }
        response: {
            success: {
                evmos: /** EstimateGasResponse defines EstimateGas response */
                {
                    /** the estimated gas */
                    gas: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** EthCall implements the `eth_call` rpc api */
    EthCall: {
        method: 'get'
        endpoint: {
            /** '/ethermint/evm/v1/eth_call' */
            evmos: `/ethermint/evm/v1/eth_call`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** same json format as the json rpc api. */
                    args: string
                    /** the default gas cap to be used. */
                    gas_cap: number
                }
            }
            body: {
                evmos: {
                    /** same json format as the json rpc api. */
                    args: string
                    /** the default gas cap to be used. */
                    gas_cap: number
                }
            }
        }
        response: {
            success: {
                evmos: /** MsgEthereumTxResponse defines the Msg/EthereumTx response type. */
                {
                    /** ethereum transaction hash in hex format. This hash differs from the
                    Tendermint sha256 hash of the transaction bytes. See
                    https://github.com/tendermint/tendermint/issues/6539 for reference */
                    hash: string
                    /** logs contains the transaction hash and the proto-compatible ethereum
                    logs. */
                    logs: Array<{
                        /** address of the contract that generated the event */
                        address: string
                        /** list of topics provided by the contract. */
                        topics: Array<string>
                        /** supplied by the contract, usually ABI-encoded */
                        data: string
                        /** block in which the transaction was included */
                        block_number: string
                        /** hash of the transaction */
                        tx_hash: string
                        /** index of the transaction in the block */
                        tx_index: string
                        /** hash of the block in which the transaction was included */
                        block_hash: string
                        /** index of the log in the block */
                        index: string
                        /** The Removed field is true if this log was reverted due to a chain
                        reorganisation. You must pay attention to this field if you receive logs
                        through a filter query. */
                        removed: boolean
                    }>
                    /** returned data from evm function (result or data supplied with revert
                    opcode) */
                    ret: string
                    /** vm error is the error returned by vm execution */
                    vm_error: string
                    /** gas consumed by the transaction */
                    gas_used: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Params queries the parameters of x/evm module. */
    EvmParams: {
        method: 'get'
        endpoint: {
            /** '/ethermint/evm/v1/params' */
            evmos: `/ethermint/evm/v1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse defines the response type for querying x/evm parameters. */
                {
                    /** Params defines the EVM module parameters */
                    params: {
                        /** evm denom represents the token denomination used to run the EVM state
                        transitions. */
                        evm_denom: string
                        /** enable create toggles state transitions that use the vm.Create function */
                        enable_create: boolean
                        /** enable call toggles state transitions that use the vm.Call function */
                        enable_call: boolean
                        /** extra eips defines the additional EIPs for the vm.Config */
                        extra_eips: Array<string>
                        /** chain config defines the EVM chain configuration parameters */
                        chain_config: {
                            /** Homestead switch block (nil no fork, 0 = already homestead) */
                            homestead_block: string
                            /** TheDAO hard-fork switch block (nil no fork) */
                            dao_fork_block: string
                            /** Whether the nodes supports or opposes the DAO hard-fork */
                            dao_fork_support: boolean
                            /** EIP150 implements the Gas price changes
                            (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork) */
                            eip150_block: string
                            /** EIP150 HF hash (needed for header only clients as only gas pricing changed) */
                            eip150_hash: string
                            /** EIP155Block HF block */
                            eip155_block: string
                            /** EIP158 HF block */
                            eip158_block: string
                            /** Byzantium switch block (nil no fork, 0 = already on byzantium) */
                            byzantium_block: string
                            /** Constantinople switch block (nil no fork, 0 = already activated) */
                            constantinople_block: string
                            /** Petersburg switch block (nil same as Constantinople) */
                            petersburg_block: string
                            /** Istanbul switch block (nil no fork, 0 = already on istanbul) */
                            istanbul_block: string
                            /** Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated) */
                            muir_glacier_block: string
                            /** Berlin switch block (nil = no fork, 0 = already on berlin) */
                            berlin_block: string
                            /** London switch block (nil = no fork, 0 = already on london) */
                            london_block: string
                            /** Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated) */
                            arrow_glacier_block: string
                            /** EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings) */
                            merge_fork_block: string
                        }
                        /** Allow unprotected transactions defines if replay-protected (i.e non EIP155 
                        signed) transactions can be executed on the state machine. */
                        allow_unprotected_txs: boolean
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Storage queries the balance of all coins for a single account. */
    Storage: {
        method: 'get'
        endpoint: {
            /** '/ethermint/evm/v1/storage/{address}/{key}' */
            evmos: `/ethermint/evm/v1/storage/${string}/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** / address is the ethereum hex address to query the storage state for. */
                    address: string
                    /** key defines the key of the storage state */
                    key: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryStorageResponse is the response type for the Query/Storage RPC
method. */
                {
                    /** key defines the storage state value hash associated with the given key. */
                    value: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** TraceBlock implements the `debug_traceBlockByNumber` and `debug_traceBlockByHash` rpc api */
    TraceBlock: {
        method: 'get'
        endpoint: {
            /** '/ethermint/evm/v1/trace_block' */
            evmos: `/ethermint/evm/v1/trace_block`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** custom javascript tracer. */
                    'trace_config.tracer': string
                    /** overrides the default timeout of 5 seconds for JavaScript-based tracing
                    calls. */
                    'trace_config.timeout': string
                    /** number of blocks the tracer is willing to go back. */
                    'trace_config.reexec': number
                    /** disable stack capture. */
                    'trace_config.disable_stack': string
                    /** disable storage capture. */
                    'trace_config.disable_storage': string
                    /** print output during capture end. */
                    'trace_config.debug': string
                    /** maximum length of output, but zero means unlimited. */
                    'trace_config.limit': number
                    /** Homestead switch block (nil no fork, 0 = already homestead). */
                    'trace_config.overrides.homestead_block': string
                    /** TheDAO hard-fork switch block (nil no fork). */
                    'trace_config.overrides.dao_fork_block': string
                    /** Whether the nodes supports or opposes the DAO hard-fork. */
                    'trace_config.overrides.dao_fork_support': string
                    /** EIP150 implements the Gas price changes
                    (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork). */
                    'trace_config.overrides.eip150_block': string
                    /** EIP150 HF hash (needed for header only clients as only gas pricing changed). */
                    'trace_config.overrides.eip150_hash': string
                    /** EIP155Block HF block. */
                    'trace_config.overrides.eip155_block': string
                    /** EIP158 HF block. */
                    'trace_config.overrides.eip158_block': string
                    /** Byzantium switch block (nil no fork, 0 = already on byzantium). */
                    'trace_config.overrides.byzantium_block': string
                    /** Constantinople switch block (nil no fork, 0 = already activated). */
                    'trace_config.overrides.constantinople_block': string
                    /** Petersburg switch block (nil same as Constantinople). */
                    'trace_config.overrides.petersburg_block': string
                    /** Istanbul switch block (nil no fork, 0 = already on istanbul). */
                    'trace_config.overrides.istanbul_block': string
                    /** Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated). */
                    'trace_config.overrides.muir_glacier_block': string
                    /** Berlin switch block (nil = no fork, 0 = already on berlin). */
                    'trace_config.overrides.berlin_block': string
                    /** London switch block (nil = no fork, 0 = already on london). */
                    'trace_config.overrides.london_block': string
                    /** Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated). */
                    'trace_config.overrides.arrow_glacier_block': string
                    /** EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings). */
                    'trace_config.overrides.merge_fork_block': string
                    /** enable memory capture. */
                    'trace_config.enable_memory': string
                    /** enable return data capture. */
                    'trace_config.enable_return_data': string
                    /** block number. */
                    block_number: number
                    /** block hex hash. */
                    block_hash: string
                    /** block time. */
                    block_time: string
                }
            }
            body: {
                evmos: {
                    /** custom javascript tracer. */
                    'trace_config.tracer': string
                    /** overrides the default timeout of 5 seconds for JavaScript-based tracing
                    calls. */
                    'trace_config.timeout': string
                    /** number of blocks the tracer is willing to go back. */
                    'trace_config.reexec': number
                    /** disable stack capture. */
                    'trace_config.disable_stack': string
                    /** disable storage capture. */
                    'trace_config.disable_storage': string
                    /** print output during capture end. */
                    'trace_config.debug': string
                    /** maximum length of output, but zero means unlimited. */
                    'trace_config.limit': number
                    /** Homestead switch block (nil no fork, 0 = already homestead). */
                    'trace_config.overrides.homestead_block': string
                    /** TheDAO hard-fork switch block (nil no fork). */
                    'trace_config.overrides.dao_fork_block': string
                    /** Whether the nodes supports or opposes the DAO hard-fork. */
                    'trace_config.overrides.dao_fork_support': string
                    /** EIP150 implements the Gas price changes
                    (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork). */
                    'trace_config.overrides.eip150_block': string
                    /** EIP150 HF hash (needed for header only clients as only gas pricing changed). */
                    'trace_config.overrides.eip150_hash': string
                    /** EIP155Block HF block. */
                    'trace_config.overrides.eip155_block': string
                    /** EIP158 HF block. */
                    'trace_config.overrides.eip158_block': string
                    /** Byzantium switch block (nil no fork, 0 = already on byzantium). */
                    'trace_config.overrides.byzantium_block': string
                    /** Constantinople switch block (nil no fork, 0 = already activated). */
                    'trace_config.overrides.constantinople_block': string
                    /** Petersburg switch block (nil same as Constantinople). */
                    'trace_config.overrides.petersburg_block': string
                    /** Istanbul switch block (nil no fork, 0 = already on istanbul). */
                    'trace_config.overrides.istanbul_block': string
                    /** Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated). */
                    'trace_config.overrides.muir_glacier_block': string
                    /** Berlin switch block (nil = no fork, 0 = already on berlin). */
                    'trace_config.overrides.berlin_block': string
                    /** London switch block (nil = no fork, 0 = already on london). */
                    'trace_config.overrides.london_block': string
                    /** Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated). */
                    'trace_config.overrides.arrow_glacier_block': string
                    /** EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings). */
                    'trace_config.overrides.merge_fork_block': string
                    /** enable memory capture. */
                    'trace_config.enable_memory': string
                    /** enable return data capture. */
                    'trace_config.enable_return_data': string
                    /** block number. */
                    block_number: number
                    /** block hex hash. */
                    block_hash: string
                    /** block time. */
                    block_time: string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryTraceBlockResponse defines TraceBlock response */
                {
                    data: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** TraceTx implements the `debug_traceTransaction` rpc api */
    TraceTx: {
        method: 'get'
        endpoint: {
            /** '/ethermint/evm/v1/trace_tx' */
            evmos: `/ethermint/evm/v1/trace_tx`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** A URL/resource name that uniquely identifies the type of the serialized
                    protocol buffer message. This string must contain at least
                    one "/" character. The last segment of the URL's path must represent
                    the fully qualified name of the type (as in
                    `path/google.protobuf.Duration`). The name should be in a canonical form
                    (e.g., leading "." is not accepted).
                    
                    In practice, teams usually precompile into the binary all types that they
                    expect it to use in the context of Any. However, for URLs which use the
                    scheme `http`, `https`, or no scheme, one can optionally set up a type
                    server that maps type URLs to message definitions as follows:
                    
                    * If no scheme is provided, `https` is assumed.
                    * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                      value in binary format, or produce an error.
                    * Applications are allowed to cache lookup results based on the
                      URL, or have them precompiled into a binary to avoid any
                      lookup. Therefore, binary compatibility needs to be preserved
                      on changes to types. (Use versioned type names to manage
                      breaking changes.)
                    
                    Note: this functionality is not currently available in the official
                    protobuf release, and it is not used for type URLs beginning with
                    type.googleapis.com.
                    
                    Schemes other than `http`, `https` (or the empty scheme) might be
                    used with implementation specific semantics. */
                    'msg.data.type_url': string
                    /** Must be a valid serialized protocol buffer of the above specified type. */
                    'msg.data.value': string
                    /** encoded storage size of the transaction. */
                    'msg.size': string
                    /** transaction hash in hex format. */
                    'msg.hash': string
                    /** ethereum signer address in hex format. This address value is checked
                    against the address derived from the signature (V, R, S) using the
                    secp256k1 elliptic curve. */
                    'msg.from': string
                    /** custom javascript tracer. */
                    'trace_config.tracer': string
                    /** overrides the default timeout of 5 seconds for JavaScript-based tracing
                    calls. */
                    'trace_config.timeout': string
                    /** number of blocks the tracer is willing to go back. */
                    'trace_config.reexec': number
                    /** disable stack capture. */
                    'trace_config.disable_stack': string
                    /** disable storage capture. */
                    'trace_config.disable_storage': string
                    /** print output during capture end. */
                    'trace_config.debug': string
                    /** maximum length of output, but zero means unlimited. */
                    'trace_config.limit': number
                    /** Homestead switch block (nil no fork, 0 = already homestead). */
                    'trace_config.overrides.homestead_block': string
                    /** TheDAO hard-fork switch block (nil no fork). */
                    'trace_config.overrides.dao_fork_block': string
                    /** Whether the nodes supports or opposes the DAO hard-fork. */
                    'trace_config.overrides.dao_fork_support': string
                    /** EIP150 implements the Gas price changes
                    (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork). */
                    'trace_config.overrides.eip150_block': string
                    /** EIP150 HF hash (needed for header only clients as only gas pricing changed). */
                    'trace_config.overrides.eip150_hash': string
                    /** EIP155Block HF block. */
                    'trace_config.overrides.eip155_block': string
                    /** EIP158 HF block. */
                    'trace_config.overrides.eip158_block': string
                    /** Byzantium switch block (nil no fork, 0 = already on byzantium). */
                    'trace_config.overrides.byzantium_block': string
                    /** Constantinople switch block (nil no fork, 0 = already activated). */
                    'trace_config.overrides.constantinople_block': string
                    /** Petersburg switch block (nil same as Constantinople). */
                    'trace_config.overrides.petersburg_block': string
                    /** Istanbul switch block (nil no fork, 0 = already on istanbul). */
                    'trace_config.overrides.istanbul_block': string
                    /** Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated). */
                    'trace_config.overrides.muir_glacier_block': string
                    /** Berlin switch block (nil = no fork, 0 = already on berlin). */
                    'trace_config.overrides.berlin_block': string
                    /** London switch block (nil = no fork, 0 = already on london). */
                    'trace_config.overrides.london_block': string
                    /** Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated). */
                    'trace_config.overrides.arrow_glacier_block': string
                    /** EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings). */
                    'trace_config.overrides.merge_fork_block': string
                    /** enable memory capture. */
                    'trace_config.enable_memory': string
                    /** enable return data capture. */
                    'trace_config.enable_return_data': string
                    /** block number of requested transaction. */
                    block_number: number
                    /** block hex hash of requested transaction. */
                    block_hash: string
                    /** block time of requested transaction. */
                    block_time: string
                }
            }
            body: {
                evmos: {
                    /** A URL/resource name that uniquely identifies the type of the serialized
                    protocol buffer message. This string must contain at least
                    one "/" character. The last segment of the URL's path must represent
                    the fully qualified name of the type (as in
                    `path/google.protobuf.Duration`). The name should be in a canonical form
                    (e.g., leading "." is not accepted).
                    
                    In practice, teams usually precompile into the binary all types that they
                    expect it to use in the context of Any. However, for URLs which use the
                    scheme `http`, `https`, or no scheme, one can optionally set up a type
                    server that maps type URLs to message definitions as follows:
                    
                    * If no scheme is provided, `https` is assumed.
                    * An HTTP GET on the URL must yield a [google.protobuf.Type][]
                      value in binary format, or produce an error.
                    * Applications are allowed to cache lookup results based on the
                      URL, or have them precompiled into a binary to avoid any
                      lookup. Therefore, binary compatibility needs to be preserved
                      on changes to types. (Use versioned type names to manage
                      breaking changes.)
                    
                    Note: this functionality is not currently available in the official
                    protobuf release, and it is not used for type URLs beginning with
                    type.googleapis.com.
                    
                    Schemes other than `http`, `https` (or the empty scheme) might be
                    used with implementation specific semantics. */
                    'msg.data.type_url': string
                    /** Must be a valid serialized protocol buffer of the above specified type. */
                    'msg.data.value': string
                    /** encoded storage size of the transaction. */
                    'msg.size': string
                    /** transaction hash in hex format. */
                    'msg.hash': string
                    /** ethereum signer address in hex format. This address value is checked
                    against the address derived from the signature (V, R, S) using the
                    secp256k1 elliptic curve. */
                    'msg.from': string
                    /** custom javascript tracer. */
                    'trace_config.tracer': string
                    /** overrides the default timeout of 5 seconds for JavaScript-based tracing
                    calls. */
                    'trace_config.timeout': string
                    /** number of blocks the tracer is willing to go back. */
                    'trace_config.reexec': number
                    /** disable stack capture. */
                    'trace_config.disable_stack': string
                    /** disable storage capture. */
                    'trace_config.disable_storage': string
                    /** print output during capture end. */
                    'trace_config.debug': string
                    /** maximum length of output, but zero means unlimited. */
                    'trace_config.limit': number
                    /** Homestead switch block (nil no fork, 0 = already homestead). */
                    'trace_config.overrides.homestead_block': string
                    /** TheDAO hard-fork switch block (nil no fork). */
                    'trace_config.overrides.dao_fork_block': string
                    /** Whether the nodes supports or opposes the DAO hard-fork. */
                    'trace_config.overrides.dao_fork_support': string
                    /** EIP150 implements the Gas price changes
                    (https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork). */
                    'trace_config.overrides.eip150_block': string
                    /** EIP150 HF hash (needed for header only clients as only gas pricing changed). */
                    'trace_config.overrides.eip150_hash': string
                    /** EIP155Block HF block. */
                    'trace_config.overrides.eip155_block': string
                    /** EIP158 HF block. */
                    'trace_config.overrides.eip158_block': string
                    /** Byzantium switch block (nil no fork, 0 = already on byzantium). */
                    'trace_config.overrides.byzantium_block': string
                    /** Constantinople switch block (nil no fork, 0 = already activated). */
                    'trace_config.overrides.constantinople_block': string
                    /** Petersburg switch block (nil same as Constantinople). */
                    'trace_config.overrides.petersburg_block': string
                    /** Istanbul switch block (nil no fork, 0 = already on istanbul). */
                    'trace_config.overrides.istanbul_block': string
                    /** Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated). */
                    'trace_config.overrides.muir_glacier_block': string
                    /** Berlin switch block (nil = no fork, 0 = already on berlin). */
                    'trace_config.overrides.berlin_block': string
                    /** London switch block (nil = no fork, 0 = already on london). */
                    'trace_config.overrides.london_block': string
                    /** Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated). */
                    'trace_config.overrides.arrow_glacier_block': string
                    /** EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings). */
                    'trace_config.overrides.merge_fork_block': string
                    /** enable memory capture. */
                    'trace_config.enable_memory': string
                    /** enable return data capture. */
                    'trace_config.enable_return_data': string
                    /** block number of requested transaction. */
                    block_number: number
                    /** block hex hash of requested transaction. */
                    block_hash: string
                    /** block time of requested transaction. */
                    block_time: string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryTraceTxResponse defines TraceTx response */
                {
                    /** response serialized in bytes */
                    data: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ValidatorAccount queries an Ethereum account's from a validator consensus
    Address. */
    ValidatorAccount: {
        method: 'get'
        endpoint: {
            /** '/ethermint/evm/v1/validator_account/{cons_address}' */
            evmos: `/ethermint/evm/v1/validator_account/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** cons_address is the validator cons address to query the account for. */
                    cons_address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryValidatorAccountResponse is the response type for the
Query/ValidatorAccount RPC method. */
                {
                    /** account_address is the cosmos address of the account in bech32 format. */
                    account_address: string
                    /** sequence is the account's sequence number. */
                    sequence: string
                    /** account_number is the account number */
                    account_number: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** BaseFee queries the base fee of the parent block of the current block. */
    FeeMarketBaseFee: {
        method: 'get'
        endpoint: {
            /** '/ethermint/feemarket/v1/base_fee' */
            evmos: `/ethermint/feemarket/v1/base_fee`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** BaseFeeResponse returns the EIP1559 base fee. */
                {
                    base_fee: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** BlockGas queries the gas used at a given block height */
    BlockGas: {
        method: 'get'
        endpoint: {
            /** '/ethermint/feemarket/v1/block_gas' */
            evmos: `/ethermint/feemarket/v1/block_gas`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryBlockGasResponse returns block gas used for a given height. */
                {
                    gas: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Params queries the parameters of x/feemarket module. */
    FeeMarketParams: {
        method: 'get'
        endpoint: {
            /** '/ethermint/feemarket/v1/params' */
            evmos: `/ethermint/feemarket/v1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse defines the response type for querying x/evm parameters. */
                {
                    /** Params defines the EVM module parameters */
                    params: {
                        /** no base fee forces the EIP-1559 base fee to 0 (needed for 0 price calls) */
                        no_base_fee: boolean
                        /** base fee change denominator bounds the amount the base fee can change
                        between blocks. */
                        base_fee_change_denominator: number
                        /** elasticity multiplier bounds the maximum gas limit an EIP-1559 block may
                        have. */
                        elasticity_multiplier: number
                        /** height at which the base fee calculation is enabled. */
                        enable_height: string
                        /** base fee for EIP-1559 blocks. */
                        base_fee: string
                        /** min_gas_price defines the minimum gas price value for cosmos and eth transactions */
                        min_gas_price: string
                        /** min gas denominator bounds the minimum gasUsed to be charged
                        to senders based on GasLimit */
                        min_gas_multiplier: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** DenomHash queries a denomination hash information. */
    DenomHash: {
        method: 'get'
        endpoint: {
            /** '/ibc/apps/transfer/v1/denom_hashes/{trace}' */
            evmos: `/ibc/apps/transfer/v1/denom_hashes/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** The denomination trace ([port_id]/[channel_id])+/[denom] */
                    trace: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryDenomHashResponse is the response type for the Query/DenomHash RPC
method. */
                {
                    /** hash (in hex format) of the denomination trace information. */
                    hash: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** DenomTraces queries all denomination traces. */
    DenomTraces: {
        method: 'get'
        endpoint: {
            /** '/ibc/apps/transfer/v1/denom_traces' */
            evmos: `/ibc/apps/transfer/v1/denom_traces`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryConnectionsResponse is the response type for the Query/DenomTraces RPC
method. */
                {
                    /** denom_traces returns all denominations trace information. */
                    denom_traces: Array<{
                        /** path defines the chain of port/channel identifiers used for tracing the
                        source of the fungible token. */
                        path: string
                        /** base denomination of the relayed fungible token. */
                        base_denom: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** DenomTrace queries a denomination trace information. */
    DenomTrace: {
        method: 'get'
        endpoint: {
            /** '/ibc/apps/transfer/v1/denom_traces/{hash}' */
            evmos: `/ibc/apps/transfer/v1/denom_traces/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** hash (in hex format) of the denomination trace information. */
                    hash: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC
method. */
                {
                    /** DenomTrace contains the base denomination for ICS20 fungible tokens and the
                    source tracing information path. */
                    denom_trace: {
                        /** path defines the chain of port/channel identifiers used for tracing the
                        source of the fungible token. */
                        path: string
                        /** base denomination of the relayed fungible token. */
                        base_denom: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Params queries all parameters of the ibc-transfer module. */
    TransferParams: {
        method: 'get'
        endpoint: {
            /** '/ibc/apps/transfer/v1/params' */
            evmos: `/ibc/apps/transfer/v1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
                {
                    /** params defines the parameters of the module. */
                    params: {
                        /** send_enabled enables or disables all cross-chain token transfers from this
                        chain. */
                        send_enabled: boolean
                        /** receive_enabled enables or disables all cross-chain token transfers to this
                        chain. */
                        receive_enabled: boolean
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** ClientParams queries all parameters of the ibc client. */
    ClientParams: {
        method: 'get'
        endpoint: {
            /** '/ibc/client/v1/params' */
            evmos: `/ibc/client/v1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryClientParamsResponse is the response type for the Query/ClientParams RPC
method. */
                {
                    /** params defines the parameters of the module. */
                    params: {
                        /** allowed_clients defines the list of allowed client state types. */
                        allowed_clients: Array<string>
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ClientStates queries all the IBC light clients of a chain. */
    ClientStates: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/client/v1/client_states' */
            evmos: `/ibc/core/client/v1/client_states`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryClientStatesResponse is the response type for the Query/ClientStates RPC
method. */
                {
                    /** list of stored ClientStates of the chain. */
                    client_states: Array<{
                        /** client identifier */
                        client_id: string
                        /** client state */
                        client_state: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                    }>
                    /** pagination response */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ClientState queries an IBC light client. */
    ClientState: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/client/v1/client_states/{client_id}' */
            evmos: `/ibc/core/client/v1/client_states/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** client state unique identifier */
                    client_id: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryClientStateResponse is the response type for the Query/ClientState RPC
method. Besides the client state, it includes a proof and the height from
which the proof was retrieved. */
                {
                    /** client state associated with the request identifier */
                    client_state: {
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was retrieved */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Status queries the status of an IBC client. */
    ClientStatus: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/client/v1/client_status/{client_id}' */
            evmos: `/ibc/core/client/v1/client_status/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** client unique identifier */
                    client_id: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryClientStatusResponse is the response type for the Query/ClientStatus RPC
method. It returns the current status of the IBC client. */
                {
                    status: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ConsensusStates queries all the consensus state associated with a given
    client. */
    ConsensusStates: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/client/v1/consensus_states/{client_id}' */
            evmos: `/ibc/core/client/v1/consensus_states/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** client identifier */
                    client_id: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryConsensusStatesResponse is the response type for the
Query/ConsensusStates RPC method */
                {
                    /** consensus states associated with the identifier */
                    consensus_states: Array<{
                        /** consensus state height */
                        height: {
                            /** the revision that the client is currently on */
                            revision_number: string
                            /** the height within the given revision */
                            revision_height: string
                        }
                        /** consensus state */
                        consensus_state: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                    }>
                    /** pagination response */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ConsensusState queries a consensus state associated with a client state at
    a given height. */
    ConsensusState: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}' */
            evmos: `/ibc/core/client/v1/consensus_states/${string}/revision/${number}/height/${number}`
        }
        params: {
            path: {
                evmos: {
                    /** client identifier */
                    client_id: string
                    /** consensus state revision number */
                    revision_number: number
                    /** consensus state revision height */
                    revision_height: number
                }
            }

            query: {
                evmos: {
                    /** latest_height overrrides the height field and queries the latest stored
                    ConsensusState. */
                    latest_height: string
                }
            }
            body: {
                evmos: {
                    /** latest_height overrrides the height field and queries the latest stored
                    ConsensusState. */
                    latest_height: string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryConsensusStateResponse is the response type for the Query/ConsensusState
RPC method */
                {
                    /** consensus state associated with the client identifier at the given height */
                    consensus_state: {
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was retrieved */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** UpgradedClientState queries an Upgraded IBC light client. */
    UpgradedClientState: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/client/v1/upgraded_client_states' */
            evmos: `/ibc/core/client/v1/upgraded_client_states`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryUpgradedClientStateResponse is the response type for the
Query/UpgradedClientState RPC method. */
                {
                    /** client state associated with the request identifier */
                    upgraded_client_state: {
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** UpgradedConsensusState queries an Upgraded IBC consensus state. */
    UpgradedConsensusState: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/client/v1/upgraded_consensus_states' */
            evmos: `/ibc/core/client/v1/upgraded_consensus_states`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryUpgradedConsensusStateResponse is the response type for the
Query/UpgradedConsensusState RPC method. */
                {
                    /** Consensus state associated with the request identifier */
                    upgraded_consensus_state: {
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ClientConnections queries the connection paths associated with a client
    state. */
    ClientConnections: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/connection/v1/client_connections/{client_id}' */
            evmos: `/ibc/core/connection/v1/client_connections/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** client identifier associated with a connection */
                    client_id: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryClientConnectionsResponse is the response type for the
Query/ClientConnections RPC method */
                {
                    /** slice of all the connection paths associated with a client. */
                    connection_paths: Array<string>
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was generated */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Connections queries all the IBC connections of a chain. */
    Connections: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/connection/v1/connections' */
            evmos: `/ibc/core/connection/v1/connections`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryConnectionsResponse is the response type for the Query/Connections RPC
method. */
                {
                    /** list of stored connections of the chain. */
                    connections: Array<{
                        /** connection identifier. */
                        id: string
                        /** client associated with this connection. */
                        client_id: string
                        /** IBC version which can be utilised to determine encodings or protocols for
                        channels or packets utilising this connection */
                        versions: Array<{
                            /** unique version identifier */
                            identifier: string
                            /** list of features compatible with the specified identifier */
                            features: Array<string>
                        }>
                        /** current state of the connection end. */
                        state: string
                        /** counterparty chain associated with this connection. */
                        counterparty: {
                            /** identifies the client on the counterparty chain associated with a given
                            connection. */
                            client_id: string
                            /** identifies the connection end on the counterparty chain associated with a
                            given connection. */
                            connection_id: string
                            /** MerklePrefix is merkle path prefixed to the key.
                            The constructed key from the Path and the key will be append(Path.KeyPath,
                            append(Path.KeyPrefix, key...)) */
                            prefix: {
                                key_prefix: string
                            }
                        }
                        /** delay period associated with this connection. */
                        delay_period: string
                    }>
                    /** pagination response */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                    /** query block height */
                    height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Connection queries an IBC connection end. */
    Connection: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/connection/v1/connections/{connection_id}' */
            evmos: `/ibc/core/connection/v1/connections/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** connection unique identifier */
                    connection_id: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryConnectionResponse is the response type for the Query/Connection RPC
method. Besides the connection end, it includes a proof and the height from
which the proof was retrieved. */
                {
                    /** connection associated with the request identifier */
                    connection: {
                        /** client associated with this connection. */
                        client_id: string
                        /** IBC version which can be utilised to determine encodings or protocols for
                        channels or packets utilising this connection. */
                        versions: Array<{
                            /** unique version identifier */
                            identifier: string
                            /** list of features compatible with the specified identifier */
                            features: Array<string>
                        }>
                        /** current state of the connection end. */
                        state: string
                        /** counterparty chain associated with this connection. */
                        counterparty: {
                            /** identifies the client on the counterparty chain associated with a given
                            connection. */
                            client_id: string
                            /** identifies the connection end on the counterparty chain associated with a
                            given connection. */
                            connection_id: string
                            /** MerklePrefix is merkle path prefixed to the key.
                            The constructed key from the Path and the key will be append(Path.KeyPath,
                            append(Path.KeyPrefix, key...)) */
                            prefix: {
                                key_prefix: string
                            }
                        }
                        /** delay period that must pass before a consensus state can be used for
                        packet-verification NOTE: delay period logic is only implemented by some
                        clients. */
                        delay_period: string
                    }
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was retrieved */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ConnectionClientState queries the client state associated with the
    connection. */
    ConnectionClientState: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/connection/v1/connections/{connection_id}/client_state' */
            evmos: `/ibc/core/connection/v1/connections/${string}/client_state`
        }
        params: {
            path: {
                evmos: {
                    /** connection identifier */
                    connection_id: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryConnectionClientStateResponse is the response type for the
Query/ConnectionClientState RPC method */
                {
                    /** client state associated with the channel */
                    identified_client_state: {
                        /** client identifier */
                        client_id: string
                        /** client state */
                        client_state: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                    }
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was retrieved */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ConnectionConsensusState queries the consensus state associated with the
    connection. */
    ConnectionConsensusState: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}' */
            evmos: `/ibc/core/connection/v1/connections/${string}/consensus_state/revision/${number}/height/${number}`
        }
        params: {
            path: {
                evmos: {
                    /** connection identifier */
                    connection_id: string
                    revision_number: number
                    revision_height: number
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryConnectionConsensusStateResponse is the response type for the
Query/ConnectionConsensusState RPC method */
                {
                    /** consensus state associated with the channel */
                    consensus_state: {
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }
                    /** client ID associated with the consensus state */
                    client_id: string
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was retrieved */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Channels queries all the IBC channels of a chain. */
    Channels: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/channels' */
            evmos: `/ibc/core/channel/v1/channels`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryChannelsResponse is the response type for the Query/Channels RPC method. */
                {
                    /** list of stored channels of the chain. */
                    channels: Array<{
                        /** current state of the channel end */
                        state: string
                        /** whether the channel is ordered or unordered */
                        ordering: string
                        /** counterparty channel end */
                        counterparty: {
                            /** port on the counterparty chain which owns the other end of the channel. */
                            port_id: string
                            /** channel end on the counterparty chain */
                            channel_id: string
                        }
                        /** list of connection identifiers, in order, along which packets sent on
                        this channel will travel */
                        connection_hops: Array<string>
                        /** opaque channel version, which is agreed upon during the handshake */
                        version: string
                        /** port identifier */
                        port_id: string
                        /** channel identifier */
                        channel_id: string
                    }>
                    /** pagination response */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                    /** query block height */
                    height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Channel queries an IBC Channel. */
    Channel: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}' */
            evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** channel unique identifier */
                    channel_id: string
                    /** port unique identifier */
                    port_id: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryChannelResponse is the response type for the Query/Channel RPC method.
Besides the Channel end, it includes a proof and the height from which the
proof was retrieved. */
                {
                    /** channel associated with the request identifiers */
                    channel: {
                        /** current state of the channel end */
                        state: string
                        /** whether the channel is ordered or unordered */
                        ordering: string
                        /** counterparty channel end */
                        counterparty: {
                            /** port on the counterparty chain which owns the other end of the channel. */
                            port_id: string
                            /** channel end on the counterparty chain */
                            channel_id: string
                        }
                        /** list of connection identifiers, in order, along which packets sent on
                        this channel will travel */
                        connection_hops: Array<string>
                        /** opaque channel version, which is agreed upon during the handshake */
                        version: string
                    }
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was retrieved */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ChannelClientState queries for the client state for the channel associated
    with the provided channel identifiers. */
    ChannelClientState: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state' */
            evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/client_state`
        }
        params: {
            path: {
                evmos: {
                    /** channel unique identifier */
                    channel_id: string
                    /** port unique identifier */
                    port_id: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryChannelClientStateResponse is the Response type for the
Query/QueryChannelClientState RPC method */
                {
                    /** client state associated with the channel */
                    identified_client_state: {
                        /** client identifier */
                        client_id: string
                        /** client state */
                        client_state: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                    }
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was retrieved */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ChannelConsensusState queries for the consensus state for the channel
    associated with the provided channel identifiers. */
    ChannelConsensusState: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}' */
            evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/consensus_state/revision/${number}/height/${number}`
        }
        params: {
            path: {
                evmos: {
                    /** channel unique identifier */
                    channel_id: string
                    /** port unique identifier */
                    port_id: string
                    /** revision number of the consensus state */
                    revision_number: number
                    /** revision height of the consensus state */
                    revision_height: number
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryChannelClientStateResponse is the Response type for the
Query/QueryChannelClientState RPC method */
                {
                    /** consensus state associated with the channel */
                    consensus_state: {
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }
                    /** client ID associated with the consensus state */
                    client_id: string
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was retrieved */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** NextSequenceReceive returns the next receive sequence for a given channel. */
    NextSequenceReceive: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence' */
            evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/next_sequence`
        }
        params: {
            path: {
                evmos: {
                    /** channel unique identifier */
                    channel_id: string
                    /** port unique identifier */
                    port_id: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QuerySequenceResponse is the request type for the
Query/QueryNextSequenceReceiveResponse RPC method */
                {
                    /** next sequence receive number */
                    next_sequence_receive: string
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was retrieved */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** PacketAcknowledgements returns all the packet acknowledgements associated
    with a channel. */
    PacketAcknowledgements: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements' */
            evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_acknowledgements`
        }
        params: {
            path: {
                evmos: {
                    /** channel unique identifier */
                    channel_id: string
                    /** port unique identifier */
                    port_id: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                    /** list of packet sequences. */
                    packet_commitment_sequences: string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                    /** list of packet sequences. */
                    packet_commitment_sequences: string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryPacketAcknowledgemetsResponse is the request type for the
Query/QueryPacketAcknowledgements RPC method */
                {
                    acknowledgements: Array<{
                        /** channel port identifier. */
                        port_id: string
                        /** channel unique identifier. */
                        channel_id: string
                        /** packet sequence. */
                        sequence: string
                        /** embedded data that represents packet state. */
                        data: string
                    }>
                    /** pagination response */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                    /** query block height */
                    height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** PacketAcknowledgement queries a stored packet acknowledgement hash. */
    PacketAcknowledgement: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}' */
            evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_acks/${number}`
        }
        params: {
            path: {
                evmos: {
                    /** channel unique identifier */
                    channel_id: string
                    /** port unique identifier */
                    port_id: string
                    /** packet sequence */
                    sequence: number
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryPacketAcknowledgementResponse defines the client query response for a
packet which also includes a proof and the height from which the
proof was retrieved */
                {
                    /** packet associated with the request fields */
                    acknowledgement: string
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was retrieved */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** PacketCommitments returns all the packet commitments hashes associated
    with a channel. */
    PacketCommitments: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments' */
            evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_commitments`
        }
        params: {
            path: {
                evmos: {
                    /** channel unique identifier */
                    channel_id: string
                    /** port unique identifier */
                    port_id: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryPacketCommitmentsResponse is the request type for the
Query/QueryPacketCommitments RPC method */
                {
                    commitments: Array<{
                        /** channel port identifier. */
                        port_id: string
                        /** channel unique identifier. */
                        channel_id: string
                        /** packet sequence. */
                        sequence: string
                        /** embedded data that represents packet state. */
                        data: string
                    }>
                    /** pagination response */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                    /** query block height */
                    height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** UnreceivedAcks returns all the unreceived IBC acknowledgements associated
    with a channel and sequences. */
    UnreceivedAcks: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks' */
            evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_commitments/${string}/unreceived_acks`
        }
        params: {
            path: {
                evmos: {
                    /** channel unique identifier */
                    channel_id: string
                    /** port unique identifier */
                    port_id: string
                    /** list of acknowledgement sequences */
                    packet_ack_sequences: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryUnreceivedAcksResponse is the response type for the
Query/UnreceivedAcks RPC method */
                {
                    /** list of unreceived acknowledgement sequences */
                    sequences: Array<string>
                    /** query block height */
                    height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** UnreceivedPackets returns all the unreceived IBC packets associated with a
    channel and sequences. */
    UnreceivedPackets: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets' */
            evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_commitments/${string}/unreceived_packets`
        }
        params: {
            path: {
                evmos: {
                    /** channel unique identifier */
                    channel_id: string
                    /** port unique identifier */
                    port_id: string
                    /** list of packet sequences */
                    packet_commitment_sequences: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryUnreceivedPacketsResponse is the response type for the
Query/UnreceivedPacketCommitments RPC method */
                {
                    /** list of unreceived packet sequences */
                    sequences: Array<string>
                    /** query block height */
                    height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** PacketCommitment queries a stored packet commitment hash. */
    PacketCommitment: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}' */
            evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_commitments/${number}`
        }
        params: {
            path: {
                evmos: {
                    /** channel unique identifier */
                    channel_id: string
                    /** port unique identifier */
                    port_id: string
                    /** packet sequence */
                    sequence: number
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryPacketCommitmentResponse defines the client query response for a packet
which also includes a proof and the height from which the proof was
retrieved */
                {
                    /** packet associated with the request fields */
                    commitment: string
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was retrieved */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** PacketReceipt queries if a given packet sequence has been received on the
    queried chain */
    PacketReceipt: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}' */
            evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_receipts/${number}`
        }
        params: {
            path: {
                evmos: {
                    /** channel unique identifier */
                    channel_id: string
                    /** port unique identifier */
                    port_id: string
                    /** packet sequence */
                    sequence: number
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryPacketReceiptResponse defines the client query response for a packet
receipt which also includes a proof, and the height from which the proof was
retrieved */
                {
                    /** success flag for if receipt exists */
                    received: boolean
                    /** merkle proof of existence */
                    proof: string
                    /** height at which the proof was retrieved */
                    proof_height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ConnectionChannels queries all the channels associated with a connection
    end. */
    ConnectionChannels: {
        method: 'get'
        endpoint: {
            /** '/ibc/core/channel/v1/connections/{connection}/channels' */
            evmos: `/ibc/core/channel/v1/connections/${string}/channels`
        }
        params: {
            path: {
                evmos: {
                    /** connection unique identifier */
                    connection: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryConnectionChannelsResponse is the Response type for the
Query/QueryConnectionChannels RPC method */
                {
                    /** list of channels associated with a connection. */
                    channels: Array<{
                        /** current state of the channel end */
                        state: string
                        /** whether the channel is ordered or unordered */
                        ordering: string
                        /** counterparty channel end */
                        counterparty: {
                            /** port on the counterparty chain which owns the other end of the channel. */
                            port_id: string
                            /** channel end on the counterparty chain */
                            channel_id: string
                        }
                        /** list of connection identifiers, in order, along which packets sent on
                        this channel will travel */
                        connection_hops: Array<string>
                        /** opaque channel version, which is agreed upon during the handshake */
                        version: string
                        /** port identifier */
                        port_id: string
                        /** channel identifier */
                        channel_id: string
                    }>
                    /** pagination response */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                    /** query block height */
                    height: {
                        /** the revision that the client is currently on */
                        revision_number: string
                        /** the height within the given revision */
                        revision_height: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Accounts returns all the existing accounts */
    Accounts: {
        method: 'get'
        endpoint: {
            /** '/cosmos/auth/v1beta1/accounts' */
            evmos: `/cosmos/auth/v1beta1/accounts`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryAccountsResponse is the response type for the Query/Accounts RPC method.

Since: cosmos-sdk 0.43 */
                {
                    /** accounts are the existing accounts */
                    accounts: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Account returns account details based on address. */
    AuthAccount: {
        method: 'get'
        endpoint: {
            /** '/cosmos/auth/v1beta1/accounts/{address}' */
            evmos: `/cosmos/auth/v1beta1/accounts/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** address defines the address to query for. */
                    address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryAccountResponse is the response type for the Query/Account RPC method. */
                {
                    /** `Any` contains an arbitrary serialized protocol buffer message along with a
                    URL that describes the type of the serialized message.
                    
                    Protobuf library provides support to pack/unpack Any values in the form
                    of utility functions or additional generated methods of the Any type.
                    
                    Example 1: Pack and unpack a message in C++.
                    
                        Foo foo = ...;
                        Any any;
                        any.PackFrom(foo);
                        ...
                        if (any.UnpackTo(&foo)) {
                          ...
                        }
                    
                    Example 2: Pack and unpack a message in Java.
                    
                        Foo foo = ...;
                        Any any = Any.pack(foo);
                        ...
                        if (any.is(Foo.class)) {
                          foo = any.unpack(Foo.class);
                        }
                    
                     Example 3: Pack and unpack a message in Python.
                    
                        foo = Foo(...)
                        any = Any()
                        any.Pack(foo)
                        ...
                        if any.Is(Foo.DESCRIPTOR):
                          any.Unpack(foo)
                          ...
                    
                     Example 4: Pack and unpack a message in Go
                    
                         foo := &pb.Foo{...}
                         any, err := anypb.New(foo)
                         if err != nil {
                           ...
                         }
                         ...
                         foo := &pb.Foo{}
                         if err := any.UnmarshalTo(foo); err != nil {
                           ...
                         }
                    
                    The pack methods provided by protobuf library will by default use
                    'type.googleapis.com/full.type.name' as the type URL and the unpack
                    methods only use the fully qualified type name after the last '/'
                    in the type URL, for example "foo.bar.com/x/y.z" will yield type
                    name "y.z".
                    
                    
                    JSON
                    ====
                    The JSON representation of an `Any` value uses the regular
                    representation of the deserialized, embedded message, with an
                    additional field `@type` which contains the type URL. Example:
                    
                        package google.profile;
                        message Person {
                          string first_name = 1;
                          string last_name = 2;
                        }
                    
                        {
                          "@type": "type.googleapis.com/google.profile.Person",
                          "firstName": <string>,
                          "lastName": <string>
                        }
                    
                    If the embedded message type is well-known and has a custom JSON
                    representation, that representation will be embedded adding a field
                    `value` which holds the custom JSON in addition to the `@type`
                    field. Example (for message [google.protobuf.Duration][]):
                    
                        {
                          "@type": "type.googleapis.com/google.protobuf.Duration",
                          "value": "1.212s"
                        } */
                    account: {
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Params queries all parameters. */
    AuthParams: {
        method: 'get'
        endpoint: {
            /** '/cosmos/auth/v1beta1/params' */
            evmos: `/cosmos/auth/v1beta1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
                {
                    /** params defines the parameters of the module. */
                    params: {
                        max_memo_characters: string
                        tx_sig_limit: string
                        tx_size_cost_per_byte: string
                        sig_verify_cost_ed25519: string
                        sig_verify_cost_secp256k1: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Returns list of `Authorization`, granted to the grantee by the granter. */
    Grants: {
        method: 'get'
        endpoint: {
            /** '/cosmos/authz/v1beta1/grants' */
            evmos: `/cosmos/authz/v1beta1/grants`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    granter: string
                    grantee: string
                    /** Optional, msg_type_url, when set, will query only grants matching given msg type. */
                    msg_type_url: string
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    granter: string
                    grantee: string
                    /** Optional, msg_type_url, when set, will query only grants matching given msg type. */
                    msg_type_url: string
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryGrantsResponse is the response type for the Query/Authorizations RPC method. */
                {
                    /** authorizations is a list of grants granted for grantee by granter. */
                    grants: Array<{
                        /** `Any` contains an arbitrary serialized protocol buffer message along with a
                        URL that describes the type of the serialized message.
                        
                        Protobuf library provides support to pack/unpack Any values in the form
                        of utility functions or additional generated methods of the Any type.
                        
                        Example 1: Pack and unpack a message in C++.
                        
                            Foo foo = ...;
                            Any any;
                            any.PackFrom(foo);
                            ...
                            if (any.UnpackTo(&foo)) {
                              ...
                            }
                        
                        Example 2: Pack and unpack a message in Java.
                        
                            Foo foo = ...;
                            Any any = Any.pack(foo);
                            ...
                            if (any.is(Foo.class)) {
                              foo = any.unpack(Foo.class);
                            }
                        
                         Example 3: Pack and unpack a message in Python.
                        
                            foo = Foo(...)
                            any = Any()
                            any.Pack(foo)
                            ...
                            if any.Is(Foo.DESCRIPTOR):
                              any.Unpack(foo)
                              ...
                        
                         Example 4: Pack and unpack a message in Go
                        
                             foo := &pb.Foo{...}
                             any, err := anypb.New(foo)
                             if err != nil {
                               ...
                             }
                             ...
                             foo := &pb.Foo{}
                             if err := any.UnmarshalTo(foo); err != nil {
                               ...
                             }
                        
                        The pack methods provided by protobuf library will by default use
                        'type.googleapis.com/full.type.name' as the type URL and the unpack
                        methods only use the fully qualified type name after the last '/'
                        in the type URL, for example "foo.bar.com/x/y.z" will yield type
                        name "y.z".
                        
                        
                        JSON
                        ====
                        The JSON representation of an `Any` value uses the regular
                        representation of the deserialized, embedded message, with an
                        additional field `@type` which contains the type URL. Example:
                        
                            package google.profile;
                            message Person {
                              string first_name = 1;
                              string last_name = 2;
                            }
                        
                            {
                              "@type": "type.googleapis.com/google.profile.Person",
                              "firstName": <string>,
                              "lastName": <string>
                            }
                        
                        If the embedded message type is well-known and has a custom JSON
                        representation, that representation will be embedded adding a field
                        `value` which holds the custom JSON in addition to the `@type`
                        field. Example (for message [google.protobuf.Duration][]):
                        
                            {
                              "@type": "type.googleapis.com/google.protobuf.Duration",
                              "value": "1.212s"
                            } */
                        authorization: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                        expiration: string
                    }>
                    /** pagination defines an pagination for the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** GranteeGrants returns a list of `GrantAuthorization` by grantee. */
    GranteeGrants: {
        method: 'get'
        endpoint: {
            /** '/cosmos/authz/v1beta1/grants/grantee/{grantee}' */
            evmos: `/cosmos/authz/v1beta1/grants/grantee/${string}`
        }
        params: {
            path: {
                evmos: {
                    grantee: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method. */
                {
                    /** grants is a list of grants granted to the grantee. */
                    grants: Array<{
                        granter: string
                        grantee: string
                        /** `Any` contains an arbitrary serialized protocol buffer message along with a
                        URL that describes the type of the serialized message.
                        
                        Protobuf library provides support to pack/unpack Any values in the form
                        of utility functions or additional generated methods of the Any type.
                        
                        Example 1: Pack and unpack a message in C++.
                        
                            Foo foo = ...;
                            Any any;
                            any.PackFrom(foo);
                            ...
                            if (any.UnpackTo(&foo)) {
                              ...
                            }
                        
                        Example 2: Pack and unpack a message in Java.
                        
                            Foo foo = ...;
                            Any any = Any.pack(foo);
                            ...
                            if (any.is(Foo.class)) {
                              foo = any.unpack(Foo.class);
                            }
                        
                         Example 3: Pack and unpack a message in Python.
                        
                            foo = Foo(...)
                            any = Any()
                            any.Pack(foo)
                            ...
                            if any.Is(Foo.DESCRIPTOR):
                              any.Unpack(foo)
                              ...
                        
                         Example 4: Pack and unpack a message in Go
                        
                             foo := &pb.Foo{...}
                             any, err := anypb.New(foo)
                             if err != nil {
                               ...
                             }
                             ...
                             foo := &pb.Foo{}
                             if err := any.UnmarshalTo(foo); err != nil {
                               ...
                             }
                        
                        The pack methods provided by protobuf library will by default use
                        'type.googleapis.com/full.type.name' as the type URL and the unpack
                        methods only use the fully qualified type name after the last '/'
                        in the type URL, for example "foo.bar.com/x/y.z" will yield type
                        name "y.z".
                        
                        
                        JSON
                        ====
                        The JSON representation of an `Any` value uses the regular
                        representation of the deserialized, embedded message, with an
                        additional field `@type` which contains the type URL. Example:
                        
                            package google.profile;
                            message Person {
                              string first_name = 1;
                              string last_name = 2;
                            }
                        
                            {
                              "@type": "type.googleapis.com/google.profile.Person",
                              "firstName": <string>,
                              "lastName": <string>
                            }
                        
                        If the embedded message type is well-known and has a custom JSON
                        representation, that representation will be embedded adding a field
                        `value` which holds the custom JSON in addition to the `@type`
                        field. Example (for message [google.protobuf.Duration][]):
                        
                            {
                              "@type": "type.googleapis.com/google.protobuf.Duration",
                              "value": "1.212s"
                            } */
                        authorization: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                        expiration: string
                    }>
                    /** pagination defines an pagination for the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** GranterGrants returns list of `GrantAuthorization`, granted by granter. */
    GranterGrants: {
        method: 'get'
        endpoint: {
            /** '/cosmos/authz/v1beta1/grants/granter/{granter}' */
            evmos: `/cosmos/authz/v1beta1/grants/granter/${string}`
        }
        params: {
            path: {
                evmos: {
                    granter: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method. */
                {
                    /** grants is a list of grants granted by the granter. */
                    grants: Array<{
                        granter: string
                        grantee: string
                        /** `Any` contains an arbitrary serialized protocol buffer message along with a
                        URL that describes the type of the serialized message.
                        
                        Protobuf library provides support to pack/unpack Any values in the form
                        of utility functions or additional generated methods of the Any type.
                        
                        Example 1: Pack and unpack a message in C++.
                        
                            Foo foo = ...;
                            Any any;
                            any.PackFrom(foo);
                            ...
                            if (any.UnpackTo(&foo)) {
                              ...
                            }
                        
                        Example 2: Pack and unpack a message in Java.
                        
                            Foo foo = ...;
                            Any any = Any.pack(foo);
                            ...
                            if (any.is(Foo.class)) {
                              foo = any.unpack(Foo.class);
                            }
                        
                         Example 3: Pack and unpack a message in Python.
                        
                            foo = Foo(...)
                            any = Any()
                            any.Pack(foo)
                            ...
                            if any.Is(Foo.DESCRIPTOR):
                              any.Unpack(foo)
                              ...
                        
                         Example 4: Pack and unpack a message in Go
                        
                             foo := &pb.Foo{...}
                             any, err := anypb.New(foo)
                             if err != nil {
                               ...
                             }
                             ...
                             foo := &pb.Foo{}
                             if err := any.UnmarshalTo(foo); err != nil {
                               ...
                             }
                        
                        The pack methods provided by protobuf library will by default use
                        'type.googleapis.com/full.type.name' as the type URL and the unpack
                        methods only use the fully qualified type name after the last '/'
                        in the type URL, for example "foo.bar.com/x/y.z" will yield type
                        name "y.z".
                        
                        
                        JSON
                        ====
                        The JSON representation of an `Any` value uses the regular
                        representation of the deserialized, embedded message, with an
                        additional field `@type` which contains the type URL. Example:
                        
                            package google.profile;
                            message Person {
                              string first_name = 1;
                              string last_name = 2;
                            }
                        
                            {
                              "@type": "type.googleapis.com/google.profile.Person",
                              "firstName": <string>,
                              "lastName": <string>
                            }
                        
                        If the embedded message type is well-known and has a custom JSON
                        representation, that representation will be embedded adding a field
                        `value` which holds the custom JSON in addition to the `@type`
                        field. Example (for message [google.protobuf.Duration][]):
                        
                            {
                              "@type": "type.googleapis.com/google.protobuf.Duration",
                              "value": "1.212s"
                            } */
                        authorization: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                        expiration: string
                    }>
                    /** pagination defines an pagination for the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** AllBalances queries the balance of all coins for a single account. */
    AllBalances: {
        method: 'get'
        endpoint: {
            /** '/cosmos/bank/v1beta1/balances/{address}' */
            evmos: `/cosmos/bank/v1beta1/balances/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** address is the address to query balances for. */
                    address: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
method. */
                {
                    /** balances is the balances of all the coins. */
                    balances: Array<{
                        denom: string
                        amount: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Balance queries the balance of a single coin for a single account. */
    BankBalance: {
        method: 'get'
        endpoint: {
            /** '/cosmos/bank/v1beta1/balances/{address}/by_denom' */
            evmos: `/cosmos/bank/v1beta1/balances/${string}/by_denom`
        }
        params: {
            path: {
                evmos: {
                    /** address is the address to query balances for. */
                    address: string
                }
            }

            query: {
                evmos: {
                    /** denom is the coin denom to query balances for. */
                    denom: string
                }
            }
            body: {
                evmos: {
                    /** denom is the coin denom to query balances for. */
                    denom: string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
                {
                    /** Coin defines a token with a denomination and an amount.
                    
                    NOTE: The amount field is an Int which implements the custom method
                    signatures required by gogoproto. */
                    balance: {
                        denom: string
                        amount: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** DenomsMetadata queries the client metadata for all registered coin denominations. */
    DenomsMetadata: {
        method: 'get'
        endpoint: {
            /** '/cosmos/bank/v1beta1/denoms_metadata' */
            evmos: `/cosmos/bank/v1beta1/denoms_metadata`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
method. */
                {
                    /** metadata provides the client information for all the registered tokens. */
                    metadatas: Array<{
                        description: string
                        /** denom_units represents the list of DenomUnit's for a given coin */
                        denom_units: Array<{
                            /** denom represents the string name of the given denom unit (e.g uatom). */
                            denom: string
                            /** exponent represents power of 10 exponent that one must
                            raise the base_denom to in order to equal the given DenomUnit's denom
                            1 denom = 1^exponent base_denom
                            (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
                            exponent = 6, thus: 1 atom = 10^6 uatom). */
                            exponent: number
                            /** aliases is a list of string aliases for the given denom */
                            aliases: Array<string>
                        }>
                        /** base represents the base denom (should be the DenomUnit with exponent = 0). */
                        base: string
                        /** display indicates the suggested denom that should be
                        displayed in clients. */
                        display: string
                        /** name defines the name of the token (eg: Cosmos Atom) */
                        name: string
                        /** symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
                        be the same as the display.
                        
                        Since: cosmos-sdk 0.43 */
                        symbol: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** DenomsMetadata queries the client metadata of a given coin denomination. */
    DenomMetadata: {
        method: 'get'
        endpoint: {
            /** '/cosmos/bank/v1beta1/denoms_metadata/{denom}' */
            evmos: `/cosmos/bank/v1beta1/denoms_metadata/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** denom is the coin denom to query the metadata for. */
                    denom: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
method. */
                {
                    /** Metadata represents a struct that describes
                    a basic token. */
                    metadata: {
                        description: string
                        /** denom_units represents the list of DenomUnit's for a given coin */
                        denom_units: Array<{
                            /** denom represents the string name of the given denom unit (e.g uatom). */
                            denom: string
                            /** exponent represents power of 10 exponent that one must
                            raise the base_denom to in order to equal the given DenomUnit's denom
                            1 denom = 1^exponent base_denom
                            (e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
                            exponent = 6, thus: 1 atom = 10^6 uatom). */
                            exponent: number
                            /** aliases is a list of string aliases for the given denom */
                            aliases: Array<string>
                        }>
                        /** base represents the base denom (should be the DenomUnit with exponent = 0). */
                        base: string
                        /** display indicates the suggested denom that should be
                        displayed in clients. */
                        display: string
                        /** name defines the name of the token (eg: Cosmos Atom) */
                        name: string
                        /** symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
                        be the same as the display.
                        
                        Since: cosmos-sdk 0.43 */
                        symbol: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Params queries the parameters of x/bank module. */
    BankParams: {
        method: 'get'
        endpoint: {
            /** '/cosmos/bank/v1beta1/params' */
            evmos: `/cosmos/bank/v1beta1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse defines the response type for querying x/bank parameters. */
                {
                    /** Params defines the parameters for the bank module. */
                    params: {
                        send_enabled: Array<{
                            denom: string
                            enabled: boolean
                        }>
                        default_send_enabled: boolean
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** SpendableBalances queries the spenable balance of all coins for a single
    account. */
    SpendableBalances: {
        method: 'get'
        endpoint: {
            /** '/cosmos/bank/v1beta1/spendable_balances/{address}' */
            evmos: `/cosmos/bank/v1beta1/spendable_balances/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** address is the address to query spendable balances for. */
                    address: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QuerySpendableBalancesResponse defines the gRPC response structure for querying
an account's spendable balances. */
                {
                    /** balances is the spendable balances of all the coins. */
                    balances: Array<{
                        denom: string
                        amount: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** TotalSupply queries the total supply of all coins. */
    TotalSupply: {
        method: 'get'
        endpoint: {
            /** '/cosmos/bank/v1beta1/supply' */
            evmos: `/cosmos/bank/v1beta1/supply`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
method */
                {
                    /** supply is the supply of the coins */
                    supply: Array<{
                        denom: string
                        amount: string
                    }>
                    /** pagination defines the pagination in the response.
                    
                    Since: cosmos-sdk 0.43 */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** SupplyOf queries the supply of a single coin. */
    SupplyOf: {
        method: 'get'
        endpoint: {
            /** '/cosmos/bank/v1beta1/supply/{denom}' */
            evmos: `/cosmos/bank/v1beta1/supply/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** denom is the coin denom to query balances for. */
                    denom: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method. */
                {
                    /** Coin defines a token with a denomination and an amount.
                    
                    NOTE: The amount field is an Int which implements the custom method
                    signatures required by gogoproto. */
                    amount: {
                        denom: string
                        amount: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** CommunityPool queries the community pool coins. */
    CommunityPool: {
        method: 'get'
        endpoint: {
            /** '/cosmos/distribution/v1beta1/community_pool' */
            evmos: `/cosmos/distribution/v1beta1/community_pool`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryCommunityPoolResponse is the response type for the Query/CommunityPool
RPC method. */
                {
                    /** pool defines community pool's coins. */
                    pool: Array<{
                        denom: string
                        amount: string
                    }>
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** DelegationTotalRewards queries the total rewards accrued by a each
    validator. */
    DelegationTotalRewards: {
        method: 'get'
        endpoint: {
            /** '/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards' */
            evmos: `/cosmos/distribution/v1beta1/delegators/${string}/rewards`
        }
        params: {
            path: {
                evmos: {
                    /** delegator_address defines the delegator address to query for. */
                    delegator_address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryDelegationTotalRewardsResponse is the response type for the
Query/DelegationTotalRewards RPC method. */
                {
                    /** rewards defines all the rewards accrued by a delegator. */
                    rewards: Array<{
                        validator_address: string
                        reward: Array<{
                            denom: string
                            amount: string
                        }>
                    }>
                    /** total defines the sum of all the rewards. */
                    total: Array<{
                        denom: string
                        amount: string
                    }>
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** DelegationRewards queries the total rewards accrued by a delegation. */
    DelegationRewards: {
        method: 'get'
        endpoint: {
            /** '/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}' */
            evmos: `/cosmos/distribution/v1beta1/delegators/${string}/rewards/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** delegator_address defines the delegator address to query for. */
                    delegator_address: string
                    /** validator_address defines the validator address to query for. */
                    validator_address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryDelegationRewardsResponse is the response type for the
Query/DelegationRewards RPC method. */
                {
                    /** rewards defines the rewards accrued by a delegation. */
                    rewards: Array<{
                        denom: string
                        amount: string
                    }>
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** DelegatorValidators queries the validators of a delegator. */
    DistDelegatorValidators: {
        method: 'get'
        endpoint: {
            /** '/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators' */
            evmos: `/cosmos/distribution/v1beta1/delegators/${string}/validators`
        }
        params: {
            path: {
                evmos: {
                    /** delegator_address defines the delegator address to query for. */
                    delegator_address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryDelegatorValidatorsResponse is the response type for the
Query/DelegatorValidators RPC method. */
                {
                    /** validators defines the validators a delegator is delegating for. */
                    validators: Array<string>
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** DelegatorWithdrawAddress queries withdraw address of a delegator. */
    DelegatorWithdrawAddress: {
        method: 'get'
        endpoint: {
            /** '/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address' */
            evmos: `/cosmos/distribution/v1beta1/delegators/${string}/withdraw_address`
        }
        params: {
            path: {
                evmos: {
                    /** delegator_address defines the delegator address to query for. */
                    delegator_address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryDelegatorWithdrawAddressResponse is the response type for the
Query/DelegatorWithdrawAddress RPC method. */
                {
                    /** withdraw_address defines the delegator address to query for. */
                    withdraw_address: string
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Params queries params of the distribution module. */
    DistributionParams: {
        method: 'get'
        endpoint: {
            /** '/cosmos/distribution/v1beta1/params' */
            evmos: `/cosmos/distribution/v1beta1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
                {
                    /** params defines the parameters of the module. */
                    params: {
                        community_tax: string
                        base_proposer_reward: string
                        bonus_proposer_reward: string
                        withdraw_addr_enabled: boolean
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** ValidatorCommission queries accumulated commission for a validator. */
    ValidatorCommission: {
        method: 'get'
        endpoint: {
            /** '/cosmos/distribution/v1beta1/validators/{validator_address}/commission' */
            evmos: `/cosmos/distribution/v1beta1/validators/${string}/commission`
        }
        params: {
            path: {
                evmos: {
                    /** validator_address defines the validator address to query for. */
                    validator_address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryValidatorCommissionResponse is the response type for the
Query/ValidatorCommission RPC method */
                {
                    /** commission defines the commision the validator received. */
                    commission: {
                        commission: Array<{
                            denom: string
                            amount: string
                        }>
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** ValidatorOutstandingRewards queries rewards of a validator address. */
    ValidatorOutstandingRewards: {
        method: 'get'
        endpoint: {
            /** '/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards' */
            evmos: `/cosmos/distribution/v1beta1/validators/${string}/outstanding_rewards`
        }
        params: {
            path: {
                evmos: {
                    /** validator_address defines the validator address to query for. */
                    validator_address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryValidatorOutstandingRewardsResponse is the response type for the
Query/ValidatorOutstandingRewards RPC method. */
                {
                    /** ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
                    for a validator inexpensive to track, allows simple sanity checks. */
                    rewards: {
                        rewards: Array<{
                            denom: string
                            amount: string
                        }>
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** ValidatorSlashes queries slash events of a validator. */
    ValidatorSlashes: {
        method: 'get'
        endpoint: {
            /** '/cosmos/distribution/v1beta1/validators/{validator_address}/slashes' */
            evmos: `/cosmos/distribution/v1beta1/validators/${string}/slashes`
        }
        params: {
            path: {
                evmos: {
                    /** validator_address defines the validator address to query for. */
                    validator_address: string
                }
            }

            query: {
                evmos: {
                    /** starting_height defines the optional starting height to query the slashes. */
                    starting_height: number
                    /** starting_height defines the optional ending height to query the slashes. */
                    ending_height: number
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** starting_height defines the optional starting height to query the slashes. */
                    starting_height: number
                    /** starting_height defines the optional ending height to query the slashes. */
                    ending_height: number
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryValidatorSlashesResponse is the response type for the
Query/ValidatorSlashes RPC method. */
                {
                    /** slashes defines the slashes the validator received. */
                    slashes: Array<{
                        validator_period: string
                        fraction: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** Allowance returns fee granted to the grantee by the granter. */
    Allowance: {
        method: 'get'
        endpoint: {
            /** '/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}' */
            evmos: `/cosmos/feegrant/v1beta1/allowance/${string}/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** granter is the address of the user granting an allowance of their funds. */
                    granter: string
                    /** grantee is the address of the user being granted an allowance of another user's funds. */
                    grantee: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryAllowanceResponse is the response type for the Query/Allowance RPC method. */
                {
                    /** Grant is stored in the KVStore to record a grant with full context */
                    allowance: {
                        /** granter is the address of the user granting an allowance of their funds. */
                        granter: string
                        /** grantee is the address of the user being granted an allowance of another user's funds. */
                        grantee: string
                        /** allowance can be any of basic and filtered fee allowance. */
                        allowance: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Allowances returns all the grants for address. */
    Allowances: {
        method: 'get'
        endpoint: {
            /** '/cosmos/feegrant/v1beta1/allowances/{grantee}' */
            evmos: `/cosmos/feegrant/v1beta1/allowances/${string}`
        }
        params: {
            path: {
                evmos: {
                    grantee: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryAllowancesResponse is the response type for the Query/Allowances RPC method. */
                {
                    /** allowances are allowance's granted for grantee by granter. */
                    allowances: Array<{
                        /** granter is the address of the user granting an allowance of their funds. */
                        granter: string
                        /** grantee is the address of the user being granted an allowance of another user's funds. */
                        grantee: string
                        /** allowance can be any of basic and filtered fee allowance. */
                        allowance: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                    }>
                    /** pagination defines an pagination for the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** AllEvidence queries all evidence. */
    AllEvidence: {
        method: 'get'
        endpoint: {
            /** '/cosmos/evidence/v1beta1/evidence' */
            evmos: `/cosmos/evidence/v1beta1/evidence`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC
method. */
                {
                    /** evidence returns all evidences. */
                    evidence: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Evidence queries evidence based on evidence hash. */
    Evidence: {
        method: 'get'
        endpoint: {
            /** '/cosmos/evidence/v1beta1/evidence/{evidence_hash}' */
            evmos: `/cosmos/evidence/v1beta1/evidence/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** evidence_hash defines the hash of the requested evidence. */
                    evidence_hash: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryEvidenceResponse is the response type for the Query/Evidence RPC method. */
                {
                    /** `Any` contains an arbitrary serialized protocol buffer message along with a
                    URL that describes the type of the serialized message.
                    
                    Protobuf library provides support to pack/unpack Any values in the form
                    of utility functions or additional generated methods of the Any type.
                    
                    Example 1: Pack and unpack a message in C++.
                    
                        Foo foo = ...;
                        Any any;
                        any.PackFrom(foo);
                        ...
                        if (any.UnpackTo(&foo)) {
                          ...
                        }
                    
                    Example 2: Pack and unpack a message in Java.
                    
                        Foo foo = ...;
                        Any any = Any.pack(foo);
                        ...
                        if (any.is(Foo.class)) {
                          foo = any.unpack(Foo.class);
                        }
                    
                     Example 3: Pack and unpack a message in Python.
                    
                        foo = Foo(...)
                        any = Any()
                        any.Pack(foo)
                        ...
                        if any.Is(Foo.DESCRIPTOR):
                          any.Unpack(foo)
                          ...
                    
                     Example 4: Pack and unpack a message in Go
                    
                         foo := &pb.Foo{...}
                         any, err := anypb.New(foo)
                         if err != nil {
                           ...
                         }
                         ...
                         foo := &pb.Foo{}
                         if err := any.UnmarshalTo(foo); err != nil {
                           ...
                         }
                    
                    The pack methods provided by protobuf library will by default use
                    'type.googleapis.com/full.type.name' as the type URL and the unpack
                    methods only use the fully qualified type name after the last '/'
                    in the type URL, for example "foo.bar.com/x/y.z" will yield type
                    name "y.z".
                    
                    
                    JSON
                    ====
                    The JSON representation of an `Any` value uses the regular
                    representation of the deserialized, embedded message, with an
                    additional field `@type` which contains the type URL. Example:
                    
                        package google.profile;
                        message Person {
                          string first_name = 1;
                          string last_name = 2;
                        }
                    
                        {
                          "@type": "type.googleapis.com/google.profile.Person",
                          "firstName": <string>,
                          "lastName": <string>
                        }
                    
                    If the embedded message type is well-known and has a custom JSON
                    representation, that representation will be embedded adding a field
                    `value` which holds the custom JSON in addition to the `@type`
                    field. Example (for message [google.protobuf.Duration][]):
                    
                        {
                          "@type": "type.googleapis.com/google.protobuf.Duration",
                          "value": "1.212s"
                        } */
                    evidence: {
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Params queries all parameters of the gov module. */
    GovParams: {
        method: 'get'
        endpoint: {
            /** '/cosmos/gov/v1beta1/params/{params_type}' */
            evmos: `/cosmos/gov/v1beta1/params/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** params_type defines which parameters to query for, can be one of "voting",
                    "tallying" or "deposit". */
                    params_type: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
                {
                    /** voting_params defines the parameters related to voting. */
                    voting_params: {
                        /** Length of the voting period. */
                        voting_period: string
                    }
                    /** deposit_params defines the parameters related to deposit. */
                    deposit_params: {
                        /** Minimum deposit for a proposal to enter voting period. */
                        min_deposit: Array<{
                            denom: string
                            amount: string
                        }>
                        /** Maximum period for Atom holders to deposit on a proposal. Initial value: 2
                         months. */
                        max_deposit_period: string
                    }
                    /** tally_params defines the parameters related to tally. */
                    tally_params: {
                        /** Minimum percentage of total stake needed to vote for a result to be
                         considered valid. */
                        quorum: string
                        /** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
                        threshold: string
                        /** Minimum value of Veto votes to Total votes ratio for proposal to be
                         vetoed. Default value: 1/3. */
                        veto_threshold: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Proposals queries all proposals based on given status. */
    Proposals: {
        method: 'get'
        endpoint: {
            /** '/cosmos/gov/v1beta1/proposals' */
            evmos: `/cosmos/gov/v1beta1/proposals`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** proposal_status defines the status of the proposals.
                    
                     - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
                     - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
                    period.
                     - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
                    period.
                     - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
                    passed.
                     - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
                    been rejected.
                     - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
                    failed. */
                    proposal_status: string
                    /** voter defines the voter address for the proposals. */
                    voter: string
                    /** depositor defines the deposit addresses from the proposals. */
                    depositor: string
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** proposal_status defines the status of the proposals.
                    
                     - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
                     - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
                    period.
                     - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
                    period.
                     - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
                    passed.
                     - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
                    been rejected.
                     - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
                    failed. */
                    proposal_status: string
                    /** voter defines the voter address for the proposals. */
                    voter: string
                    /** depositor defines the deposit addresses from the proposals. */
                    depositor: string
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryProposalsResponse is the response type for the Query/Proposals RPC
method. */
                {
                    proposals: Array<{
                        proposal_id: string
                        /** `Any` contains an arbitrary serialized protocol buffer message along with a
                        URL that describes the type of the serialized message.
                        
                        Protobuf library provides support to pack/unpack Any values in the form
                        of utility functions or additional generated methods of the Any type.
                        
                        Example 1: Pack and unpack a message in C++.
                        
                            Foo foo = ...;
                            Any any;
                            any.PackFrom(foo);
                            ...
                            if (any.UnpackTo(&foo)) {
                              ...
                            }
                        
                        Example 2: Pack and unpack a message in Java.
                        
                            Foo foo = ...;
                            Any any = Any.pack(foo);
                            ...
                            if (any.is(Foo.class)) {
                              foo = any.unpack(Foo.class);
                            }
                        
                         Example 3: Pack and unpack a message in Python.
                        
                            foo = Foo(...)
                            any = Any()
                            any.Pack(foo)
                            ...
                            if any.Is(Foo.DESCRIPTOR):
                              any.Unpack(foo)
                              ...
                        
                         Example 4: Pack and unpack a message in Go
                        
                             foo := &pb.Foo{...}
                             any, err := anypb.New(foo)
                             if err != nil {
                               ...
                             }
                             ...
                             foo := &pb.Foo{}
                             if err := any.UnmarshalTo(foo); err != nil {
                               ...
                             }
                        
                        The pack methods provided by protobuf library will by default use
                        'type.googleapis.com/full.type.name' as the type URL and the unpack
                        methods only use the fully qualified type name after the last '/'
                        in the type URL, for example "foo.bar.com/x/y.z" will yield type
                        name "y.z".
                        
                        
                        JSON
                        ====
                        The JSON representation of an `Any` value uses the regular
                        representation of the deserialized, embedded message, with an
                        additional field `@type` which contains the type URL. Example:
                        
                            package google.profile;
                            message Person {
                              string first_name = 1;
                              string last_name = 2;
                            }
                        
                            {
                              "@type": "type.googleapis.com/google.profile.Person",
                              "firstName": <string>,
                              "lastName": <string>
                            }
                        
                        If the embedded message type is well-known and has a custom JSON
                        representation, that representation will be embedded adding a field
                        `value` which holds the custom JSON in addition to the `@type`
                        field. Example (for message [google.protobuf.Duration][]):
                        
                            {
                              "@type": "type.googleapis.com/google.protobuf.Duration",
                              "value": "1.212s"
                            } */
                        content: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                        /** ProposalStatus enumerates the valid statuses of a proposal.
                        
                         - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
                         - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
                        period.
                         - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
                        period.
                         - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
                        passed.
                         - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
                        been rejected.
                         - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
                        failed. */
                        status: string
                        /** TallyResult defines a standard tally for a governance proposal. */
                        final_tally_result: {
                            yes: string
                            abstain: string
                            no: string
                            no_with_veto: string
                        }
                        submit_time: string
                        deposit_end_time: string
                        total_deposit: Array<{
                            denom: string
                            amount: string
                        }>
                        voting_start_time: string
                        voting_end_time: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Proposal queries proposal details based on ProposalID. */
    Proposal: {
        method: 'get'
        endpoint: {
            /** '/cosmos/gov/v1beta1/proposals/{proposal_id}' */
            evmos: `/cosmos/gov/v1beta1/proposals/${number}`
        }
        params: {
            path: {
                evmos: {
                    /** proposal_id defines the unique id of the proposal. */
                    proposal_id: number
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryProposalResponse is the response type for the Query/Proposal RPC method. */
                {
                    /** Proposal defines the core field members of a governance proposal. */
                    proposal: {
                        proposal_id: string
                        /** `Any` contains an arbitrary serialized protocol buffer message along with a
                        URL that describes the type of the serialized message.
                        
                        Protobuf library provides support to pack/unpack Any values in the form
                        of utility functions or additional generated methods of the Any type.
                        
                        Example 1: Pack and unpack a message in C++.
                        
                            Foo foo = ...;
                            Any any;
                            any.PackFrom(foo);
                            ...
                            if (any.UnpackTo(&foo)) {
                              ...
                            }
                        
                        Example 2: Pack and unpack a message in Java.
                        
                            Foo foo = ...;
                            Any any = Any.pack(foo);
                            ...
                            if (any.is(Foo.class)) {
                              foo = any.unpack(Foo.class);
                            }
                        
                         Example 3: Pack and unpack a message in Python.
                        
                            foo = Foo(...)
                            any = Any()
                            any.Pack(foo)
                            ...
                            if any.Is(Foo.DESCRIPTOR):
                              any.Unpack(foo)
                              ...
                        
                         Example 4: Pack and unpack a message in Go
                        
                             foo := &pb.Foo{...}
                             any, err := anypb.New(foo)
                             if err != nil {
                               ...
                             }
                             ...
                             foo := &pb.Foo{}
                             if err := any.UnmarshalTo(foo); err != nil {
                               ...
                             }
                        
                        The pack methods provided by protobuf library will by default use
                        'type.googleapis.com/full.type.name' as the type URL and the unpack
                        methods only use the fully qualified type name after the last '/'
                        in the type URL, for example "foo.bar.com/x/y.z" will yield type
                        name "y.z".
                        
                        
                        JSON
                        ====
                        The JSON representation of an `Any` value uses the regular
                        representation of the deserialized, embedded message, with an
                        additional field `@type` which contains the type URL. Example:
                        
                            package google.profile;
                            message Person {
                              string first_name = 1;
                              string last_name = 2;
                            }
                        
                            {
                              "@type": "type.googleapis.com/google.profile.Person",
                              "firstName": <string>,
                              "lastName": <string>
                            }
                        
                        If the embedded message type is well-known and has a custom JSON
                        representation, that representation will be embedded adding a field
                        `value` which holds the custom JSON in addition to the `@type`
                        field. Example (for message [google.protobuf.Duration][]):
                        
                            {
                              "@type": "type.googleapis.com/google.protobuf.Duration",
                              "value": "1.212s"
                            } */
                        content: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                        /** ProposalStatus enumerates the valid statuses of a proposal.
                        
                         - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
                         - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
                        period.
                         - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
                        period.
                         - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
                        passed.
                         - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
                        been rejected.
                         - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
                        failed. */
                        status: string
                        /** TallyResult defines a standard tally for a governance proposal. */
                        final_tally_result: {
                            yes: string
                            abstain: string
                            no: string
                            no_with_veto: string
                        }
                        submit_time: string
                        deposit_end_time: string
                        total_deposit: Array<{
                            denom: string
                            amount: string
                        }>
                        voting_start_time: string
                        voting_end_time: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Deposits queries all deposits of a single proposal. */
    Deposits: {
        method: 'get'
        endpoint: {
            /** '/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits' */
            evmos: `/cosmos/gov/v1beta1/proposals/${number}/deposits`
        }
        params: {
            path: {
                evmos: {
                    /** proposal_id defines the unique id of the proposal. */
                    proposal_id: number
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryDepositsResponse is the response type for the Query/Deposits RPC method. */
                {
                    deposits: Array<{
                        proposal_id: string
                        depositor: string
                        amount: Array<{
                            denom: string
                            amount: string
                        }>
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Deposit queries single deposit information based proposalID, depositAddr. */
    Deposit: {
        method: 'get'
        endpoint: {
            /** '/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}' */
            evmos: `/cosmos/gov/v1beta1/proposals/${number}/deposits/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** proposal_id defines the unique id of the proposal. */
                    proposal_id: number
                    /** depositor defines the deposit addresses from the proposals. */
                    depositor: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryDepositResponse is the response type for the Query/Deposit RPC method. */
                {
                    /** Deposit defines an amount deposited by an account address to an active
                    proposal. */
                    deposit: {
                        proposal_id: string
                        depositor: string
                        amount: Array<{
                            denom: string
                            amount: string
                        }>
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** TallyResult queries the tally of a proposal vote. */
    TallyResult: {
        method: 'get'
        endpoint: {
            /** '/cosmos/gov/v1beta1/proposals/{proposal_id}/tally' */
            evmos: `/cosmos/gov/v1beta1/proposals/${number}/tally`
        }
        params: {
            path: {
                evmos: {
                    /** proposal_id defines the unique id of the proposal. */
                    proposal_id: number
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryTallyResultResponse is the response type for the Query/Tally RPC method. */
                {
                    /** TallyResult defines a standard tally for a governance proposal. */
                    tally: {
                        yes: string
                        abstain: string
                        no: string
                        no_with_veto: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Votes queries votes of a given proposal. */
    Votes: {
        method: 'get'
        endpoint: {
            /** '/cosmos/gov/v1beta1/proposals/{proposal_id}/votes' */
            evmos: `/cosmos/gov/v1beta1/proposals/${number}/votes`
        }
        params: {
            path: {
                evmos: {
                    /** proposal_id defines the unique id of the proposal. */
                    proposal_id: number
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryVotesResponse is the response type for the Query/Votes RPC method. */
                {
                    /** votes defined the queried votes. */
                    votes: Array<{
                        proposal_id: string
                        voter: string
                        /** Deprecated: Prefer to use `options` instead. This field is set in queries
                        if and only if `len(options) == 1` and that option has weight 1. In all
                        other cases, this field will default to VOTE_OPTION_UNSPECIFIED. */
                        option: string
                        /** Since: cosmos-sdk 0.43 */
                        options: Array<{
                            /** VoteOption enumerates the valid vote options for a given governance proposal.
                            
                             - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
                             - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
                             - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
                             - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
                             - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */
                            option: string
                            weight: string
                        }>
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Vote queries voted information based on proposalID, voterAddr. */
    Vote: {
        method: 'get'
        endpoint: {
            /** '/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}' */
            evmos: `/cosmos/gov/v1beta1/proposals/${number}/votes/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** proposal_id defines the unique id of the proposal. */
                    proposal_id: number
                    /** voter defines the oter address for the proposals. */
                    voter: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryVoteResponse is the response type for the Query/Vote RPC method. */
                {
                    /** Vote defines a vote on a governance proposal.
                    A Vote consists of a proposal ID, the voter, and the vote option. */
                    vote: {
                        proposal_id: string
                        voter: string
                        /** Deprecated: Prefer to use `options` instead. This field is set in queries
                        if and only if `len(options) == 1` and that option has weight 1. In all
                        other cases, this field will default to VOTE_OPTION_UNSPECIFIED. */
                        option: string
                        /** Since: cosmos-sdk 0.43 */
                        options: Array<{
                            /** VoteOption enumerates the valid vote options for a given governance proposal.
                            
                             - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
                             - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
                             - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
                             - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
                             - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */
                            option: string
                            weight: string
                        }>
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Params queries the parameters of slashing module */
    SlashingParams: {
        method: 'get'
        endpoint: {
            /** '/cosmos/slashing/v1beta1/params' */
            evmos: `/cosmos/slashing/v1beta1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method */
                {
                    /** Params represents the parameters used for by the slashing module. */
                    params: {
                        signed_blocks_window: string
                        min_signed_per_window: string
                        downtime_jail_duration: string
                        slash_fraction_double_sign: string
                        slash_fraction_downtime: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** SigningInfos queries signing info of all validators */
    SigningInfos: {
        method: 'get'
        endpoint: {
            /** '/cosmos/slashing/v1beta1/signing_infos' */
            evmos: `/cosmos/slashing/v1beta1/signing_infos`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC
method */
                {
                    /** info is the signing info of all validators */
                    info: Array<{
                        address: string
                        /** Height at which validator was first a candidate OR was unjailed */
                        start_height: string
                        /** Index which is incremented each time the validator was a bonded
                        in a block and may have signed a precommit or not. This in conjunction with the
                        `SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`. */
                        index_offset: string
                        /** Timestamp until which the validator is jailed due to liveness downtime. */
                        jailed_until: string
                        /** Whether or not a validator has been tombstoned (killed out of validator set). It is set
                        once the validator commits an equivocation or for any other configured misbehiavor. */
                        tombstoned: boolean
                        /** A counter kept to avoid unnecessary array reads.
                        Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`. */
                        missed_blocks_counter: string
                    }>
                    /** PageResponse is to be embedded in gRPC response messages where the
                    corresponding request message has used PageRequest.
                    
                     message SomeResponse {
                             repeated Bar results = 1;
                             PageResponse page = 2;
                     } */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** SigningInfo queries the signing info of given cons address */
    SigningInfo: {
        method: 'get'
        endpoint: {
            /** '/cosmos/slashing/v1beta1/signing_infos/{cons_address}' */
            evmos: `/cosmos/slashing/v1beta1/signing_infos/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** cons_address is the address to query signing info of */
                    cons_address: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC
method */
                {
                    /** val_signing_info is the signing info of requested val cons address */
                    val_signing_info: {
                        address: string
                        /** Height at which validator was first a candidate OR was unjailed */
                        start_height: string
                        /** Index which is incremented each time the validator was a bonded
                        in a block and may have signed a precommit or not. This in conjunction with the
                        `SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`. */
                        index_offset: string
                        /** Timestamp until which the validator is jailed due to liveness downtime. */
                        jailed_until: string
                        /** Whether or not a validator has been tombstoned (killed out of validator set). It is set
                        once the validator commits an equivocation or for any other configured misbehiavor. */
                        tombstoned: boolean
                        /** A counter kept to avoid unnecessary array reads.
                        Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`. */
                        missed_blocks_counter: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        value: string
                    }>
                }
            }
        }

    }

    /** DelegatorDelegations queries all delegations of a given delegator address. */
    DelegatorDelegations: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/delegations/{delegator_addr}' */
            evmos: `/cosmos/staking/v1beta1/delegations/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** delegator_addr defines the delegator address to query for. */
                    delegator_addr: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryDelegatorDelegationsResponse is response type for the
Query/DelegatorDelegations RPC method. */
                {
                    /** delegation_responses defines all the delegations' info of a delegator. */
                    delegation_responses: Array<{
                        /** Delegation represents the bond with tokens held by an account. It is
                        owned by one delegator, and is associated with the voting power of one
                        validator. */
                        delegation: {
                            /** delegator_address is the bech32-encoded address of the delegator. */
                            delegator_address: string
                            /** validator_address is the bech32-encoded address of the validator. */
                            validator_address: string
                            /** shares define the delegation shares received. */
                            shares: string
                        }
                        /** Coin defines a token with a denomination and an amount.
                        
                        NOTE: The amount field is an Int which implements the custom method
                        signatures required by gogoproto. */
                        balance: {
                            denom: string
                            amount: string
                        }
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Redelegations queries redelegations of given address. */
    Redelegations: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations' */
            evmos: `/cosmos/staking/v1beta1/delegators/${string}/redelegations`
        }
        params: {
            path: {
                evmos: {
                    /** delegator_addr defines the delegator address to query for. */
                    delegator_addr: string
                }
            }

            query: {
                evmos: {
                    /** src_validator_addr defines the validator address to redelegate from. */
                    src_validator_addr: string
                    /** dst_validator_addr defines the validator address to redelegate to. */
                    dst_validator_addr: string
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** src_validator_addr defines the validator address to redelegate from. */
                    src_validator_addr: string
                    /** dst_validator_addr defines the validator address to redelegate to. */
                    dst_validator_addr: string
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryRedelegationsResponse is response type for the Query/Redelegations RPC
method. */
                {
                    redelegation_responses: Array<{
                        /** Redelegation contains the list of a particular delegator's redelegating bonds
                        from a particular source validator to a particular destination validator. */
                        redelegation: {
                            /** delegator_address is the bech32-encoded address of the delegator. */
                            delegator_address: string
                            /** validator_src_address is the validator redelegation source operator address. */
                            validator_src_address: string
                            /** validator_dst_address is the validator redelegation destination operator address. */
                            validator_dst_address: string
                            /** entries are the redelegation entries. */
                            entries: Array<{
                                /** creation_height  defines the height which the redelegation took place. */
                                creation_height: string
                                /** completion_time defines the unix time for redelegation completion. */
                                completion_time: string
                                /** initial_balance defines the initial balance when redelegation started. */
                                initial_balance: string
                                /** shares_dst is the amount of destination-validator shares created by redelegation. */
                                shares_dst: string
                            }>
                        }
                        entries: Array<{
                            /** RedelegationEntry defines a redelegation object with relevant metadata. */
                            redelegation_entry: {
                                /** creation_height  defines the height which the redelegation took place. */
                                creation_height: string
                                /** completion_time defines the unix time for redelegation completion. */
                                completion_time: string
                                /** initial_balance defines the initial balance when redelegation started. */
                                initial_balance: string
                                /** shares_dst is the amount of destination-validator shares created by redelegation. */
                                shares_dst: string
                            }
                            balance: string
                        }>
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** DelegatorUnbondingDelegations queries all unbonding delegations of a given
    delegator address. */
    DelegatorUnbondingDelegations: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations' */
            evmos: `/cosmos/staking/v1beta1/delegators/${string}/unbonding_delegations`
        }
        params: {
            path: {
                evmos: {
                    /** delegator_addr defines the delegator address to query for. */
                    delegator_addr: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryUnbondingDelegatorDelegationsResponse is response type for the
Query/UnbondingDelegatorDelegations RPC method. */
                {
                    unbonding_responses: Array<{
                        /** delegator_address is the bech32-encoded address of the delegator. */
                        delegator_address: string
                        /** validator_address is the bech32-encoded address of the validator. */
                        validator_address: string
                        /** entries are the unbonding delegation entries. */
                        entries: Array<{
                            /** creation_height is the height which the unbonding took place. */
                            creation_height: string
                            /** completion_time is the unix time for unbonding completion. */
                            completion_time: string
                            /** initial_balance defines the tokens initially scheduled to receive at completion. */
                            initial_balance: string
                            /** balance defines the tokens to receive at completion. */
                            balance: string
                        }>
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** DelegatorValidators queries all validators info for given delegator
    address. */
    DelegatorValidators: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators' */
            evmos: `/cosmos/staking/v1beta1/delegators/${string}/validators`
        }
        params: {
            path: {
                evmos: {
                    /** delegator_addr defines the delegator address to query for. */
                    delegator_addr: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryDelegatorValidatorsResponse is response type for the
Query/DelegatorValidators RPC method. */
                {
                    /** validators defines the the validators' info of a delegator. */
                    validators: Array<{
                        /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
                        operator_address: string
                        /** `Any` contains an arbitrary serialized protocol buffer message along with a
                        URL that describes the type of the serialized message.
                        
                        Protobuf library provides support to pack/unpack Any values in the form
                        of utility functions or additional generated methods of the Any type.
                        
                        Example 1: Pack and unpack a message in C++.
                        
                            Foo foo = ...;
                            Any any;
                            any.PackFrom(foo);
                            ...
                            if (any.UnpackTo(&foo)) {
                              ...
                            }
                        
                        Example 2: Pack and unpack a message in Java.
                        
                            Foo foo = ...;
                            Any any = Any.pack(foo);
                            ...
                            if (any.is(Foo.class)) {
                              foo = any.unpack(Foo.class);
                            }
                        
                         Example 3: Pack and unpack a message in Python.
                        
                            foo = Foo(...)
                            any = Any()
                            any.Pack(foo)
                            ...
                            if any.Is(Foo.DESCRIPTOR):
                              any.Unpack(foo)
                              ...
                        
                         Example 4: Pack and unpack a message in Go
                        
                             foo := &pb.Foo{...}
                             any, err := anypb.New(foo)
                             if err != nil {
                               ...
                             }
                             ...
                             foo := &pb.Foo{}
                             if err := any.UnmarshalTo(foo); err != nil {
                               ...
                             }
                        
                        The pack methods provided by protobuf library will by default use
                        'type.googleapis.com/full.type.name' as the type URL and the unpack
                        methods only use the fully qualified type name after the last '/'
                        in the type URL, for example "foo.bar.com/x/y.z" will yield type
                        name "y.z".
                        
                        
                        JSON
                        ====
                        The JSON representation of an `Any` value uses the regular
                        representation of the deserialized, embedded message, with an
                        additional field `@type` which contains the type URL. Example:
                        
                            package google.profile;
                            message Person {
                              string first_name = 1;
                              string last_name = 2;
                            }
                        
                            {
                              "@type": "type.googleapis.com/google.profile.Person",
                              "firstName": <string>,
                              "lastName": <string>
                            }
                        
                        If the embedded message type is well-known and has a custom JSON
                        representation, that representation will be embedded adding a field
                        `value` which holds the custom JSON in addition to the `@type`
                        field. Example (for message [google.protobuf.Duration][]):
                        
                            {
                              "@type": "type.googleapis.com/google.protobuf.Duration",
                              "value": "1.212s"
                            } */
                        consensus_pubkey: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                        /** jailed defined whether the validator has been jailed from bonded status or not. */
                        jailed: boolean
                        /** status is the validator status (bonded/unbonding/unbonded). */
                        status: string
                        /** tokens define the delegated tokens (incl. self-delegation). */
                        tokens: string
                        /** delegator_shares defines total shares issued to a validator's delegators. */
                        delegator_shares: string
                        /** description defines the description terms for the validator. */
                        description: {
                            /** moniker defines a human-readable name for the validator. */
                            moniker: string
                            /** identity defines an optional identity signature (ex. UPort or Keybase). */
                            identity: string
                            /** website defines an optional website link. */
                            website: string
                            /** security_contact defines an optional email for security contact. */
                            security_contact: string
                            /** details define other optional details. */
                            details: string
                        }
                        /** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
                        unbonding_height: string
                        /** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
                        unbonding_time: string
                        /** commission defines the commission parameters. */
                        commission: {
                            /** commission_rates defines the initial commission rates to be used for creating a validator. */
                            commission_rates: {
                                /** rate is the commission rate charged to delegators, as a fraction. */
                                rate: string
                                /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                                max_rate: string
                                /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                                max_change_rate: string
                            }
                            /** update_time is the last time the commission rate was changed. */
                            update_time: string
                        }
                        /** min_self_delegation is the validator's self declared minimum self delegation. */
                        min_self_delegation: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** DelegatorValidator queries validator info for given delegator validator
    pair. */
    DelegatorValidator: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}' */
            evmos: `/cosmos/staking/v1beta1/delegators/${string}/validators/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** delegator_addr defines the delegator address to query for. */
                    delegator_addr: string
                    /** validator_addr defines the validator address to query for. */
                    validator_addr: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryDelegatorValidatorResponse response type for the
Query/DelegatorValidator RPC method. */
                {
                    /** Validator defines a validator, together with the total amount of the
                    Validator's bond shares and their exchange rate to coins. Slashing results in
                    a decrease in the exchange rate, allowing correct calculation of future
                    undelegations without iterating over delegators. When coins are delegated to
                    this validator, the validator is credited with a delegation whose number of
                    bond shares is based on the amount of coins delegated divided by the current
                    exchange rate. Voting power can be calculated as total bonded shares
                    multiplied by exchange rate. */
                    validator: {
                        /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
                        operator_address: string
                        /** `Any` contains an arbitrary serialized protocol buffer message along with a
                        URL that describes the type of the serialized message.
                        
                        Protobuf library provides support to pack/unpack Any values in the form
                        of utility functions or additional generated methods of the Any type.
                        
                        Example 1: Pack and unpack a message in C++.
                        
                            Foo foo = ...;
                            Any any;
                            any.PackFrom(foo);
                            ...
                            if (any.UnpackTo(&foo)) {
                              ...
                            }
                        
                        Example 2: Pack and unpack a message in Java.
                        
                            Foo foo = ...;
                            Any any = Any.pack(foo);
                            ...
                            if (any.is(Foo.class)) {
                              foo = any.unpack(Foo.class);
                            }
                        
                         Example 3: Pack and unpack a message in Python.
                        
                            foo = Foo(...)
                            any = Any()
                            any.Pack(foo)
                            ...
                            if any.Is(Foo.DESCRIPTOR):
                              any.Unpack(foo)
                              ...
                        
                         Example 4: Pack and unpack a message in Go
                        
                             foo := &pb.Foo{...}
                             any, err := anypb.New(foo)
                             if err != nil {
                               ...
                             }
                             ...
                             foo := &pb.Foo{}
                             if err := any.UnmarshalTo(foo); err != nil {
                               ...
                             }
                        
                        The pack methods provided by protobuf library will by default use
                        'type.googleapis.com/full.type.name' as the type URL and the unpack
                        methods only use the fully qualified type name after the last '/'
                        in the type URL, for example "foo.bar.com/x/y.z" will yield type
                        name "y.z".
                        
                        
                        JSON
                        ====
                        The JSON representation of an `Any` value uses the regular
                        representation of the deserialized, embedded message, with an
                        additional field `@type` which contains the type URL. Example:
                        
                            package google.profile;
                            message Person {
                              string first_name = 1;
                              string last_name = 2;
                            }
                        
                            {
                              "@type": "type.googleapis.com/google.profile.Person",
                              "firstName": <string>,
                              "lastName": <string>
                            }
                        
                        If the embedded message type is well-known and has a custom JSON
                        representation, that representation will be embedded adding a field
                        `value` which holds the custom JSON in addition to the `@type`
                        field. Example (for message [google.protobuf.Duration][]):
                        
                            {
                              "@type": "type.googleapis.com/google.protobuf.Duration",
                              "value": "1.212s"
                            } */
                        consensus_pubkey: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                        /** jailed defined whether the validator has been jailed from bonded status or not. */
                        jailed: boolean
                        /** status is the validator status (bonded/unbonding/unbonded). */
                        status: string
                        /** tokens define the delegated tokens (incl. self-delegation). */
                        tokens: string
                        /** delegator_shares defines total shares issued to a validator's delegators. */
                        delegator_shares: string
                        /** description defines the description terms for the validator. */
                        description: {
                            /** moniker defines a human-readable name for the validator. */
                            moniker: string
                            /** identity defines an optional identity signature (ex. UPort or Keybase). */
                            identity: string
                            /** website defines an optional website link. */
                            website: string
                            /** security_contact defines an optional email for security contact. */
                            security_contact: string
                            /** details define other optional details. */
                            details: string
                        }
                        /** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
                        unbonding_height: string
                        /** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
                        unbonding_time: string
                        /** commission defines the commission parameters. */
                        commission: {
                            /** commission_rates defines the initial commission rates to be used for creating a validator. */
                            commission_rates: {
                                /** rate is the commission rate charged to delegators, as a fraction. */
                                rate: string
                                /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                                max_rate: string
                                /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                                max_change_rate: string
                            }
                            /** update_time is the last time the commission rate was changed. */
                            update_time: string
                        }
                        /** min_self_delegation is the validator's self declared minimum self delegation. */
                        min_self_delegation: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** HistoricalInfo queries the historical info for given height. */
    HistoricalInfo: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/historical_info/{height}' */
            evmos: `/cosmos/staking/v1beta1/historical_info/${number}`
        }
        params: {
            path: {
                evmos: {
                    /** height defines at which height to query the historical info. */
                    height: number
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC
method. */
                {
                    /** hist defines the historical info at the given height. */
                    hist: {
                        /** Header defines the structure of a Tendermint block header. */
                        header: {
                            /** basic block info */
                            version: {
                                block: string
                                app: string
                            }
                            chain_id: string
                            height: string
                            time: string
                            /** prev block info */
                            last_block_id: {
                                hash: string
                                /** PartsetHeader */
                                part_set_header: {
                                    total: number
                                    hash: string
                                }
                            }
                            /** hashes of block data */
                            last_commit_hash: string
                            data_hash: string
                            /** hashes from the app output from the prev block */
                            validators_hash: string
                            next_validators_hash: string
                            consensus_hash: string
                            app_hash: string
                            last_results_hash: string
                            /** consensus info */
                            evidence_hash: string
                            proposer_address: string
                        }
                        valset: Array<{
                            /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
                            operator_address: string
                            /** `Any` contains an arbitrary serialized protocol buffer message along with a
                            URL that describes the type of the serialized message.
                            
                            Protobuf library provides support to pack/unpack Any values in the form
                            of utility functions or additional generated methods of the Any type.
                            
                            Example 1: Pack and unpack a message in C++.
                            
                                Foo foo = ...;
                                Any any;
                                any.PackFrom(foo);
                                ...
                                if (any.UnpackTo(&foo)) {
                                  ...
                                }
                            
                            Example 2: Pack and unpack a message in Java.
                            
                                Foo foo = ...;
                                Any any = Any.pack(foo);
                                ...
                                if (any.is(Foo.class)) {
                                  foo = any.unpack(Foo.class);
                                }
                            
                             Example 3: Pack and unpack a message in Python.
                            
                                foo = Foo(...)
                                any = Any()
                                any.Pack(foo)
                                ...
                                if any.Is(Foo.DESCRIPTOR):
                                  any.Unpack(foo)
                                  ...
                            
                             Example 4: Pack and unpack a message in Go
                            
                                 foo := &pb.Foo{...}
                                 any, err := anypb.New(foo)
                                 if err != nil {
                                   ...
                                 }
                                 ...
                                 foo := &pb.Foo{}
                                 if err := any.UnmarshalTo(foo); err != nil {
                                   ...
                                 }
                            
                            The pack methods provided by protobuf library will by default use
                            'type.googleapis.com/full.type.name' as the type URL and the unpack
                            methods only use the fully qualified type name after the last '/'
                            in the type URL, for example "foo.bar.com/x/y.z" will yield type
                            name "y.z".
                            
                            
                            JSON
                            ====
                            The JSON representation of an `Any` value uses the regular
                            representation of the deserialized, embedded message, with an
                            additional field `@type` which contains the type URL. Example:
                            
                                package google.profile;
                                message Person {
                                  string first_name = 1;
                                  string last_name = 2;
                                }
                            
                                {
                                  "@type": "type.googleapis.com/google.profile.Person",
                                  "firstName": <string>,
                                  "lastName": <string>
                                }
                            
                            If the embedded message type is well-known and has a custom JSON
                            representation, that representation will be embedded adding a field
                            `value` which holds the custom JSON in addition to the `@type`
                            field. Example (for message [google.protobuf.Duration][]):
                            
                                {
                                  "@type": "type.googleapis.com/google.protobuf.Duration",
                                  "value": "1.212s"
                                } */
                            consensus_pubkey: {
                                type_url: string
                                /** Must be a valid serialized protocol buffer of the above specified type. */
                                value: string
                            }
                            /** jailed defined whether the validator has been jailed from bonded status or not. */
                            jailed: boolean
                            /** status is the validator status (bonded/unbonding/unbonded). */
                            status: string
                            /** tokens define the delegated tokens (incl. self-delegation). */
                            tokens: string
                            /** delegator_shares defines total shares issued to a validator's delegators. */
                            delegator_shares: string
                            /** description defines the description terms for the validator. */
                            description: {
                                /** moniker defines a human-readable name for the validator. */
                                moniker: string
                                /** identity defines an optional identity signature (ex. UPort or Keybase). */
                                identity: string
                                /** website defines an optional website link. */
                                website: string
                                /** security_contact defines an optional email for security contact. */
                                security_contact: string
                                /** details define other optional details. */
                                details: string
                            }
                            /** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
                            unbonding_height: string
                            /** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
                            unbonding_time: string
                            /** commission defines the commission parameters. */
                            commission: {
                                /** commission_rates defines the initial commission rates to be used for creating a validator. */
                                commission_rates: {
                                    /** rate is the commission rate charged to delegators, as a fraction. */
                                    rate: string
                                    /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                                    max_rate: string
                                    /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                                    max_change_rate: string
                                }
                                /** update_time is the last time the commission rate was changed. */
                                update_time: string
                            }
                            /** min_self_delegation is the validator's self declared minimum self delegation. */
                            min_self_delegation: string
                        }>
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Parameters queries the staking parameters. */
    StakingParams: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/params' */
            evmos: `/cosmos/staking/v1beta1/params`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryParamsResponse is response type for the Query/Params RPC method. */
                {
                    /** params holds all the parameters of this module. */
                    params: {
                        /** unbonding_time is the time duration of unbonding. */
                        unbonding_time: string
                        /** max_validators is the maximum number of validators. */
                        max_validators: number
                        /** max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio). */
                        max_entries: number
                        /** historical_entries is the number of historical entries to persist. */
                        historical_entries: number
                        /** bond_denom defines the bondable coin denomination. */
                        bond_denom: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Validators queries all validators that match the given status. */
    Validators: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/validators' */
            evmos: `/cosmos/staking/v1beta1/validators`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** status enables to query for validators matching a given status. */
                    status: string
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** status enables to query for validators matching a given status. */
                    status: string
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryValidatorsResponse is response type for the Query/Validators RPC method */
                {
                    /** validators contains all the queried validators. */
                    validators: Array<{
                        /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
                        operator_address: string
                        /** `Any` contains an arbitrary serialized protocol buffer message along with a
                        URL that describes the type of the serialized message.
                        
                        Protobuf library provides support to pack/unpack Any values in the form
                        of utility functions or additional generated methods of the Any type.
                        
                        Example 1: Pack and unpack a message in C++.
                        
                            Foo foo = ...;
                            Any any;
                            any.PackFrom(foo);
                            ...
                            if (any.UnpackTo(&foo)) {
                              ...
                            }
                        
                        Example 2: Pack and unpack a message in Java.
                        
                            Foo foo = ...;
                            Any any = Any.pack(foo);
                            ...
                            if (any.is(Foo.class)) {
                              foo = any.unpack(Foo.class);
                            }
                        
                         Example 3: Pack and unpack a message in Python.
                        
                            foo = Foo(...)
                            any = Any()
                            any.Pack(foo)
                            ...
                            if any.Is(Foo.DESCRIPTOR):
                              any.Unpack(foo)
                              ...
                        
                         Example 4: Pack and unpack a message in Go
                        
                             foo := &pb.Foo{...}
                             any, err := anypb.New(foo)
                             if err != nil {
                               ...
                             }
                             ...
                             foo := &pb.Foo{}
                             if err := any.UnmarshalTo(foo); err != nil {
                               ...
                             }
                        
                        The pack methods provided by protobuf library will by default use
                        'type.googleapis.com/full.type.name' as the type URL and the unpack
                        methods only use the fully qualified type name after the last '/'
                        in the type URL, for example "foo.bar.com/x/y.z" will yield type
                        name "y.z".
                        
                        
                        JSON
                        ====
                        The JSON representation of an `Any` value uses the regular
                        representation of the deserialized, embedded message, with an
                        additional field `@type` which contains the type URL. Example:
                        
                            package google.profile;
                            message Person {
                              string first_name = 1;
                              string last_name = 2;
                            }
                        
                            {
                              "@type": "type.googleapis.com/google.profile.Person",
                              "firstName": <string>,
                              "lastName": <string>
                            }
                        
                        If the embedded message type is well-known and has a custom JSON
                        representation, that representation will be embedded adding a field
                        `value` which holds the custom JSON in addition to the `@type`
                        field. Example (for message [google.protobuf.Duration][]):
                        
                            {
                              "@type": "type.googleapis.com/google.protobuf.Duration",
                              "value": "1.212s"
                            } */
                        consensus_pubkey: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                        /** jailed defined whether the validator has been jailed from bonded status or not. */
                        jailed: boolean
                        /** status is the validator status (bonded/unbonding/unbonded). */
                        status: string
                        /** tokens define the delegated tokens (incl. self-delegation). */
                        tokens: string
                        /** delegator_shares defines total shares issued to a validator's delegators. */
                        delegator_shares: string
                        /** description defines the description terms for the validator. */
                        description: {
                            /** moniker defines a human-readable name for the validator. */
                            moniker: string
                            /** identity defines an optional identity signature (ex. UPort or Keybase). */
                            identity: string
                            /** website defines an optional website link. */
                            website: string
                            /** security_contact defines an optional email for security contact. */
                            security_contact: string
                            /** details define other optional details. */
                            details: string
                        }
                        /** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
                        unbonding_height: string
                        /** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
                        unbonding_time: string
                        /** commission defines the commission parameters. */
                        commission: {
                            /** commission_rates defines the initial commission rates to be used for creating a validator. */
                            commission_rates: {
                                /** rate is the commission rate charged to delegators, as a fraction. */
                                rate: string
                                /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                                max_rate: string
                                /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                                max_change_rate: string
                            }
                            /** update_time is the last time the commission rate was changed. */
                            update_time: string
                        }
                        /** min_self_delegation is the validator's self declared minimum self delegation. */
                        min_self_delegation: string
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Validator queries validator info for given validator address. */
    Validator: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/validators/{validator_addr}' */
            evmos: `/cosmos/staking/v1beta1/validators/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** validator_addr defines the validator address to query for. */
                    validator_addr: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryValidatorResponse is response type for the Query/Validator RPC method */
                {
                    /** Validator defines a validator, together with the total amount of the
                    Validator's bond shares and their exchange rate to coins. Slashing results in
                    a decrease in the exchange rate, allowing correct calculation of future
                    undelegations without iterating over delegators. When coins are delegated to
                    this validator, the validator is credited with a delegation whose number of
                    bond shares is based on the amount of coins delegated divided by the current
                    exchange rate. Voting power can be calculated as total bonded shares
                    multiplied by exchange rate. */
                    validator: {
                        /** operator_address defines the address of the validator's operator; bech encoded in JSON. */
                        operator_address: string
                        /** `Any` contains an arbitrary serialized protocol buffer message along with a
                        URL that describes the type of the serialized message.
                        
                        Protobuf library provides support to pack/unpack Any values in the form
                        of utility functions or additional generated methods of the Any type.
                        
                        Example 1: Pack and unpack a message in C++.
                        
                            Foo foo = ...;
                            Any any;
                            any.PackFrom(foo);
                            ...
                            if (any.UnpackTo(&foo)) {
                              ...
                            }
                        
                        Example 2: Pack and unpack a message in Java.
                        
                            Foo foo = ...;
                            Any any = Any.pack(foo);
                            ...
                            if (any.is(Foo.class)) {
                              foo = any.unpack(Foo.class);
                            }
                        
                         Example 3: Pack and unpack a message in Python.
                        
                            foo = Foo(...)
                            any = Any()
                            any.Pack(foo)
                            ...
                            if any.Is(Foo.DESCRIPTOR):
                              any.Unpack(foo)
                              ...
                        
                         Example 4: Pack and unpack a message in Go
                        
                             foo := &pb.Foo{...}
                             any, err := anypb.New(foo)
                             if err != nil {
                               ...
                             }
                             ...
                             foo := &pb.Foo{}
                             if err := any.UnmarshalTo(foo); err != nil {
                               ...
                             }
                        
                        The pack methods provided by protobuf library will by default use
                        'type.googleapis.com/full.type.name' as the type URL and the unpack
                        methods only use the fully qualified type name after the last '/'
                        in the type URL, for example "foo.bar.com/x/y.z" will yield type
                        name "y.z".
                        
                        
                        JSON
                        ====
                        The JSON representation of an `Any` value uses the regular
                        representation of the deserialized, embedded message, with an
                        additional field `@type` which contains the type URL. Example:
                        
                            package google.profile;
                            message Person {
                              string first_name = 1;
                              string last_name = 2;
                            }
                        
                            {
                              "@type": "type.googleapis.com/google.profile.Person",
                              "firstName": <string>,
                              "lastName": <string>
                            }
                        
                        If the embedded message type is well-known and has a custom JSON
                        representation, that representation will be embedded adding a field
                        `value` which holds the custom JSON in addition to the `@type`
                        field. Example (for message [google.protobuf.Duration][]):
                        
                            {
                              "@type": "type.googleapis.com/google.protobuf.Duration",
                              "value": "1.212s"
                            } */
                        consensus_pubkey: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                        /** jailed defined whether the validator has been jailed from bonded status or not. */
                        jailed: boolean
                        /** status is the validator status (bonded/unbonding/unbonded). */
                        status: string
                        /** tokens define the delegated tokens (incl. self-delegation). */
                        tokens: string
                        /** delegator_shares defines total shares issued to a validator's delegators. */
                        delegator_shares: string
                        /** description defines the description terms for the validator. */
                        description: {
                            /** moniker defines a human-readable name for the validator. */
                            moniker: string
                            /** identity defines an optional identity signature (ex. UPort or Keybase). */
                            identity: string
                            /** website defines an optional website link. */
                            website: string
                            /** security_contact defines an optional email for security contact. */
                            security_contact: string
                            /** details define other optional details. */
                            details: string
                        }
                        /** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
                        unbonding_height: string
                        /** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
                        unbonding_time: string
                        /** commission defines the commission parameters. */
                        commission: {
                            /** commission_rates defines the initial commission rates to be used for creating a validator. */
                            commission_rates: {
                                /** rate is the commission rate charged to delegators, as a fraction. */
                                rate: string
                                /** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
                                max_rate: string
                                /** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
                                max_change_rate: string
                            }
                            /** update_time is the last time the commission rate was changed. */
                            update_time: string
                        }
                        /** min_self_delegation is the validator's self declared minimum self delegation. */
                        min_self_delegation: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ValidatorDelegations queries delegate info for given validator. */
    ValidatorDelegations: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/validators/{validator_addr}/delegations' */
            evmos: `/cosmos/staking/v1beta1/validators/${string}/delegations`
        }
        params: {
            path: {
                evmos: {
                    /** validator_addr defines the validator address to query for. */
                    validator_addr: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryValidatorDelegationsResponse is response type for the
Query/ValidatorDelegations RPC method */
                {
                    delegation_responses: Array<{
                        /** Delegation represents the bond with tokens held by an account. It is
                        owned by one delegator, and is associated with the voting power of one
                        validator. */
                        delegation: {
                            /** delegator_address is the bech32-encoded address of the delegator. */
                            delegator_address: string
                            /** validator_address is the bech32-encoded address of the validator. */
                            validator_address: string
                            /** shares define the delegation shares received. */
                            shares: string
                        }
                        /** Coin defines a token with a denomination and an amount.
                        
                        NOTE: The amount field is an Int which implements the custom method
                        signatures required by gogoproto. */
                        balance: {
                            denom: string
                            amount: string
                        }
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Delegation queries delegate info for given validator delegator pair. */
    Delegation: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}' */
            evmos: `/cosmos/staking/v1beta1/validators/${string}/delegations/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** validator_addr defines the validator address to query for. */
                    validator_addr: string
                    /** delegator_addr defines the delegator address to query for. */
                    delegator_addr: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryDelegationResponse is response type for the Query/Delegation RPC method. */
                {
                    /** DelegationResponse is equivalent to Delegation except that it contains a
                    balance in addition to shares which is more suitable for client responses. */
                    delegation_response: {
                        /** Delegation represents the bond with tokens held by an account. It is
                        owned by one delegator, and is associated with the voting power of one
                        validator. */
                        delegation: {
                            /** delegator_address is the bech32-encoded address of the delegator. */
                            delegator_address: string
                            /** validator_address is the bech32-encoded address of the validator. */
                            validator_address: string
                            /** shares define the delegation shares received. */
                            shares: string
                        }
                        /** Coin defines a token with a denomination and an amount.
                        
                        NOTE: The amount field is an Int which implements the custom method
                        signatures required by gogoproto. */
                        balance: {
                            denom: string
                            amount: string
                        }
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** UnbondingDelegation queries unbonding info for given validator delegator
    pair. */
    UnbondingDelegation: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation' */
            evmos: `/cosmos/staking/v1beta1/validators/${string}/delegations/${string}/unbonding_delegation`
        }
        params: {
            path: {
                evmos: {
                    /** validator_addr defines the validator address to query for. */
                    validator_addr: string
                    /** delegator_addr defines the delegator address to query for. */
                    delegator_addr: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** QueryDelegationResponse is response type for the Query/UnbondingDelegation
RPC method. */
                {
                    /** UnbondingDelegation stores all of a single delegator's unbonding bonds
                    for a single validator in an time-ordered list. */
                    unbond: {
                        /** delegator_address is the bech32-encoded address of the delegator. */
                        delegator_address: string
                        /** validator_address is the bech32-encoded address of the validator. */
                        validator_address: string
                        /** entries are the unbonding delegation entries. */
                        entries: Array<{
                            /** creation_height is the height which the unbonding took place. */
                            creation_height: string
                            /** completion_time is the unix time for unbonding completion. */
                            completion_time: string
                            /** initial_balance defines the tokens initially scheduled to receive at completion. */
                            initial_balance: string
                            /** balance defines the tokens to receive at completion. */
                            balance: string
                        }>
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** ValidatorUnbondingDelegations queries unbonding delegations of a validator. */
    ValidatorUnbondingDelegations: {
        method: 'get'
        endpoint: {
            /** '/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations' */
            evmos: `/cosmos/staking/v1beta1/validators/${string}/unbonding_delegations`
        }
        params: {
            path: {
                evmos: {
                    /** validator_addr defines the validator address to query for. */
                    validator_addr: string
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** QueryValidatorUnbondingDelegationsResponse is response type for the
Query/ValidatorUnbondingDelegations RPC method. */
                {
                    unbonding_responses: Array<{
                        /** delegator_address is the bech32-encoded address of the delegator. */
                        delegator_address: string
                        /** validator_address is the bech32-encoded address of the validator. */
                        validator_address: string
                        /** entries are the unbonding delegation entries. */
                        entries: Array<{
                            /** creation_height is the height which the unbonding took place. */
                            creation_height: string
                            /** completion_time is the unix time for unbonding completion. */
                            completion_time: string
                            /** initial_balance defines the tokens initially scheduled to receive at completion. */
                            initial_balance: string
                            /** balance defines the tokens to receive at completion. */
                            balance: string
                        }>
                    }>
                    /** pagination defines the pagination in the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** Simulate simulates executing a transaction for estimating gas usage. */
    Simulate: {
        method: 'post'
        endpoint: {
            /** '/cosmos/tx/v1beta1/simulate' */
            evmos: `/cosmos/tx/v1beta1/simulate`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    'body': unknown
                }
            }
            body: {
                evmos: {
                    'body': unknown
                }
            }
        }
        response: {
            success: {
                evmos: /** SimulateResponse is the response type for the
Service.SimulateRPC method. */
                {
                    /** gas_info is the information about gas used in the simulation. */
                    gas_info: {
                        /** GasWanted is the maximum units of work we allow this tx to perform. */
                        gas_wanted: string
                        /** GasUsed is the amount of gas actually consumed. */
                        gas_used: string
                    }
                    /** result is the result of the simulation. */
                    result: {
                        /** Data is any data returned from message or handler execution. It MUST be
                        length prefixed in order to separate data from multiple message executions. */
                        data: string
                        /** Log contains the log information from message or handler execution. */
                        log: string
                        /** Events contains a slice of Event objects that were emitted during message
                        or handler execution. */
                        events: Array<{
                            type: string
                            attributes: Array<{
                                key: string
                                value: string
                                index: boolean
                            }>
                        }>
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** GetTxsEvent fetches txs by event. */
    GetTxsEvent: {
        method: 'get'
        endpoint: {
            /** '/cosmos/tx/v1beta1/txs' */
            evmos: `/cosmos/tx/v1beta1/txs`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** events is the list of transaction event type. */
                    events: string
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                    /**  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.
                     - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order
                     - ORDER_BY_DESC: ORDER_BY_DESC defines descending order */
                    order_by: string
                }
            }
            body: {
                evmos: {
                    /** events is the list of transaction event type. */
                    events: string
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                    /**  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.
                     - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order
                     - ORDER_BY_DESC: ORDER_BY_DESC defines descending order */
                    order_by: string
                }
            }
        }
        response: {
            success: {
                evmos: unknown
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** GetBlockWithTxs fetches a block with decoded txs. */
    GetBlockWithTxs: {
        method: 'get'
        endpoint: {
            /** '/cosmos/tx/v1beta1/txs/block/{height}' */
            evmos: `/cosmos/tx/v1beta1/txs/block/${number}`
        }
        params: {
            path: {
                evmos: {
                    /** height is the height of the block to query. */
                    height: number
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: unknown
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** GetTx fetches a tx by hash. */
    GetTx: {
        method: 'get'
        endpoint: {
            /** '/cosmos/tx/v1beta1/txs/{hash}' */
            evmos: `/cosmos/tx/v1beta1/txs/${string}`
        }
        params: {
            path: {
                evmos: {
                    /** hash is the tx hash to query, encoded as a hex string. */
                    hash: string
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: unknown
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** GetLatestBlock returns the latest block. */
    GetLatestBlock: {
        method: 'get'
        endpoint: {
            /** '/cosmos/base/tendermint/v1beta1/blocks/latest' */
            evmos: `/cosmos/base/tendermint/v1beta1/blocks/latest`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method. */
                {
                    /** BlockID */
                    block_id: {
                        hash: string
                        /** PartsetHeader */
                        part_set_header: {
                            total: number
                            hash: string
                        }
                    }
                    block: {
                        /** Header defines the structure of a Tendermint block header. */
                        header: {
                            /** basic block info */
                            version: {
                                block: string
                                app: string
                            }
                            chain_id: string
                            height: string
                            time: string
                            /** BlockID */
                            last_block_id: {
                                hash: string
                                /** PartsetHeader */
                                part_set_header: {
                                    total: number
                                    hash: string
                                }
                            }
                            /** hashes of block data */
                            last_commit_hash: string
                            data_hash: string
                            /** hashes from the app output from the prev block */
                            validators_hash: string
                            next_validators_hash: string
                            consensus_hash: string
                            app_hash: string
                            last_results_hash: string
                            /** consensus info */
                            evidence_hash: string
                            proposer_address: string
                        }
                        /** Data contains the set of transactions included in the block */
                        data: {
                            /** Txs that will be applied by state @ block.Height+1.
                            NOTE: not all txs here are valid.  We're just agreeing on the order first.
                            This means that block.AppHash does not include these txs. */
                            txs: Array<string>
                        }
                        evidence: {
                            evidence: Array<{
                                /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting
                                votes. */
                                duplicate_vote_evidence: {
                                    /** Vote represents a prevote, precommit, or commit vote from validators for
                                    consensus. */
                                    vote_a: {
                                        /** SignedMsgType is a type of signed message in the consensus.
                                        
                                         - SIGNED_MSG_TYPE_PREVOTE: Votes
                                         - SIGNED_MSG_TYPE_PROPOSAL: Proposals */
                                        type: string
                                        height: string
                                        round: number
                                        /** BlockID */
                                        block_id: {
                                            hash: string
                                            /** PartsetHeader */
                                            part_set_header: {
                                                total: number
                                                hash: string
                                            }
                                        }
                                        timestamp: string
                                        validator_address: string
                                        validator_index: number
                                        signature: string
                                    }
                                    /** Vote represents a prevote, precommit, or commit vote from validators for
                                    consensus. */
                                    vote_b: {
                                        /** SignedMsgType is a type of signed message in the consensus.
                                        
                                         - SIGNED_MSG_TYPE_PREVOTE: Votes
                                         - SIGNED_MSG_TYPE_PROPOSAL: Proposals */
                                        type: string
                                        height: string
                                        round: number
                                        /** BlockID */
                                        block_id: {
                                            hash: string
                                            /** PartsetHeader */
                                            part_set_header: {
                                                total: number
                                                hash: string
                                            }
                                        }
                                        timestamp: string
                                        validator_address: string
                                        validator_index: number
                                        signature: string
                                    }
                                    total_voting_power: string
                                    validator_power: string
                                    timestamp: string
                                }
                                /** LightClientAttackEvidence contains evidence of a set of validators attempting
                                to mislead a light client. */
                                light_client_attack_evidence: {
                                    conflicting_block: {
                                        signed_header: {
                                            /** Header defines the structure of a Tendermint block header. */
                                            header: {
                                                /** basic block info */
                                                version: {
                                                    block: string
                                                    app: string
                                                }
                                                chain_id: string
                                                height: string
                                                time: string
                                                /** BlockID */
                                                last_block_id: {
                                                    hash: string
                                                    /** PartsetHeader */
                                                    part_set_header: {
                                                        total: number
                                                        hash: string
                                                    }
                                                }
                                                /** hashes of block data */
                                                last_commit_hash: string
                                                data_hash: string
                                                /** hashes from the app output from the prev block */
                                                validators_hash: string
                                                next_validators_hash: string
                                                consensus_hash: string
                                                app_hash: string
                                                last_results_hash: string
                                                /** consensus info */
                                                evidence_hash: string
                                                proposer_address: string
                                            }
                                            /** Commit contains the evidence that a block was committed by a set of
                                            validators. */
                                            commit: {
                                                height: string
                                                round: number
                                                /** BlockID */
                                                block_id: {
                                                    hash: string
                                                    /** PartsetHeader */
                                                    part_set_header: {
                                                        total: number
                                                        hash: string
                                                    }
                                                }
                                                signatures: Array<{
                                                    /** BlockIdFlag indicates which BlcokID the signature is for */
                                                    block_id_flag: string
                                                    validator_address: string
                                                    timestamp: string
                                                    signature: string
                                                }>
                                            }
                                        }
                                        validator_set: {
                                            validators: Array<{
                                                address: string
                                                /** PublicKey defines the keys available for use with Tendermint Validators */
                                                pub_key: {
                                                    ed25519: string
                                                    secp256k1: string
                                                }
                                                voting_power: string
                                                proposer_priority: string
                                            }>
                                            proposer: {
                                                address: string
                                                /** PublicKey defines the keys available for use with Tendermint Validators */
                                                pub_key: {
                                                    ed25519: string
                                                    secp256k1: string
                                                }
                                                voting_power: string
                                                proposer_priority: string
                                            }
                                            total_voting_power: string
                                        }
                                    }
                                    common_height: string
                                    byzantine_validators: Array<{
                                        address: string
                                        /** PublicKey defines the keys available for use with Tendermint Validators */
                                        pub_key: {
                                            ed25519: string
                                            secp256k1: string
                                        }
                                        voting_power: string
                                        proposer_priority: string
                                    }>
                                    total_voting_power: string
                                    timestamp: string
                                }
                            }>
                        }
                        /** Commit contains the evidence that a block was committed by a set of
                        validators. */
                        last_commit: {
                            height: string
                            round: number
                            /** BlockID */
                            block_id: {
                                hash: string
                                /** PartsetHeader */
                                part_set_header: {
                                    total: number
                                    hash: string
                                }
                            }
                            signatures: Array<{
                                /** BlockIdFlag indicates which BlcokID the signature is for */
                                block_id_flag: string
                                validator_address: string
                                timestamp: string
                                signature: string
                            }>
                        }
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** GetBlockByHeight queries block for given height. */
    GetBlockByHeight: {
        method: 'get'
        endpoint: {
            /** '/cosmos/base/tendermint/v1beta1/blocks/{height}' */
            evmos: `/cosmos/base/tendermint/v1beta1/blocks/${number}`
        }
        params: {
            path: {
                evmos: {
                    height: number
                }
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method. */
                {
                    /** BlockID */
                    block_id: {
                        hash: string
                        /** PartsetHeader */
                        part_set_header: {
                            total: number
                            hash: string
                        }
                    }
                    block: {
                        /** Header defines the structure of a Tendermint block header. */
                        header: {
                            /** basic block info */
                            version: {
                                block: string
                                app: string
                            }
                            chain_id: string
                            height: string
                            time: string
                            /** BlockID */
                            last_block_id: {
                                hash: string
                                /** PartsetHeader */
                                part_set_header: {
                                    total: number
                                    hash: string
                                }
                            }
                            /** hashes of block data */
                            last_commit_hash: string
                            data_hash: string
                            /** hashes from the app output from the prev block */
                            validators_hash: string
                            next_validators_hash: string
                            consensus_hash: string
                            app_hash: string
                            last_results_hash: string
                            /** consensus info */
                            evidence_hash: string
                            proposer_address: string
                        }
                        /** Data contains the set of transactions included in the block */
                        data: {
                            /** Txs that will be applied by state @ block.Height+1.
                            NOTE: not all txs here are valid.  We're just agreeing on the order first.
                            This means that block.AppHash does not include these txs. */
                            txs: Array<string>
                        }
                        evidence: {
                            evidence: Array<{
                                /** DuplicateVoteEvidence contains evidence of a validator signed two conflicting
                                votes. */
                                duplicate_vote_evidence: {
                                    /** Vote represents a prevote, precommit, or commit vote from validators for
                                    consensus. */
                                    vote_a: {
                                        /** SignedMsgType is a type of signed message in the consensus.
                                        
                                         - SIGNED_MSG_TYPE_PREVOTE: Votes
                                         - SIGNED_MSG_TYPE_PROPOSAL: Proposals */
                                        type: string
                                        height: string
                                        round: number
                                        /** BlockID */
                                        block_id: {
                                            hash: string
                                            /** PartsetHeader */
                                            part_set_header: {
                                                total: number
                                                hash: string
                                            }
                                        }
                                        timestamp: string
                                        validator_address: string
                                        validator_index: number
                                        signature: string
                                    }
                                    /** Vote represents a prevote, precommit, or commit vote from validators for
                                    consensus. */
                                    vote_b: {
                                        /** SignedMsgType is a type of signed message in the consensus.
                                        
                                         - SIGNED_MSG_TYPE_PREVOTE: Votes
                                         - SIGNED_MSG_TYPE_PROPOSAL: Proposals */
                                        type: string
                                        height: string
                                        round: number
                                        /** BlockID */
                                        block_id: {
                                            hash: string
                                            /** PartsetHeader */
                                            part_set_header: {
                                                total: number
                                                hash: string
                                            }
                                        }
                                        timestamp: string
                                        validator_address: string
                                        validator_index: number
                                        signature: string
                                    }
                                    total_voting_power: string
                                    validator_power: string
                                    timestamp: string
                                }
                                /** LightClientAttackEvidence contains evidence of a set of validators attempting
                                to mislead a light client. */
                                light_client_attack_evidence: {
                                    conflicting_block: {
                                        signed_header: {
                                            /** Header defines the structure of a Tendermint block header. */
                                            header: {
                                                /** basic block info */
                                                version: {
                                                    block: string
                                                    app: string
                                                }
                                                chain_id: string
                                                height: string
                                                time: string
                                                /** BlockID */
                                                last_block_id: {
                                                    hash: string
                                                    /** PartsetHeader */
                                                    part_set_header: {
                                                        total: number
                                                        hash: string
                                                    }
                                                }
                                                /** hashes of block data */
                                                last_commit_hash: string
                                                data_hash: string
                                                /** hashes from the app output from the prev block */
                                                validators_hash: string
                                                next_validators_hash: string
                                                consensus_hash: string
                                                app_hash: string
                                                last_results_hash: string
                                                /** consensus info */
                                                evidence_hash: string
                                                proposer_address: string
                                            }
                                            /** Commit contains the evidence that a block was committed by a set of
                                            validators. */
                                            commit: {
                                                height: string
                                                round: number
                                                /** BlockID */
                                                block_id: {
                                                    hash: string
                                                    /** PartsetHeader */
                                                    part_set_header: {
                                                        total: number
                                                        hash: string
                                                    }
                                                }
                                                signatures: Array<{
                                                    /** BlockIdFlag indicates which BlcokID the signature is for */
                                                    block_id_flag: string
                                                    validator_address: string
                                                    timestamp: string
                                                    signature: string
                                                }>
                                            }
                                        }
                                        validator_set: {
                                            validators: Array<{
                                                address: string
                                                /** PublicKey defines the keys available for use with Tendermint Validators */
                                                pub_key: {
                                                    ed25519: string
                                                    secp256k1: string
                                                }
                                                voting_power: string
                                                proposer_priority: string
                                            }>
                                            proposer: {
                                                address: string
                                                /** PublicKey defines the keys available for use with Tendermint Validators */
                                                pub_key: {
                                                    ed25519: string
                                                    secp256k1: string
                                                }
                                                voting_power: string
                                                proposer_priority: string
                                            }
                                            total_voting_power: string
                                        }
                                    }
                                    common_height: string
                                    byzantine_validators: Array<{
                                        address: string
                                        /** PublicKey defines the keys available for use with Tendermint Validators */
                                        pub_key: {
                                            ed25519: string
                                            secp256k1: string
                                        }
                                        voting_power: string
                                        proposer_priority: string
                                    }>
                                    total_voting_power: string
                                    timestamp: string
                                }
                            }>
                        }
                        /** Commit contains the evidence that a block was committed by a set of
                        validators. */
                        last_commit: {
                            height: string
                            round: number
                            /** BlockID */
                            block_id: {
                                hash: string
                                /** PartsetHeader */
                                part_set_header: {
                                    total: number
                                    hash: string
                                }
                            }
                            signatures: Array<{
                                /** BlockIdFlag indicates which BlcokID the signature is for */
                                block_id_flag: string
                                validator_address: string
                                timestamp: string
                                signature: string
                            }>
                        }
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** GetNodeInfo queries the current node info. */
    GetNodeInfo: {
        method: 'get'
        endpoint: {
            /** '/cosmos/base/tendermint/v1beta1/node_info' */
            evmos: `/cosmos/base/tendermint/v1beta1/node_info`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** GetNodeInfoResponse is the request type for the Query/GetNodeInfo RPC method. */
                {
                    default_node_info: {
                        protocol_version: {
                            p2p: string
                            block: string
                            app: string
                        }
                        default_node_id: string
                        listen_addr: string
                        network: string
                        version: string
                        channels: string
                        moniker: string
                        other: {
                            tx_index: string
                            rpc_address: string
                        }
                    }
                    /** VersionInfo is the type for the GetNodeInfoResponse message. */
                    application_version: {
                        name: string
                        app_name: string
                        version: string
                        git_commit: string
                        build_tags: string
                        go_version: string
                        build_deps: Array<{
                            /** module path */
                            path: string
                            /** module version */
                            version: string
                            /** checksum */
                            sum: string
                        }>
                        /** Since: cosmos-sdk 0.43 */
                        cosmos_sdk_version: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** GetSyncing queries node syncing. */
    GetSyncing: {
        method: 'get'
        endpoint: {
            /** '/cosmos/base/tendermint/v1beta1/syncing' */
            evmos: `/cosmos/base/tendermint/v1beta1/syncing`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: undefined
            }
            body: {
                evmos: undefined
            }
        }
        response: {
            success: {
                evmos: /** GetSyncingResponse is the response type for the Query/GetSyncing RPC method. */
                {
                    syncing: boolean
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** GetLatestValidatorSet queries latest validator-set. */
    GetLatestValidatorSet: {
        method: 'get'
        endpoint: {
            /** '/cosmos/base/tendermint/v1beta1/validatorsets/latest' */
            evmos: `/cosmos/base/tendermint/v1beta1/validatorsets/latest`
        }
        params: {
            path: {
                evmos: undefined
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method. */
                {
                    block_height: string
                    validators: Array<{
                        address: string
                        /** `Any` contains an arbitrary serialized protocol buffer message along with a
                        URL that describes the type of the serialized message.
                        
                        Protobuf library provides support to pack/unpack Any values in the form
                        of utility functions or additional generated methods of the Any type.
                        
                        Example 1: Pack and unpack a message in C++.
                        
                            Foo foo = ...;
                            Any any;
                            any.PackFrom(foo);
                            ...
                            if (any.UnpackTo(&foo)) {
                              ...
                            }
                        
                        Example 2: Pack and unpack a message in Java.
                        
                            Foo foo = ...;
                            Any any = Any.pack(foo);
                            ...
                            if (any.is(Foo.class)) {
                              foo = any.unpack(Foo.class);
                            }
                        
                         Example 3: Pack and unpack a message in Python.
                        
                            foo = Foo(...)
                            any = Any()
                            any.Pack(foo)
                            ...
                            if any.Is(Foo.DESCRIPTOR):
                              any.Unpack(foo)
                              ...
                        
                         Example 4: Pack and unpack a message in Go
                        
                             foo := &pb.Foo{...}
                             any, err := anypb.New(foo)
                             if err != nil {
                               ...
                             }
                             ...
                             foo := &pb.Foo{}
                             if err := any.UnmarshalTo(foo); err != nil {
                               ...
                             }
                        
                        The pack methods provided by protobuf library will by default use
                        'type.googleapis.com/full.type.name' as the type URL and the unpack
                        methods only use the fully qualified type name after the last '/'
                        in the type URL, for example "foo.bar.com/x/y.z" will yield type
                        name "y.z".
                        
                        
                        JSON
                        ====
                        The JSON representation of an `Any` value uses the regular
                        representation of the deserialized, embedded message, with an
                        additional field `@type` which contains the type URL. Example:
                        
                            package google.profile;
                            message Person {
                              string first_name = 1;
                              string last_name = 2;
                            }
                        
                            {
                              "@type": "type.googleapis.com/google.profile.Person",
                              "firstName": <string>,
                              "lastName": <string>
                            }
                        
                        If the embedded message type is well-known and has a custom JSON
                        representation, that representation will be embedded adding a field
                        `value` which holds the custom JSON in addition to the `@type`
                        field. Example (for message [google.protobuf.Duration][]):
                        
                            {
                              "@type": "type.googleapis.com/google.protobuf.Duration",
                              "value": "1.212s"
                            } */
                        pub_key: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                        voting_power: string
                        proposer_priority: string
                    }>
                    /** pagination defines an pagination for the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

    /** GetValidatorSetByHeight queries validator-set at a given height. */
    GetValidatorSetByHeight: {
        method: 'get'
        endpoint: {
            /** '/cosmos/base/tendermint/v1beta1/validatorsets/{height}' */
            evmos: `/cosmos/base/tendermint/v1beta1/validatorsets/${number}`
        }
        params: {
            path: {
                evmos: {
                    height: number
                }
            }

            query: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
            body: {
                evmos: {
                    /** key is a value returned in PageResponse.next_key to begin
                    querying the next page most efficiently. Only one of offset or key
                    should be set. */
                    'pagination.key': string
                    /** offset is a numeric offset that can be used when key is unavailable.
                    It is less efficient than using key. Only one of offset or key should
                    be set. */
                    'pagination.offset': number
                    /** limit is the total number of results to be returned in the result page.
                    If left empty it will default to a value to be set by each app. */
                    'pagination.limit': number
                    /** count_total is set to true  to indicate that the result set should include
                    a count of the total number of items available for pagination in UIs.
                    count_total is only respected when offset is used. It is ignored when key
                    is set. */
                    'pagination.count_total': string
                    /** reverse is set to true if results are to be returned in the descending order.
                    
                    Since: cosmos-sdk 0.43 */
                    'pagination.reverse': string
                }
            }
        }
        response: {
            success: {
                evmos: /** GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method. */
                {
                    block_height: string
                    validators: Array<{
                        address: string
                        /** `Any` contains an arbitrary serialized protocol buffer message along with a
                        URL that describes the type of the serialized message.
                        
                        Protobuf library provides support to pack/unpack Any values in the form
                        of utility functions or additional generated methods of the Any type.
                        
                        Example 1: Pack and unpack a message in C++.
                        
                            Foo foo = ...;
                            Any any;
                            any.PackFrom(foo);
                            ...
                            if (any.UnpackTo(&foo)) {
                              ...
                            }
                        
                        Example 2: Pack and unpack a message in Java.
                        
                            Foo foo = ...;
                            Any any = Any.pack(foo);
                            ...
                            if (any.is(Foo.class)) {
                              foo = any.unpack(Foo.class);
                            }
                        
                         Example 3: Pack and unpack a message in Python.
                        
                            foo = Foo(...)
                            any = Any()
                            any.Pack(foo)
                            ...
                            if any.Is(Foo.DESCRIPTOR):
                              any.Unpack(foo)
                              ...
                        
                         Example 4: Pack and unpack a message in Go
                        
                             foo := &pb.Foo{...}
                             any, err := anypb.New(foo)
                             if err != nil {
                               ...
                             }
                             ...
                             foo := &pb.Foo{}
                             if err := any.UnmarshalTo(foo); err != nil {
                               ...
                             }
                        
                        The pack methods provided by protobuf library will by default use
                        'type.googleapis.com/full.type.name' as the type URL and the unpack
                        methods only use the fully qualified type name after the last '/'
                        in the type URL, for example "foo.bar.com/x/y.z" will yield type
                        name "y.z".
                        
                        
                        JSON
                        ====
                        The JSON representation of an `Any` value uses the regular
                        representation of the deserialized, embedded message, with an
                        additional field `@type` which contains the type URL. Example:
                        
                            package google.profile;
                            message Person {
                              string first_name = 1;
                              string last_name = 2;
                            }
                        
                            {
                              "@type": "type.googleapis.com/google.profile.Person",
                              "firstName": <string>,
                              "lastName": <string>
                            }
                        
                        If the embedded message type is well-known and has a custom JSON
                        representation, that representation will be embedded adding a field
                        `value` which holds the custom JSON in addition to the `@type`
                        field. Example (for message [google.protobuf.Duration][]):
                        
                            {
                              "@type": "type.googleapis.com/google.protobuf.Duration",
                              "value": "1.212s"
                            } */
                        pub_key: {
                            type_url: string
                            /** Must be a valid serialized protocol buffer of the above specified type. */
                            value: string
                        }
                        voting_power: string
                        proposer_priority: string
                    }>
                    /** pagination defines an pagination for the response. */
                    pagination: {
                        /** next_key is the key to be passed to PageRequest.key to
                        query the next page most efficiently */
                        next_key: string
                        /** total is total number of results available if PageRequest.count_total
                        was set, its value is undefined otherwise */
                        total: string
                    }
                }
            }
            error: {
                evmos: {
                    error: string
                    code: number
                    message: string
                    details: Array<{
                        type_url: string
                        /** Must be a valid serialized protocol buffer of the above specified type. */
                        value: string
                    }>
                }
            }
        }

    }

}

/** Represent any of the available chain names. */
export type ChainName = | 'kyve' | 'evmos'

/** Represent any of the available operation IDs. */
export type OperationId = keyof RestApi
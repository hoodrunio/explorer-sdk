// DO NOT EDIT THIS FILE MANUALLY

/** REST API endpoint based on given `ChainName` and `OperationId`. */
    export type RestApiEndpoint<N extends ChainName, I extends OperationId> =
    RestApi[I] extends { endpoint: { [chainName in N]: infer E } } ? E : never

/** REST API path parameters based on given `ChainName` and `OperationId`. */
    export type RestApiPathParams<N extends ChainName, I extends OperationId> =
    RestApi[I] extends { params: { path: { [chainName in N]: infer E } } } ? E : never

/** REST API query parameters based on given `ChainName` and `OperationId`. */
    export type RestApiQueryParams<N extends ChainName, I extends OperationId> =
    RestApi[I] extends { params: { query: { [chainName in N]: infer E } } } ? E : never

/** REST API body parameters based on given `ChainName` and `OperationId`. */
    export type RestApiBodyParams<N extends ChainName, I extends OperationId> =
    RestApi[I] extends { params: { body: { [chainName in N]: infer E } } } ? E : never

/** REST API successful response type based on given `ChainName` and `OperationId`. */
    export type RestApiSuccessResponse<N extends ChainName, I extends OperationId> =
    RestApi[I] extends { response: { success: { [chainName in N]: infer E } } } ? E : never

/** REST API error response type based on given `ChainName` and `OperationId`. */
    export type RestApiErrorResponse<N extends ChainName, I extends OperationId> =
    RestApi[I] extends { response: { error: { [chainName in N]: infer E } } } ? E : never

/** Stores everything related to Rest API. */
    export interface RestApi {
/** ClaimsRecords returns all claims records */
ClaimsRecords: {
    method: 'get'
    endpoint: {
/** '/evmos/claims/v1/claims_records' */
evmos: `/evmos/claims/v1/claims_records`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
evmos: /** QueryClaimsRecordsResponse is the response type for the Query/ClaimsRecords
RPC method. */
{
/** claims defines all claims records */
claims: Array<{
/** bech32 or hex address of claim user */
address: string
/** total initial claimable amount for the user */
initial_claimable_amount: string
/** slice of the available actions completed */
actions_completed: Array<boolean>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** ClaimsRecord returns the claims record for a given address */
ClaimsRecord: {
    method: 'get'
    endpoint: {
/** '/evmos/claims/v1/claims_records/{address}' */
evmos: `/evmos/claims/v1/claims_records/${string}`
}
    params: {
        path: {
evmos: {
/** address defines the user to query claims record for */
address: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryClaimsRecordResponse is the response type for the Query/ClaimsRecord RPC
method. */
{
/** total initial claimable amount for the user */
initial_claimable_amount: string
/** the claims of the user */
claims: Array<{
/** action enum */
action: string
/** true if the action has been completed */
completed: boolean
/** claimable token amount for the action. Zero if completed */
claimable_amount: string
}>
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Params returns the claims module parameters */
ClaimsParams: {
    method: 'get'
    endpoint: {
/** '/evmos/claims/v1/params' */
evmos: `/evmos/claims/v1/params`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
{
/** params defines the parameters of the module. */
params: {
/** enable claiming process */
enable_claims: boolean
/** timestamp of the airdrop start */
airdrop_start_time: string
/** duration until decay of claimable tokens begin */
duration_until_decay: string
/** duration of the token claim decay period */
duration_of_decay: string
/** denom of claimable coin */
claims_denom: string
/** list of authorized channel identifiers that can perform address
attestations via IBC. */
authorized_channels: Array<string>
/** list of channel identifiers from EVM compatible chains */
evm_channels: Array<string>
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** TotalUnclaimed queries the total unclaimed tokens from the airdrop */
TotalUnclaimed: {
    method: 'get'
    endpoint: {
/** '/evmos/claims/v1/total_unclaimed' */
evmos: `/evmos/claims/v1/total_unclaimed`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryTotalUnclaimedResponse is the response type for the Query/TotalUnclaimed
RPC method. */
{
/** coins defines the unclaimed coins */
coins: Array<{
denom: string
amount: string
}>
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** CurrentEpoch provide current epoch of specified identifier */
CurrentEpoch: {
    method: 'get'
    endpoint: {
/** '/evmos/epochs/v1/current_epoch' */
evmos: `/evmos/epochs/v1/current_epoch`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
identifier: string
}
}
        body: {
evmos: {
identifier: string
}
}
    }
    response: {
        success: {
evmos: {
current_epoch: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** EpochInfos provide running epochInfos */
EpochInfos: {
    method: 'get'
    endpoint: {
/** '/evmos/epochs/v1/epochs' */
evmos: `/evmos/epochs/v1/epochs`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
evmos: {
epochs: Array<{
identifier: string
start_time: string
duration: string
current_epoch: string
current_epoch_start_time: string
epoch_counting_started: boolean
current_epoch_start_height: string
}>
/** PageResponse is to be embedded in gRPC response messages where the
corresponding request message has used PageRequest.

 message SomeResponse {
         repeated Bar results = 1;
         PageResponse page = 2;
 } */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Params retrieves the erc20 module params */
ERC20Params: {
    method: 'get'
    endpoint: {
/** '/evmos/erc20/v1/params' */
evmos: `/evmos/erc20/v1/params`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryParamsResponse is the response type for the Query/Params RPC
method. */
{
/** Params defines the erc20 module params */
params: {
/** parameter to enable the conversion of Cosmos coins <--> ERC20 tokens. */
enable_erc20: boolean
/** parameter to enable the EVM hook that converts an ERC20 token to a Cosmos
Coin by transferring the Tokens through a MsgEthereumTx to the
ModuleAddress Ethereum address. */
enable_evm_hook: boolean
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** TokenPairs retrieves registered token pairs */
TokenPairs: {
    method: 'get'
    endpoint: {
/** '/evmos/erc20/v1/token_pairs' */
evmos: `/evmos/erc20/v1/token_pairs`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
evmos: /** QueryTokenPairsResponse is the response type for the Query/TokenPairs RPC
method. */
{
token_pairs: Array<{
/** address of ERC20 contract token */
erc20_address: string
/** cosmos base denomination to be mapped to */
denom: string
/** shows token mapping enable status */
enabled: boolean
/** ERC20 owner address ENUM (0 invalid, 1 ModuleAccount, 2 external address) */
contract_owner: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** TokenPair retrieves a registered token pair */
TokenPair: {
    method: 'get'
    endpoint: {
/** '/evmos/erc20/v1/token_pairs/{token}' */
evmos: `/evmos/erc20/v1/token_pairs/${string}`
}
    params: {
        path: {
evmos: {
/** token identifier can be either the hex contract address of the ERC20 or the
Cosmos base denomination */
token: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryTokenPairResponse is the response type for the Query/TokenPair RPC
method. */
{
/** TokenPair defines an instance that records a pairing consisting of a native
 Cosmos Coin and an ERC20 token address. */
token_pair: {
/** address of ERC20 contract token */
erc20_address: string
/** cosmos base denomination to be mapped to */
denom: string
/** shows token mapping enable status */
enabled: boolean
/** ERC20 owner address ENUM (0 invalid, 1 ModuleAccount, 2 external address) */
contract_owner: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** AllocationMeters retrieves active allocation meters for a given
denomination */
AllocationMeters: {
    method: 'get'
    endpoint: {
/** '/evmos/incentives/v1/allocation_meters' */
evmos: `/evmos/incentives/v1/allocation_meters`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
evmos: /** QueryAllocationMetersResponse is the response type for the
Query/AllocationMeters RPC method. */
{
allocation_meters: Array<{
denom: string
amount: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** AllocationMeter Retrieves a active gas meter */
AllocationMeter: {
    method: 'get'
    endpoint: {
/** '/evmos/incentives/v1/allocation_meters/{denom}' */
evmos: `/evmos/incentives/v1/allocation_meters/${string}`
}
    params: {
        path: {
evmos: {
/** denom is the coin denom to query an allocation meter for. */
denom: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryAllocationMeterResponse is the response type for the
Query/AllocationMeter RPC method. */
{
/** DecCoin defines a token with a denomination and a decimal amount.

NOTE: The amount field is an Dec which implements the custom method
signatures required by gogoproto. */
allocation_meter: {
denom: string
amount: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** GasMeters retrieves active gas meters for a given contract */
GasMeters: {
    method: 'get'
    endpoint: {
/** '/evmos/incentives/v1/gas_meters/{contract}' */
evmos: `/evmos/incentives/v1/gas_meters/${string}`
}
    params: {
        path: {
evmos: {
/** contract is the hex contract address of a incentivized smart contract */
contract: string
}
}
    
        query: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
evmos: /** QueryGasMetersResponse is the response type for the Query/Incentives RPC
method. */
{
gas_meters: Array<{
/** hex address of the incentivized contract */
contract: string
/** participant address that interacts with the incentive */
participant: string
/** cumulative gas spent during the epoch */
cumulative_gas: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** GasMeter Retrieves a active gas meter */
GasMeter: {
    method: 'get'
    endpoint: {
/** '/evmos/incentives/v1/gas_meters/{contract}/{participant}' */
evmos: `/evmos/incentives/v1/gas_meters/${string}/${string}`
}
    params: {
        path: {
evmos: {
/** contract identifier is the hex contract address of a contract */
contract: string
/** participant identifier is the hex address of a user */
participant: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryGasMeterResponse is the response type for the Query/Incentive RPC
method. */
{
gas_meter: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Incentives retrieves registered incentives */
Incentives: {
    method: 'get'
    endpoint: {
/** '/evmos/incentives/v1/incentives' */
evmos: `/evmos/incentives/v1/incentives`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
evmos: /** QueryIncentivesResponse is the response type for the Query/Incentives RPC
method. */
{
incentives: Array<{
/** contract address */
contract: string
/** denoms and percentage of rewards to be allocated */
allocations: Array<{
denom: string
amount: string
}>
/** number of remaining epochs */
epochs: number
/** distribution start time */
start_time: string
/** cumulative gas spent by all gasmeters of the incentive during the epoch */
total_gas: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Incentive retrieves a registered incentive */
Incentive: {
    method: 'get'
    endpoint: {
/** '/evmos/incentives/v1/incentives/{contract}' */
evmos: `/evmos/incentives/v1/incentives/${string}`
}
    params: {
        path: {
evmos: {
/** contract identifier is the hex contract address of a contract */
contract: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryIncentiveResponse is the response type for the Query/Incentive RPC
method. */
{
/** Incentive defines an instance that organizes distribution conditions for a
given smart contract */
incentive: {
/** contract address */
contract: string
/** denoms and percentage of rewards to be allocated */
allocations: Array<{
denom: string
amount: string
}>
/** number of remaining epochs */
epochs: number
/** distribution start time */
start_time: string
/** cumulative gas spent by all gasmeters of the incentive during the epoch */
total_gas: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Params retrieves the incentives module params */
IncentivesParams: {
    method: 'get'
    endpoint: {
/** '/evmos/incentives/v1/params' */
evmos: `/evmos/incentives/v1/params`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryParamsResponse is the response type for the Query/Params RPC
method. */
{
/** Params defines the incentives module params */
params: {
/** parameter to enable incentives */
enable_incentives: boolean
/** maximum percentage an incentive can allocate per denomination */
allocation_limit: string
/** identifier for the epochs module hooks */
incentives_epoch_identifier: string
/** scaling factor for capping rewards */
reward_scaler: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** CirculatingSupply retrieves the total number of tokens that are in
circulation (i.e. excluding unvested tokens). */
CirculatingSupply: {
    method: 'get'
    endpoint: {
/** '/evmos/inflation/v1/circulating_supply' */
evmos: `/evmos/inflation/v1/circulating_supply`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryCirculatingSupplyResponse is the response type for the
Query/CirculatingSupply RPC method. */
{
/** total amount of coins in circulation */
circulating_supply: {
denom: string
amount: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** EpochMintProvision retrieves current minting epoch provision value. */
EpochMintProvision: {
    method: 'get'
    endpoint: {
/** '/evmos/inflation/v1/epoch_mint_provision' */
evmos: `/evmos/inflation/v1/epoch_mint_provision`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryEpochMintProvisionResponse is the response type for the
Query/EpochMintProvision RPC method. */
{
/** epoch_mint_provision is the current minting per epoch provision value. */
epoch_mint_provision: {
denom: string
amount: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** InflationRate retrieves the inflation rate of the current period. */
InflationRate: {
    method: 'get'
    endpoint: {
/** '/evmos/inflation/v1/inflation_rate' */
evmos: `/evmos/inflation/v1/inflation_rate`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryInflationRateResponse is the response type for the Query/InflationRate
RPC method. */
{
/** rate by which the total supply increases within one period */
inflation_rate: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Params retrieves the total set of minting parameters. */
InflationParams: {
    method: 'get'
    endpoint: {
/** '/evmos/inflation/v1/params' */
evmos: `/evmos/inflation/v1/params`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
{
/** params defines the parameters of the module. */
params: {
/** type of coin to mint */
mint_denom: string
/** variables to calculate exponential inflation */
exponential_calculation: {
/** initial value */
a: string
/** reduction factor */
r: string
/** long term inflation */
c: string
/** bonding target */
bonding_target: string
/** max variance */
max_variance: string
}
/** inflation distribution of the minted denom */
inflation_distribution: {
/** staking_rewards defines the proportion of the minted minted_denom that is
to be allocated as staking rewards */
staking_rewards: string
/** usage_incentives defines the proportion of the minted minted_denom that is
to be allocated to the incentives module address */
usage_incentives: string
/** community_pool defines the proportion of the minted minted_denom that is to
be allocated to the community pool */
community_pool: string
}
/** parameter to enable inflation and halt increasing the skipped_epochs */
enable_inflation: boolean
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Period retrieves current period. */
Period: {
    method: 'get'
    endpoint: {
/** '/evmos/inflation/v1/period' */
evmos: `/evmos/inflation/v1/period`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryPeriodResponse is the response type for the Query/Period RPC method. */
{
/** period is the current minting per epoch provision value. */
period: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** SkippedEpochs retrieves the total number of skipped epochs. */
SkippedEpochs: {
    method: 'get'
    endpoint: {
/** '/evmos/inflation/v1/skipped_epochs' */
evmos: `/evmos/inflation/v1/skipped_epochs`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QuerySkippedEpochsResponse is the response type for the Query/SkippedEpochs
RPC method. */
{
/** number of epochs that the inflation module has been disabled. */
skipped_epochs: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Retrieves the unvested, vested and locked tokens for a vesting account */
Balances: {
    method: 'get'
    endpoint: {
/** '/evmos/vesting/v1/balances/{address}' */
evmos: `/evmos/vesting/v1/balances/${string}`
}
    params: {
        path: {
evmos: {
/** address of the clawback vesting account */
address: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryBalancesResponse is the response type for the Query/Balances RPC
method. */
{
/** current amount of locked tokens */
locked: Array<{
denom: string
amount: string
}>
/** current amount of unvested tokens */
unvested: Array<{
denom: string
amount: string
}>
/** current amount of vested tokens */
vested: Array<{
denom: string
amount: string
}>
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Params retrieves the total set of recovery parameters. */
RecoveryParams: {
    method: 'get'
    endpoint: {
/** '/evmos/recovery/v1/params' */
evmos: `/evmos/recovery/v1/params`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
{
/** Params holds parameters for the recovery module */
params: {
/** enable recovery IBC middleware */
enable_recovery: boolean
/** duration added to timeout timestamp for balances recovered via IBC packets */
packet_timeout_duration: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Account returns account details based on address. */
Account: {
    method: 'get'
    endpoint: {
/** '/cosmos/auth/v1beta1/accounts/{address}' */
axelar: `/cosmos/auth/v1beta1/accounts/${string}`
/** '/ethermint/evm/v1/account/{address}' */
evmos: `/ethermint/evm/v1/account/${string}`
}
    params: {
        path: {
axelar: {
/** address defines the address to query for. */
address: string
}
evmos: {
/** address is the ethereum hex address to query the account for. */
address: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryAccountResponse is the response type for the Query/Account RPC method. */
{
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
account: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
evmos: /** QueryAccountResponse is the response type for the Query/Account RPC method. */
{
/** balance is the balance of the EVM denomination. */
balance: string
/** code hash is the hex-formatted code bytes from the EOA. */
code_hash: string
/** nonce is the account's sequence number. */
nonce: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Balance queries the balance of a single coin for a single account. */
Balance: {
    method: 'get'
    endpoint: {
/** '/cosmos/bank/v1beta1/balances/{address}/by_denom' */
axelar: `/cosmos/bank/v1beta1/balances/${string}/by_denom`
/** '/ethermint/evm/v1/balances/{address}' */
evmos: `/ethermint/evm/v1/balances/${string}`
}
    params: {
        path: {
axelar: {
/** address is the address to query balances for. */
address: string
}
evmos: {
/** address is the ethereum hex address to query the balance for. */
address: string
}
}
    
        query: {
axelar: {
/** denom is the coin denom to query balances for. */
denom: string
}
evmos: undefined
}
        body: {
axelar: {
/** denom is the coin denom to query balances for. */
denom: string
}
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
{
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
balance: {
denom: string
amount: string
}
}
evmos: /** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
{
/** balance is the balance of the EVM denomination. */
balance: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** BaseFee queries the base fee of the parent block of the current block,
it's similar to feemarket module's method, but also checks london hardfork status. */
BaseFee: {
    method: 'get'
    endpoint: {
/** '/ethermint/evm/v1/base_fee' */
evmos: `/ethermint/evm/v1/base_fee`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** BaseFeeResponse returns the EIP1559 base fee. */
{
base_fee: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Code queries the balance of all coins for a single account. */
Code: {
    method: 'get'
    endpoint: {
/** '/ethermint/evm/v1/codes/{address}' */
evmos: `/ethermint/evm/v1/codes/${string}`
}
    params: {
        path: {
evmos: {
/** address is the ethereum hex address to query the code for. */
address: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryCodeResponse is the response type for the Query/Code RPC
method. */
{
/** code represents the code bytes from an ethereum address. */
code: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** CosmosAccount queries an Ethereum account's Cosmos Address. */
CosmosAccount: {
    method: 'get'
    endpoint: {
/** '/ethermint/evm/v1/cosmos_account/{address}' */
evmos: `/ethermint/evm/v1/cosmos_account/${string}`
}
    params: {
        path: {
evmos: {
/** address is the ethereum hex address to query the account for. */
address: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryCosmosAccountResponse is the response type for the Query/CosmosAccount
RPC method. */
{
/** cosmos_address is the cosmos address of the account. */
cosmos_address: string
/** sequence is the account's sequence number. */
sequence: string
/** account_number is the account numbert */
account_number: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** EstimateGas implements the `eth_estimateGas` rpc api */
EstimateGas: {
    method: 'get'
    endpoint: {
/** '/ethermint/evm/v1/estimate_gas' */
evmos: `/ethermint/evm/v1/estimate_gas`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
/** same json format as the json rpc api. */
args: string
/** the default gas cap to be used. */
gas_cap: number
}
}
        body: {
evmos: {
/** same json format as the json rpc api. */
args: string
/** the default gas cap to be used. */
gas_cap: number
}
}
    }
    response: {
        success: {
evmos: /** EstimateGasResponse defines EstimateGas response */
{
/** the estimated gas */
gas: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** EthCall implements the `eth_call` rpc api */
EthCall: {
    method: 'get'
    endpoint: {
/** '/ethermint/evm/v1/eth_call' */
evmos: `/ethermint/evm/v1/eth_call`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
/** same json format as the json rpc api. */
args: string
/** the default gas cap to be used. */
gas_cap: number
}
}
        body: {
evmos: {
/** same json format as the json rpc api. */
args: string
/** the default gas cap to be used. */
gas_cap: number
}
}
    }
    response: {
        success: {
evmos: /** MsgEthereumTxResponse defines the Msg/EthereumTx response type. */
{
/** ethereum transaction hash in hex format. This hash differs from the
Tendermint sha256 hash of the transaction bytes. See
https://github.com/tendermint/tendermint/issues/6539 for reference */
hash: string
/** logs contains the transaction hash and the proto-compatible ethereum
logs. */
logs: Array<{
/** address of the contract that generated the event */
address: string
/** list of topics provided by the contract. */
topics: Array<string>
/** supplied by the contract, usually ABI-encoded */
data: string
/** block in which the transaction was included */
block_number: string
/** hash of the transaction */
tx_hash: string
/** index of the transaction in the block */
tx_index: string
/** hash of the block in which the transaction was included */
block_hash: string
/** index of the log in the block */
index: string
/** The Removed field is true if this log was reverted due to a chain
reorganisation. You must pay attention to this field if you receive logs
through a filter query. */
removed: boolean
}>
/** returned data from evm function (result or data supplied with revert
opcode) */
ret: string
/** vm error is the error returned by vm execution */
vm_error: string
/** gas consumed by the transaction */
gas_used: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Params queries the parameters of x/evm module. */
EvmParams: {
    method: 'get'
    endpoint: {
/** '/ethermint/evm/v1/params' */
evmos: `/ethermint/evm/v1/params`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryParamsResponse defines the response type for querying x/evm parameters. */
{
/** Params defines the EVM module parameters */
params: {
/** evm denom represents the token denomination used to run the EVM state
transitions. */
evm_denom: string
/** enable create toggles state transitions that use the vm.Create function */
enable_create: boolean
/** enable call toggles state transitions that use the vm.Call function */
enable_call: boolean
/** extra eips defines the additional EIPs for the vm.Config */
extra_eips: Array<string>
/** chain config defines the EVM chain configuration parameters */
chain_config: {
/** Homestead switch block (nil no fork, 0 = already homestead) */
homestead_block: string
/** TheDAO hard-fork switch block (nil no fork) */
dao_fork_block: string
/** Whether the nodes supports or opposes the DAO hard-fork */
dao_fork_support: boolean
/** EIP150 implements the Gas price changes
(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork) */
eip150_block: string
/** EIP150 HF hash (needed for header only clients as only gas pricing changed) */
eip150_hash: string
/** EIP155Block HF block */
eip155_block: string
/** EIP158 HF block */
eip158_block: string
/** Byzantium switch block (nil no fork, 0 = already on byzantium) */
byzantium_block: string
/** Constantinople switch block (nil no fork, 0 = already activated) */
constantinople_block: string
/** Petersburg switch block (nil same as Constantinople) */
petersburg_block: string
/** Istanbul switch block (nil no fork, 0 = already on istanbul) */
istanbul_block: string
/** Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated) */
muir_glacier_block: string
/** Berlin switch block (nil = no fork, 0 = already on berlin) */
berlin_block: string
/** London switch block (nil = no fork, 0 = already on london) */
london_block: string
/** Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated) */
arrow_glacier_block: string
/** EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings) */
merge_fork_block: string
}
/** Allow unprotected transactions defines if replay-protected (i.e non EIP155 
signed) transactions can be executed on the state machine. */
allow_unprotected_txs: boolean
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Storage queries the balance of all coins for a single account. */
Storage: {
    method: 'get'
    endpoint: {
/** '/ethermint/evm/v1/storage/{address}/{key}' */
evmos: `/ethermint/evm/v1/storage/${string}/${string}`
}
    params: {
        path: {
evmos: {
/** / address is the ethereum hex address to query the storage state for. */
address: string
/** key defines the key of the storage state */
key: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryStorageResponse is the response type for the Query/Storage RPC
method. */
{
/** key defines the storage state value hash associated with the given key. */
value: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** TraceBlock implements the `debug_traceBlockByNumber` and `debug_traceBlockByHash` rpc api */
TraceBlock: {
    method: 'get'
    endpoint: {
/** '/ethermint/evm/v1/trace_block' */
evmos: `/ethermint/evm/v1/trace_block`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
/** custom javascript tracer. */
'trace_config.tracer': string
/** overrides the default timeout of 5 seconds for JavaScript-based tracing
calls. */
'trace_config.timeout': string
/** number of blocks the tracer is willing to go back. */
'trace_config.reexec': number
/** disable stack capture. */
'trace_config.disable_stack': string
/** disable storage capture. */
'trace_config.disable_storage': string
/** print output during capture end. */
'trace_config.debug': string
/** maximum length of output, but zero means unlimited. */
'trace_config.limit': number
/** Homestead switch block (nil no fork, 0 = already homestead). */
'trace_config.overrides.homestead_block': string
/** TheDAO hard-fork switch block (nil no fork). */
'trace_config.overrides.dao_fork_block': string
/** Whether the nodes supports or opposes the DAO hard-fork. */
'trace_config.overrides.dao_fork_support': string
/** EIP150 implements the Gas price changes
(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork). */
'trace_config.overrides.eip150_block': string
/** EIP150 HF hash (needed for header only clients as only gas pricing changed). */
'trace_config.overrides.eip150_hash': string
/** EIP155Block HF block. */
'trace_config.overrides.eip155_block': string
/** EIP158 HF block. */
'trace_config.overrides.eip158_block': string
/** Byzantium switch block (nil no fork, 0 = already on byzantium). */
'trace_config.overrides.byzantium_block': string
/** Constantinople switch block (nil no fork, 0 = already activated). */
'trace_config.overrides.constantinople_block': string
/** Petersburg switch block (nil same as Constantinople). */
'trace_config.overrides.petersburg_block': string
/** Istanbul switch block (nil no fork, 0 = already on istanbul). */
'trace_config.overrides.istanbul_block': string
/** Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated). */
'trace_config.overrides.muir_glacier_block': string
/** Berlin switch block (nil = no fork, 0 = already on berlin). */
'trace_config.overrides.berlin_block': string
/** London switch block (nil = no fork, 0 = already on london). */
'trace_config.overrides.london_block': string
/** Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated). */
'trace_config.overrides.arrow_glacier_block': string
/** EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings). */
'trace_config.overrides.merge_fork_block': string
/** enable memory capture. */
'trace_config.enable_memory': string
/** enable return data capture. */
'trace_config.enable_return_data': string
/** block number. */
block_number: number
/** block hex hash. */
block_hash: string
/** block time. */
block_time: string
}
}
        body: {
evmos: {
/** custom javascript tracer. */
'trace_config.tracer': string
/** overrides the default timeout of 5 seconds for JavaScript-based tracing
calls. */
'trace_config.timeout': string
/** number of blocks the tracer is willing to go back. */
'trace_config.reexec': number
/** disable stack capture. */
'trace_config.disable_stack': string
/** disable storage capture. */
'trace_config.disable_storage': string
/** print output during capture end. */
'trace_config.debug': string
/** maximum length of output, but zero means unlimited. */
'trace_config.limit': number
/** Homestead switch block (nil no fork, 0 = already homestead). */
'trace_config.overrides.homestead_block': string
/** TheDAO hard-fork switch block (nil no fork). */
'trace_config.overrides.dao_fork_block': string
/** Whether the nodes supports or opposes the DAO hard-fork. */
'trace_config.overrides.dao_fork_support': string
/** EIP150 implements the Gas price changes
(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork). */
'trace_config.overrides.eip150_block': string
/** EIP150 HF hash (needed for header only clients as only gas pricing changed). */
'trace_config.overrides.eip150_hash': string
/** EIP155Block HF block. */
'trace_config.overrides.eip155_block': string
/** EIP158 HF block. */
'trace_config.overrides.eip158_block': string
/** Byzantium switch block (nil no fork, 0 = already on byzantium). */
'trace_config.overrides.byzantium_block': string
/** Constantinople switch block (nil no fork, 0 = already activated). */
'trace_config.overrides.constantinople_block': string
/** Petersburg switch block (nil same as Constantinople). */
'trace_config.overrides.petersburg_block': string
/** Istanbul switch block (nil no fork, 0 = already on istanbul). */
'trace_config.overrides.istanbul_block': string
/** Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated). */
'trace_config.overrides.muir_glacier_block': string
/** Berlin switch block (nil = no fork, 0 = already on berlin). */
'trace_config.overrides.berlin_block': string
/** London switch block (nil = no fork, 0 = already on london). */
'trace_config.overrides.london_block': string
/** Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated). */
'trace_config.overrides.arrow_glacier_block': string
/** EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings). */
'trace_config.overrides.merge_fork_block': string
/** enable memory capture. */
'trace_config.enable_memory': string
/** enable return data capture. */
'trace_config.enable_return_data': string
/** block number. */
block_number: number
/** block hex hash. */
block_hash: string
/** block time. */
block_time: string
}
}
    }
    response: {
        success: {
evmos: /** QueryTraceBlockResponse defines TraceBlock response */
{
data: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** TraceTx implements the `debug_traceTransaction` rpc api */
TraceTx: {
    method: 'get'
    endpoint: {
/** '/ethermint/evm/v1/trace_tx' */
evmos: `/ethermint/evm/v1/trace_tx`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
/** A URL/resource name that uniquely identifies the type of the serialized
protocol buffer message. This string must contain at least
one "/" character. The last segment of the URL's path must represent
the fully qualified name of the type (as in
`path/google.protobuf.Duration`). The name should be in a canonical form
(e.g., leading "." is not accepted).

In practice, teams usually precompile into the binary all types that they
expect it to use in the context of Any. However, for URLs which use the
scheme `http`, `https`, or no scheme, one can optionally set up a type
server that maps type URLs to message definitions as follows:

* If no scheme is provided, `https` is assumed.
* An HTTP GET on the URL must yield a [google.protobuf.Type][]
  value in binary format, or produce an error.
* Applications are allowed to cache lookup results based on the
  URL, or have them precompiled into a binary to avoid any
  lookup. Therefore, binary compatibility needs to be preserved
  on changes to types. (Use versioned type names to manage
  breaking changes.)

Note: this functionality is not currently available in the official
protobuf release, and it is not used for type URLs beginning with
type.googleapis.com.

Schemes other than `http`, `https` (or the empty scheme) might be
used with implementation specific semantics. */
'msg.data.type_url': string
/** Must be a valid serialized protocol buffer of the above specified type. */
'msg.data.value': string
/** encoded storage size of the transaction. */
'msg.size': string
/** transaction hash in hex format. */
'msg.hash': string
/** ethereum signer address in hex format. This address value is checked
against the address derived from the signature (V, R, S) using the
secp256k1 elliptic curve. */
'msg.from': string
/** custom javascript tracer. */
'trace_config.tracer': string
/** overrides the default timeout of 5 seconds for JavaScript-based tracing
calls. */
'trace_config.timeout': string
/** number of blocks the tracer is willing to go back. */
'trace_config.reexec': number
/** disable stack capture. */
'trace_config.disable_stack': string
/** disable storage capture. */
'trace_config.disable_storage': string
/** print output during capture end. */
'trace_config.debug': string
/** maximum length of output, but zero means unlimited. */
'trace_config.limit': number
/** Homestead switch block (nil no fork, 0 = already homestead). */
'trace_config.overrides.homestead_block': string
/** TheDAO hard-fork switch block (nil no fork). */
'trace_config.overrides.dao_fork_block': string
/** Whether the nodes supports or opposes the DAO hard-fork. */
'trace_config.overrides.dao_fork_support': string
/** EIP150 implements the Gas price changes
(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork). */
'trace_config.overrides.eip150_block': string
/** EIP150 HF hash (needed for header only clients as only gas pricing changed). */
'trace_config.overrides.eip150_hash': string
/** EIP155Block HF block. */
'trace_config.overrides.eip155_block': string
/** EIP158 HF block. */
'trace_config.overrides.eip158_block': string
/** Byzantium switch block (nil no fork, 0 = already on byzantium). */
'trace_config.overrides.byzantium_block': string
/** Constantinople switch block (nil no fork, 0 = already activated). */
'trace_config.overrides.constantinople_block': string
/** Petersburg switch block (nil same as Constantinople). */
'trace_config.overrides.petersburg_block': string
/** Istanbul switch block (nil no fork, 0 = already on istanbul). */
'trace_config.overrides.istanbul_block': string
/** Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated). */
'trace_config.overrides.muir_glacier_block': string
/** Berlin switch block (nil = no fork, 0 = already on berlin). */
'trace_config.overrides.berlin_block': string
/** London switch block (nil = no fork, 0 = already on london). */
'trace_config.overrides.london_block': string
/** Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated). */
'trace_config.overrides.arrow_glacier_block': string
/** EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings). */
'trace_config.overrides.merge_fork_block': string
/** enable memory capture. */
'trace_config.enable_memory': string
/** enable return data capture. */
'trace_config.enable_return_data': string
/** block number of requested transaction. */
block_number: number
/** block hex hash of requested transaction. */
block_hash: string
/** block time of requested transaction. */
block_time: string
}
}
        body: {
evmos: {
/** A URL/resource name that uniquely identifies the type of the serialized
protocol buffer message. This string must contain at least
one "/" character. The last segment of the URL's path must represent
the fully qualified name of the type (as in
`path/google.protobuf.Duration`). The name should be in a canonical form
(e.g., leading "." is not accepted).

In practice, teams usually precompile into the binary all types that they
expect it to use in the context of Any. However, for URLs which use the
scheme `http`, `https`, or no scheme, one can optionally set up a type
server that maps type URLs to message definitions as follows:

* If no scheme is provided, `https` is assumed.
* An HTTP GET on the URL must yield a [google.protobuf.Type][]
  value in binary format, or produce an error.
* Applications are allowed to cache lookup results based on the
  URL, or have them precompiled into a binary to avoid any
  lookup. Therefore, binary compatibility needs to be preserved
  on changes to types. (Use versioned type names to manage
  breaking changes.)

Note: this functionality is not currently available in the official
protobuf release, and it is not used for type URLs beginning with
type.googleapis.com.

Schemes other than `http`, `https` (or the empty scheme) might be
used with implementation specific semantics. */
'msg.data.type_url': string
/** Must be a valid serialized protocol buffer of the above specified type. */
'msg.data.value': string
/** encoded storage size of the transaction. */
'msg.size': string
/** transaction hash in hex format. */
'msg.hash': string
/** ethereum signer address in hex format. This address value is checked
against the address derived from the signature (V, R, S) using the
secp256k1 elliptic curve. */
'msg.from': string
/** custom javascript tracer. */
'trace_config.tracer': string
/** overrides the default timeout of 5 seconds for JavaScript-based tracing
calls. */
'trace_config.timeout': string
/** number of blocks the tracer is willing to go back. */
'trace_config.reexec': number
/** disable stack capture. */
'trace_config.disable_stack': string
/** disable storage capture. */
'trace_config.disable_storage': string
/** print output during capture end. */
'trace_config.debug': string
/** maximum length of output, but zero means unlimited. */
'trace_config.limit': number
/** Homestead switch block (nil no fork, 0 = already homestead). */
'trace_config.overrides.homestead_block': string
/** TheDAO hard-fork switch block (nil no fork). */
'trace_config.overrides.dao_fork_block': string
/** Whether the nodes supports or opposes the DAO hard-fork. */
'trace_config.overrides.dao_fork_support': string
/** EIP150 implements the Gas price changes
(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork). */
'trace_config.overrides.eip150_block': string
/** EIP150 HF hash (needed for header only clients as only gas pricing changed). */
'trace_config.overrides.eip150_hash': string
/** EIP155Block HF block. */
'trace_config.overrides.eip155_block': string
/** EIP158 HF block. */
'trace_config.overrides.eip158_block': string
/** Byzantium switch block (nil no fork, 0 = already on byzantium). */
'trace_config.overrides.byzantium_block': string
/** Constantinople switch block (nil no fork, 0 = already activated). */
'trace_config.overrides.constantinople_block': string
/** Petersburg switch block (nil same as Constantinople). */
'trace_config.overrides.petersburg_block': string
/** Istanbul switch block (nil no fork, 0 = already on istanbul). */
'trace_config.overrides.istanbul_block': string
/** Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated). */
'trace_config.overrides.muir_glacier_block': string
/** Berlin switch block (nil = no fork, 0 = already on berlin). */
'trace_config.overrides.berlin_block': string
/** London switch block (nil = no fork, 0 = already on london). */
'trace_config.overrides.london_block': string
/** Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated). */
'trace_config.overrides.arrow_glacier_block': string
/** EIP-3675 (TheMerge) switch block (nil = no fork, 0 = already in merge proceedings). */
'trace_config.overrides.merge_fork_block': string
/** enable memory capture. */
'trace_config.enable_memory': string
/** enable return data capture. */
'trace_config.enable_return_data': string
/** block number of requested transaction. */
block_number: number
/** block hex hash of requested transaction. */
block_hash: string
/** block time of requested transaction. */
block_time: string
}
}
    }
    response: {
        success: {
evmos: /** QueryTraceTxResponse defines TraceTx response */
{
/** response serialized in bytes */
data: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ValidatorAccount queries an Ethereum account's from a validator consensus
Address. */
ValidatorAccount: {
    method: 'get'
    endpoint: {
/** '/ethermint/evm/v1/validator_account/{cons_address}' */
evmos: `/ethermint/evm/v1/validator_account/${string}`
}
    params: {
        path: {
evmos: {
/** cons_address is the validator cons address to query the account for. */
cons_address: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryValidatorAccountResponse is the response type for the
Query/ValidatorAccount RPC method. */
{
/** account_address is the cosmos address of the account in bech32 format. */
account_address: string
/** sequence is the account's sequence number. */
sequence: string
/** account_number is the account number */
account_number: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** BaseFee queries the base fee of the parent block of the current block. */
FeeMarketBaseFee: {
    method: 'get'
    endpoint: {
/** '/ethermint/feemarket/v1/base_fee' */
evmos: `/ethermint/feemarket/v1/base_fee`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** BaseFeeResponse returns the EIP1559 base fee. */
{
base_fee: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** BlockGas queries the gas used at a given block height */
BlockGas: {
    method: 'get'
    endpoint: {
/** '/ethermint/feemarket/v1/block_gas' */
evmos: `/ethermint/feemarket/v1/block_gas`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryBlockGasResponse returns block gas used for a given height. */
{
gas: string
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Params queries the parameters of x/feemarket module. */
FeeMarketParams: {
    method: 'get'
    endpoint: {
/** '/ethermint/feemarket/v1/params' */
evmos: `/ethermint/feemarket/v1/params`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryParamsResponse defines the response type for querying x/evm parameters. */
{
/** Params defines the EVM module parameters */
params: {
/** no base fee forces the EIP-1559 base fee to 0 (needed for 0 price calls) */
no_base_fee: boolean
/** base fee change denominator bounds the amount the base fee can change
between blocks. */
base_fee_change_denominator: number
/** elasticity multiplier bounds the maximum gas limit an EIP-1559 block may
have. */
elasticity_multiplier: number
/** height at which the base fee calculation is enabled. */
enable_height: string
/** base fee for EIP-1559 blocks. */
base_fee: string
/** min_gas_price defines the minimum gas price value for cosmos and eth transactions */
min_gas_price: string
/** min gas denominator bounds the minimum gasUsed to be charged
to senders based on GasLimit */
min_gas_multiplier: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** DenomHash queries a denomination hash information. */
DenomHash: {
    method: 'get'
    endpoint: {
/** '/ibc/apps/transfer/v1/denom_hashes/{trace}' */
axelar: `/ibc/apps/transfer/v1/denom_hashes/${string}`
/** '/ibc/apps/transfer/v1/denom_hashes/{trace}' */
evmos: `/ibc/apps/transfer/v1/denom_hashes/${string}`
}
    params: {
        path: {
axelar: {
/** The denomination trace ([port_id]/[channel_id])+/[denom] */
trace: string
}
evmos: {
/** The denomination trace ([port_id]/[channel_id])+/[denom] */
trace: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryDenomHashResponse is the response type for the Query/DenomHash RPC
method. */
{
/** hash (in hex format) of the denomination trace information. */
hash: string
}
evmos: /** QueryDenomHashResponse is the response type for the Query/DenomHash RPC
method. */
{
/** hash (in hex format) of the denomination trace information. */
hash: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** DenomTraces queries all denomination traces. */
DenomTraces: {
    method: 'get'
    endpoint: {
/** '/ibc/apps/transfer/v1/denom_traces' */
axelar: `/ibc/apps/transfer/v1/denom_traces`
/** '/ibc/apps/transfer/v1/denom_traces' */
evmos: `/ibc/apps/transfer/v1/denom_traces`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryConnectionsResponse is the response type for the Query/DenomTraces RPC
method. */
{
/** denom_traces returns all denominations trace information. */
denom_traces: Array<{
/** path defines the chain of port/channel identifiers used for tracing the
source of the fungible token. */
path: string
/** base denomination of the relayed fungible token. */
base_denom: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryConnectionsResponse is the response type for the Query/DenomTraces RPC
method. */
{
/** denom_traces returns all denominations trace information. */
denom_traces: Array<{
/** path defines the chain of port/channel identifiers used for tracing the
source of the fungible token. */
path: string
/** base denomination of the relayed fungible token. */
base_denom: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** DenomTrace queries a denomination trace information. */
DenomTrace: {
    method: 'get'
    endpoint: {
/** '/ibc/apps/transfer/v1/denom_traces/{hash}' */
axelar: `/ibc/apps/transfer/v1/denom_traces/${string}`
/** '/ibc/apps/transfer/v1/denom_traces/{hash}' */
evmos: `/ibc/apps/transfer/v1/denom_traces/${string}`
}
    params: {
        path: {
axelar: {
/** hash (in hex format) of the denomination trace information. */
hash: string
}
evmos: {
/** hash (in hex format) of the denomination trace information. */
hash: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC
method. */
{
/** DenomTrace contains the base denomination for ICS20 fungible tokens and the
source tracing information path. */
denom_trace: {
/** path defines the chain of port/channel identifiers used for tracing the
source of the fungible token. */
path: string
/** base denomination of the relayed fungible token. */
base_denom: string
}
}
evmos: /** QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC
method. */
{
/** DenomTrace contains the base denomination for ICS20 fungible tokens and the
source tracing information path. */
denom_trace: {
/** path defines the chain of port/channel identifiers used for tracing the
source of the fungible token. */
path: string
/** base denomination of the relayed fungible token. */
base_denom: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Params queries all parameters of the ibc-transfer module. */
TransferParams: {
    method: 'get'
    endpoint: {
/** '/ibc/apps/transfer/v1/params' */
evmos: `/ibc/apps/transfer/v1/params`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
{
/** params defines the parameters of the module. */
params: {
/** send_enabled enables or disables all cross-chain token transfers from this
chain. */
send_enabled: boolean
/** receive_enabled enables or disables all cross-chain token transfers to this
chain. */
receive_enabled: boolean
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** ClientParams queries all parameters of the ibc client. */
ClientParams: {
    method: 'get'
    endpoint: {
/** '/ibc/client/v1/params' */
axelar: `/ibc/client/v1/params`
/** '/ibc/client/v1/params' */
evmos: `/ibc/client/v1/params`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryClientParamsResponse is the response type for the Query/ClientParams RPC
method. */
{
/** params defines the parameters of the module. */
params: {
/** allowed_clients defines the list of allowed client state types. */
allowed_clients: Array<string>
}
}
evmos: /** QueryClientParamsResponse is the response type for the Query/ClientParams RPC
method. */
{
/** params defines the parameters of the module. */
params: {
/** allowed_clients defines the list of allowed client state types. */
allowed_clients: Array<string>
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ClientStates queries all the IBC light clients of a chain. */
ClientStates: {
    method: 'get'
    endpoint: {
/** '/ibc/core/client/v1/client_states' */
axelar: `/ibc/core/client/v1/client_states`
/** '/ibc/core/client/v1/client_states' */
evmos: `/ibc/core/client/v1/client_states`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryClientStatesResponse is the response type for the Query/ClientStates RPC
method. */
{
/** list of stored ClientStates of the chain. */
client_states: Array<{
/** client identifier */
client_id: string
/** client state */
client_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryClientStatesResponse is the response type for the Query/ClientStates RPC
method. */
{
/** list of stored ClientStates of the chain. */
client_states: Array<{
/** client identifier */
client_id: string
/** client state */
client_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ClientState queries an IBC light client. */
ClientState: {
    method: 'get'
    endpoint: {
/** '/ibc/core/client/v1/client_states/{client_id}' */
axelar: `/ibc/core/client/v1/client_states/${string}`
/** '/ibc/core/client/v1/client_states/{client_id}' */
evmos: `/ibc/core/client/v1/client_states/${string}`
}
    params: {
        path: {
axelar: {
/** client state unique identifier */
client_id: string
}
evmos: {
/** client state unique identifier */
client_id: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryClientStateResponse is the response type for the Query/ClientState RPC
method. Besides the client state, it includes a proof and the height from
which the proof was retrieved. */
{
/** client state associated with the request identifier */
client_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryClientStateResponse is the response type for the Query/ClientState RPC
method. Besides the client state, it includes a proof and the height from
which the proof was retrieved. */
{
/** client state associated with the request identifier */
client_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Status queries the status of an IBC client. */
ClientStatus: {
    method: 'get'
    endpoint: {
/** '/ibc/core/client/v1/client_status/{client_id}' */
axelar: `/ibc/core/client/v1/client_status/${string}`
/** '/ibc/core/client/v1/client_status/{client_id}' */
evmos: `/ibc/core/client/v1/client_status/${string}`
}
    params: {
        path: {
axelar: {
/** client unique identifier */
client_id: string
}
evmos: {
/** client unique identifier */
client_id: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryClientStatusResponse is the response type for the Query/ClientStatus RPC
method. It returns the current status of the IBC client. */
{
status: string
}
evmos: /** QueryClientStatusResponse is the response type for the Query/ClientStatus RPC
method. It returns the current status of the IBC client. */
{
status: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ConsensusStates queries all the consensus state associated with a given
client. */
ConsensusStates: {
    method: 'get'
    endpoint: {
/** '/ibc/core/client/v1/consensus_states/{client_id}' */
axelar: `/ibc/core/client/v1/consensus_states/${string}`
/** '/ibc/core/client/v1/consensus_states/{client_id}' */
evmos: `/ibc/core/client/v1/consensus_states/${string}`
}
    params: {
        path: {
axelar: {
/** client identifier */
client_id: string
}
evmos: {
/** client identifier */
client_id: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryConsensusStatesResponse is the response type for the
Query/ConsensusStates RPC method */
{
/** consensus states associated with the identifier */
consensus_states: Array<{
/** consensus state height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
/** consensus state */
consensus_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryConsensusStatesResponse is the response type for the
Query/ConsensusStates RPC method */
{
/** consensus states associated with the identifier */
consensus_states: Array<{
/** consensus state height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
/** consensus state */
consensus_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ConsensusState queries a consensus state associated with a client state at
a given height. */
ConsensusState: {
    method: 'get'
    endpoint: {
/** '/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}' */
axelar: `/ibc/core/client/v1/consensus_states/${string}/revision/${number}/height/${number}`
/** '/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}' */
evmos: `/ibc/core/client/v1/consensus_states/${string}/revision/${number}/height/${number}`
}
    params: {
        path: {
axelar: {
/** client identifier */
client_id: string
/** consensus state revision number */
revision_number: number
/** consensus state revision height */
revision_height: number
}
evmos: {
/** client identifier */
client_id: string
/** consensus state revision number */
revision_number: number
/** consensus state revision height */
revision_height: number
}
}
    
        query: {
axelar: {
/** latest_height overrrides the height field and queries the latest stored
ConsensusState. */
latest_height: string
}
evmos: {
/** latest_height overrrides the height field and queries the latest stored
ConsensusState. */
latest_height: string
}
}
        body: {
axelar: {
/** latest_height overrrides the height field and queries the latest stored
ConsensusState. */
latest_height: string
}
evmos: {
/** latest_height overrrides the height field and queries the latest stored
ConsensusState. */
latest_height: string
}
}
    }
    response: {
        success: {
axelar: /** QueryConsensusStateResponse is the response type for the Query/ConsensusState
RPC method */
{
/** consensus state associated with the client identifier at the given height */
consensus_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryConsensusStateResponse is the response type for the Query/ConsensusState
RPC method */
{
/** consensus state associated with the client identifier at the given height */
consensus_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** UpgradedClientState queries an Upgraded IBC light client. */
UpgradedClientState: {
    method: 'get'
    endpoint: {
/** '/ibc/core/client/v1/upgraded_client_states' */
axelar: `/ibc/core/client/v1/upgraded_client_states`
/** '/ibc/core/client/v1/upgraded_client_states' */
evmos: `/ibc/core/client/v1/upgraded_client_states`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryUpgradedClientStateResponse is the response type for the
Query/UpgradedClientState RPC method. */
{
/** client state associated with the request identifier */
upgraded_client_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
evmos: /** QueryUpgradedClientStateResponse is the response type for the
Query/UpgradedClientState RPC method. */
{
/** client state associated with the request identifier */
upgraded_client_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** UpgradedConsensusState queries an Upgraded IBC consensus state. */
UpgradedConsensusState: {
    method: 'get'
    endpoint: {
/** '/ibc/core/client/v1/upgraded_consensus_states' */
axelar: `/ibc/core/client/v1/upgraded_consensus_states`
/** '/ibc/core/client/v1/upgraded_consensus_states' */
evmos: `/ibc/core/client/v1/upgraded_consensus_states`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryUpgradedConsensusStateResponse is the response type for the
Query/UpgradedConsensusState RPC method. */
{
/** Consensus state associated with the request identifier */
upgraded_consensus_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
evmos: /** QueryUpgradedConsensusStateResponse is the response type for the
Query/UpgradedConsensusState RPC method. */
{
/** Consensus state associated with the request identifier */
upgraded_consensus_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ClientConnections queries the connection paths associated with a client
state. */
ClientConnections: {
    method: 'get'
    endpoint: {
/** '/ibc/core/connection/v1/client_connections/{client_id}' */
axelar: `/ibc/core/connection/v1/client_connections/${string}`
/** '/ibc/core/connection/v1/client_connections/{client_id}' */
evmos: `/ibc/core/connection/v1/client_connections/${string}`
}
    params: {
        path: {
axelar: {
/** client identifier associated with a connection */
client_id: string
}
evmos: {
/** client identifier associated with a connection */
client_id: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryClientConnectionsResponse is the response type for the
Query/ClientConnections RPC method */
{
/** slice of all the connection paths associated with a client. */
connection_paths: Array<string>
/** merkle proof of existence */
proof: string
/** height at which the proof was generated */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryClientConnectionsResponse is the response type for the
Query/ClientConnections RPC method */
{
/** slice of all the connection paths associated with a client. */
connection_paths: Array<string>
/** merkle proof of existence */
proof: string
/** height at which the proof was generated */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Connections queries all the IBC connections of a chain. */
Connections: {
    method: 'get'
    endpoint: {
/** '/ibc/core/connection/v1/connections' */
axelar: `/ibc/core/connection/v1/connections`
/** '/ibc/core/connection/v1/connections' */
evmos: `/ibc/core/connection/v1/connections`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryConnectionsResponse is the response type for the Query/Connections RPC
method. */
{
/** list of stored connections of the chain. */
connections: Array<{
/** connection identifier. */
id: string
/** client associated with this connection. */
client_id: string
/** IBC version which can be utilised to determine encodings or protocols for
channels or packets utilising this connection */
versions: Array<{
/** unique version identifier */
identifier: string
/** list of features compatible with the specified identifier */
features: Array<string>
}>
/** current state of the connection end. */
state: string
/** counterparty chain associated with this connection. */
counterparty: {
/** identifies the client on the counterparty chain associated with a given
connection. */
client_id: string
/** identifies the connection end on the counterparty chain associated with a
given connection. */
connection_id: string
/** MerklePrefix is merkle path prefixed to the key.
The constructed key from the Path and the key will be append(Path.KeyPath,
append(Path.KeyPrefix, key...)) */
prefix: {
key_prefix: string
}
}
/** delay period associated with this connection. */
delay_period: string
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryConnectionsResponse is the response type for the Query/Connections RPC
method. */
{
/** list of stored connections of the chain. */
connections: Array<{
/** connection identifier. */
id: string
/** client associated with this connection. */
client_id: string
/** IBC version which can be utilised to determine encodings or protocols for
channels or packets utilising this connection */
versions: Array<{
/** unique version identifier */
identifier: string
/** list of features compatible with the specified identifier */
features: Array<string>
}>
/** current state of the connection end. */
state: string
/** counterparty chain associated with this connection. */
counterparty: {
/** identifies the client on the counterparty chain associated with a given
connection. */
client_id: string
/** identifies the connection end on the counterparty chain associated with a
given connection. */
connection_id: string
/** MerklePrefix is merkle path prefixed to the key.
The constructed key from the Path and the key will be append(Path.KeyPath,
append(Path.KeyPrefix, key...)) */
prefix: {
key_prefix: string
}
}
/** delay period associated with this connection. */
delay_period: string
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Connection queries an IBC connection end. */
Connection: {
    method: 'get'
    endpoint: {
/** '/ibc/core/connection/v1/connections/{connection_id}' */
axelar: `/ibc/core/connection/v1/connections/${string}`
/** '/ibc/core/connection/v1/connections/{connection_id}' */
evmos: `/ibc/core/connection/v1/connections/${string}`
}
    params: {
        path: {
axelar: {
/** connection unique identifier */
connection_id: string
}
evmos: {
/** connection unique identifier */
connection_id: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryConnectionResponse is the response type for the Query/Connection RPC
method. Besides the connection end, it includes a proof and the height from
which the proof was retrieved. */
{
/** connection associated with the request identifier */
connection: {
/** client associated with this connection. */
client_id: string
/** IBC version which can be utilised to determine encodings or protocols for
channels or packets utilising this connection. */
versions: Array<{
/** unique version identifier */
identifier: string
/** list of features compatible with the specified identifier */
features: Array<string>
}>
/** current state of the connection end. */
state: string
/** counterparty chain associated with this connection. */
counterparty: {
/** identifies the client on the counterparty chain associated with a given
connection. */
client_id: string
/** identifies the connection end on the counterparty chain associated with a
given connection. */
connection_id: string
/** MerklePrefix is merkle path prefixed to the key.
The constructed key from the Path and the key will be append(Path.KeyPath,
append(Path.KeyPrefix, key...)) */
prefix: {
key_prefix: string
}
}
/** delay period that must pass before a consensus state can be used for
packet-verification NOTE: delay period logic is only implemented by some
clients. */
delay_period: string
}
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryConnectionResponse is the response type for the Query/Connection RPC
method. Besides the connection end, it includes a proof and the height from
which the proof was retrieved. */
{
/** connection associated with the request identifier */
connection: {
/** client associated with this connection. */
client_id: string
/** IBC version which can be utilised to determine encodings or protocols for
channels or packets utilising this connection. */
versions: Array<{
/** unique version identifier */
identifier: string
/** list of features compatible with the specified identifier */
features: Array<string>
}>
/** current state of the connection end. */
state: string
/** counterparty chain associated with this connection. */
counterparty: {
/** identifies the client on the counterparty chain associated with a given
connection. */
client_id: string
/** identifies the connection end on the counterparty chain associated with a
given connection. */
connection_id: string
/** MerklePrefix is merkle path prefixed to the key.
The constructed key from the Path and the key will be append(Path.KeyPath,
append(Path.KeyPrefix, key...)) */
prefix: {
key_prefix: string
}
}
/** delay period that must pass before a consensus state can be used for
packet-verification NOTE: delay period logic is only implemented by some
clients. */
delay_period: string
}
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ConnectionClientState queries the client state associated with the
connection. */
ConnectionClientState: {
    method: 'get'
    endpoint: {
/** '/ibc/core/connection/v1/connections/{connection_id}/client_state' */
axelar: `/ibc/core/connection/v1/connections/${string}/client_state`
/** '/ibc/core/connection/v1/connections/{connection_id}/client_state' */
evmos: `/ibc/core/connection/v1/connections/${string}/client_state`
}
    params: {
        path: {
axelar: {
/** connection identifier */
connection_id: string
}
evmos: {
/** connection identifier */
connection_id: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryConnectionClientStateResponse is the response type for the
Query/ConnectionClientState RPC method */
{
/** client state associated with the channel */
identified_client_state: {
/** client identifier */
client_id: string
/** client state */
client_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryConnectionClientStateResponse is the response type for the
Query/ConnectionClientState RPC method */
{
/** client state associated with the channel */
identified_client_state: {
/** client identifier */
client_id: string
/** client state */
client_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ConnectionConsensusState queries the consensus state associated with the
connection. */
ConnectionConsensusState: {
    method: 'get'
    endpoint: {
/** '/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}' */
axelar: `/ibc/core/connection/v1/connections/${string}/consensus_state/revision/${number}/height/${number}`
/** '/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}' */
evmos: `/ibc/core/connection/v1/connections/${string}/consensus_state/revision/${number}/height/${number}`
}
    params: {
        path: {
axelar: {
/** connection identifier */
connection_id: string
revision_number: number
revision_height: number
}
evmos: {
/** connection identifier */
connection_id: string
revision_number: number
revision_height: number
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryConnectionConsensusStateResponse is the response type for the
Query/ConnectionConsensusState RPC method */
{
/** consensus state associated with the channel */
consensus_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** client ID associated with the consensus state */
client_id: string
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryConnectionConsensusStateResponse is the response type for the
Query/ConnectionConsensusState RPC method */
{
/** consensus state associated with the channel */
consensus_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** client ID associated with the consensus state */
client_id: string
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Channels queries all the IBC channels of a chain. */
Channels: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/channels' */
axelar: `/ibc/core/channel/v1/channels`
/** '/ibc/core/channel/v1/channels' */
evmos: `/ibc/core/channel/v1/channels`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryChannelsResponse is the response type for the Query/Channels RPC method. */
{
/** list of stored channels of the chain. */
channels: Array<{
/** current state of the channel end */
state: string
/** whether the channel is ordered or unordered */
ordering: string
/** counterparty channel end */
counterparty: {
/** port on the counterparty chain which owns the other end of the channel. */
port_id: string
/** channel end on the counterparty chain */
channel_id: string
}
/** list of connection identifiers, in order, along which packets sent on
this channel will travel */
connection_hops: Array<string>
/** opaque channel version, which is agreed upon during the handshake */
version: string
/** port identifier */
port_id: string
/** channel identifier */
channel_id: string
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryChannelsResponse is the response type for the Query/Channels RPC method. */
{
/** list of stored channels of the chain. */
channels: Array<{
/** current state of the channel end */
state: string
/** whether the channel is ordered or unordered */
ordering: string
/** counterparty channel end */
counterparty: {
/** port on the counterparty chain which owns the other end of the channel. */
port_id: string
/** channel end on the counterparty chain */
channel_id: string
}
/** list of connection identifiers, in order, along which packets sent on
this channel will travel */
connection_hops: Array<string>
/** opaque channel version, which is agreed upon during the handshake */
version: string
/** port identifier */
port_id: string
/** channel identifier */
channel_id: string
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Channel queries an IBC Channel. */
Channel: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}' */
axelar: `/ibc/core/channel/v1/channels/${string}/ports/${string}`
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}' */
evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}`
}
    params: {
        path: {
axelar: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
}
evmos: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryChannelResponse is the response type for the Query/Channel RPC method.
Besides the Channel end, it includes a proof and the height from which the
proof was retrieved. */
{
/** channel associated with the request identifiers */
channel: {
/** current state of the channel end */
state: string
/** whether the channel is ordered or unordered */
ordering: string
/** counterparty channel end */
counterparty: {
/** port on the counterparty chain which owns the other end of the channel. */
port_id: string
/** channel end on the counterparty chain */
channel_id: string
}
/** list of connection identifiers, in order, along which packets sent on
this channel will travel */
connection_hops: Array<string>
/** opaque channel version, which is agreed upon during the handshake */
version: string
}
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryChannelResponse is the response type for the Query/Channel RPC method.
Besides the Channel end, it includes a proof and the height from which the
proof was retrieved. */
{
/** channel associated with the request identifiers */
channel: {
/** current state of the channel end */
state: string
/** whether the channel is ordered or unordered */
ordering: string
/** counterparty channel end */
counterparty: {
/** port on the counterparty chain which owns the other end of the channel. */
port_id: string
/** channel end on the counterparty chain */
channel_id: string
}
/** list of connection identifiers, in order, along which packets sent on
this channel will travel */
connection_hops: Array<string>
/** opaque channel version, which is agreed upon during the handshake */
version: string
}
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ChannelClientState queries for the client state for the channel associated
with the provided channel identifiers. */
ChannelClientState: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state' */
axelar: `/ibc/core/channel/v1/channels/${string}/ports/${string}/client_state`
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state' */
evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/client_state`
}
    params: {
        path: {
axelar: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
}
evmos: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryChannelClientStateResponse is the Response type for the
Query/QueryChannelClientState RPC method */
{
/** client state associated with the channel */
identified_client_state: {
/** client identifier */
client_id: string
/** client state */
client_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryChannelClientStateResponse is the Response type for the
Query/QueryChannelClientState RPC method */
{
/** client state associated with the channel */
identified_client_state: {
/** client identifier */
client_id: string
/** client state */
client_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ChannelConsensusState queries for the consensus state for the channel
associated with the provided channel identifiers. */
ChannelConsensusState: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}' */
axelar: `/ibc/core/channel/v1/channels/${string}/ports/${string}/consensus_state/revision/${number}/height/${number}`
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}' */
evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/consensus_state/revision/${number}/height/${number}`
}
    params: {
        path: {
axelar: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
/** revision number of the consensus state */
revision_number: number
/** revision height of the consensus state */
revision_height: number
}
evmos: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
/** revision number of the consensus state */
revision_number: number
/** revision height of the consensus state */
revision_height: number
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryChannelClientStateResponse is the Response type for the
Query/QueryChannelClientState RPC method */
{
/** consensus state associated with the channel */
consensus_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** client ID associated with the consensus state */
client_id: string
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryChannelClientStateResponse is the Response type for the
Query/QueryChannelClientState RPC method */
{
/** consensus state associated with the channel */
consensus_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** client ID associated with the consensus state */
client_id: string
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** NextSequenceReceive returns the next receive sequence for a given channel. */
NextSequenceReceive: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence' */
axelar: `/ibc/core/channel/v1/channels/${string}/ports/${string}/next_sequence`
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence' */
evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/next_sequence`
}
    params: {
        path: {
axelar: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
}
evmos: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QuerySequenceResponse is the request type for the
Query/QueryNextSequenceReceiveResponse RPC method */
{
/** next sequence receive number */
next_sequence_receive: string
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QuerySequenceResponse is the request type for the
Query/QueryNextSequenceReceiveResponse RPC method */
{
/** next sequence receive number */
next_sequence_receive: string
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** PacketAcknowledgements returns all the packet acknowledgements associated
with a channel. */
PacketAcknowledgements: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements' */
axelar: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_acknowledgements`
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements' */
evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_acknowledgements`
}
    params: {
        path: {
axelar: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
}
evmos: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
/** list of packet sequences. */
packet_commitment_sequences: string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
/** list of packet sequences. */
packet_commitment_sequences: string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
/** list of packet sequences. */
packet_commitment_sequences: string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
/** list of packet sequences. */
packet_commitment_sequences: string
}
}
    }
    response: {
        success: {
axelar: /** QueryPacketAcknowledgemetsResponse is the request type for the
Query/QueryPacketAcknowledgements RPC method */
{
acknowledgements: Array<{
/** channel port identifier. */
port_id: string
/** channel unique identifier. */
channel_id: string
/** packet sequence. */
sequence: string
/** embedded data that represents packet state. */
data: string
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryPacketAcknowledgemetsResponse is the request type for the
Query/QueryPacketAcknowledgements RPC method */
{
acknowledgements: Array<{
/** channel port identifier. */
port_id: string
/** channel unique identifier. */
channel_id: string
/** packet sequence. */
sequence: string
/** embedded data that represents packet state. */
data: string
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** PacketAcknowledgement queries a stored packet acknowledgement hash. */
PacketAcknowledgement: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}' */
axelar: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_acks/${number}`
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}' */
evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_acks/${number}`
}
    params: {
        path: {
axelar: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
/** packet sequence */
sequence: number
}
evmos: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
/** packet sequence */
sequence: number
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryPacketAcknowledgementResponse defines the client query response for a
packet which also includes a proof and the height from which the
proof was retrieved */
{
/** packet associated with the request fields */
acknowledgement: string
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryPacketAcknowledgementResponse defines the client query response for a
packet which also includes a proof and the height from which the
proof was retrieved */
{
/** packet associated with the request fields */
acknowledgement: string
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** PacketCommitments returns all the packet commitments hashes associated
with a channel. */
PacketCommitments: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments' */
axelar: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_commitments`
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments' */
evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_commitments`
}
    params: {
        path: {
axelar: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
}
evmos: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryPacketCommitmentsResponse is the request type for the
Query/QueryPacketCommitments RPC method */
{
commitments: Array<{
/** channel port identifier. */
port_id: string
/** channel unique identifier. */
channel_id: string
/** packet sequence. */
sequence: string
/** embedded data that represents packet state. */
data: string
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryPacketCommitmentsResponse is the request type for the
Query/QueryPacketCommitments RPC method */
{
commitments: Array<{
/** channel port identifier. */
port_id: string
/** channel unique identifier. */
channel_id: string
/** packet sequence. */
sequence: string
/** embedded data that represents packet state. */
data: string
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** UnreceivedAcks returns all the unreceived IBC acknowledgements associated
with a channel and sequences. */
UnreceivedAcks: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks' */
axelar: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_commitments/${string}/unreceived_acks`
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks' */
evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_commitments/${string}/unreceived_acks`
}
    params: {
        path: {
axelar: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
/** list of acknowledgement sequences */
packet_ack_sequences: string
}
evmos: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
/** list of acknowledgement sequences */
packet_ack_sequences: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryUnreceivedAcksResponse is the response type for the
Query/UnreceivedAcks RPC method */
{
/** list of unreceived acknowledgement sequences */
sequences: Array<string>
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryUnreceivedAcksResponse is the response type for the
Query/UnreceivedAcks RPC method */
{
/** list of unreceived acknowledgement sequences */
sequences: Array<string>
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** UnreceivedPackets returns all the unreceived IBC packets associated with a
channel and sequences. */
UnreceivedPackets: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets' */
axelar: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_commitments/${string}/unreceived_packets`
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets' */
evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_commitments/${string}/unreceived_packets`
}
    params: {
        path: {
axelar: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
/** list of packet sequences */
packet_commitment_sequences: string
}
evmos: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
/** list of packet sequences */
packet_commitment_sequences: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryUnreceivedPacketsResponse is the response type for the
Query/UnreceivedPacketCommitments RPC method */
{
/** list of unreceived packet sequences */
sequences: Array<string>
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryUnreceivedPacketsResponse is the response type for the
Query/UnreceivedPacketCommitments RPC method */
{
/** list of unreceived packet sequences */
sequences: Array<string>
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** PacketCommitment queries a stored packet commitment hash. */
PacketCommitment: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}' */
axelar: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_commitments/${number}`
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}' */
evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_commitments/${number}`
}
    params: {
        path: {
axelar: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
/** packet sequence */
sequence: number
}
evmos: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
/** packet sequence */
sequence: number
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryPacketCommitmentResponse defines the client query response for a packet
which also includes a proof and the height from which the proof was
retrieved */
{
/** packet associated with the request fields */
commitment: string
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryPacketCommitmentResponse defines the client query response for a packet
which also includes a proof and the height from which the proof was
retrieved */
{
/** packet associated with the request fields */
commitment: string
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** PacketReceipt queries if a given packet sequence has been received on the
queried chain */
PacketReceipt: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}' */
axelar: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_receipts/${number}`
/** '/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}' */
evmos: `/ibc/core/channel/v1/channels/${string}/ports/${string}/packet_receipts/${number}`
}
    params: {
        path: {
axelar: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
/** packet sequence */
sequence: number
}
evmos: {
/** channel unique identifier */
channel_id: string
/** port unique identifier */
port_id: string
/** packet sequence */
sequence: number
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryPacketReceiptResponse defines the client query response for a packet
receipt which also includes a proof, and the height from which the proof was
retrieved */
{
/** success flag for if receipt exists */
received: boolean
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryPacketReceiptResponse defines the client query response for a packet
receipt which also includes a proof, and the height from which the proof was
retrieved */
{
/** success flag for if receipt exists */
received: boolean
/** merkle proof of existence */
proof: string
/** height at which the proof was retrieved */
proof_height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ConnectionChannels queries all the channels associated with a connection
end. */
ConnectionChannels: {
    method: 'get'
    endpoint: {
/** '/ibc/core/channel/v1/connections/{connection}/channels' */
axelar: `/ibc/core/channel/v1/connections/${string}/channels`
/** '/ibc/core/channel/v1/connections/{connection}/channels' */
evmos: `/ibc/core/channel/v1/connections/${string}/channels`
}
    params: {
        path: {
axelar: {
/** connection unique identifier */
connection: string
}
evmos: {
/** connection unique identifier */
connection: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryConnectionChannelsResponse is the Response type for the
Query/QueryConnectionChannels RPC method */
{
/** list of channels associated with a connection. */
channels: Array<{
/** current state of the channel end */
state: string
/** whether the channel is ordered or unordered */
ordering: string
/** counterparty channel end */
counterparty: {
/** port on the counterparty chain which owns the other end of the channel. */
port_id: string
/** channel end on the counterparty chain */
channel_id: string
}
/** list of connection identifiers, in order, along which packets sent on
this channel will travel */
connection_hops: Array<string>
/** opaque channel version, which is agreed upon during the handshake */
version: string
/** port identifier */
port_id: string
/** channel identifier */
channel_id: string
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
evmos: /** QueryConnectionChannelsResponse is the Response type for the
Query/QueryConnectionChannels RPC method */
{
/** list of channels associated with a connection. */
channels: Array<{
/** current state of the channel end */
state: string
/** whether the channel is ordered or unordered */
ordering: string
/** counterparty channel end */
counterparty: {
/** port on the counterparty chain which owns the other end of the channel. */
port_id: string
/** channel end on the counterparty chain */
channel_id: string
}
/** list of connection identifiers, in order, along which packets sent on
this channel will travel */
connection_hops: Array<string>
/** opaque channel version, which is agreed upon during the handshake */
version: string
/** port identifier */
port_id: string
/** channel identifier */
channel_id: string
}>
/** pagination response */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
/** query block height */
height: {
/** the revision that the client is currently on */
revision_number: string
/** the height within the given revision */
revision_height: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Accounts returns all the existing accounts */
Accounts: {
    method: 'get'
    endpoint: {
/** '/cosmos/auth/v1beta1/accounts' */
axelar: `/cosmos/auth/v1beta1/accounts`
/** '/cosmos/auth/v1beta1/accounts' */
evmos: `/cosmos/auth/v1beta1/accounts`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryAccountsResponse is the response type for the Query/Accounts RPC method.

Since: cosmos-sdk 0.43 */
{
/** accounts are the existing accounts */
accounts: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryAccountsResponse is the response type for the Query/Accounts RPC method.

Since: cosmos-sdk 0.43 */
{
/** accounts are the existing accounts */
accounts: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Account returns account details based on address. */
AuthAccount: {
    method: 'get'
    endpoint: {
/** '/cosmos/auth/v1beta1/accounts/{address}' */
evmos: `/cosmos/auth/v1beta1/accounts/${string}`
}
    params: {
        path: {
evmos: {
/** address defines the address to query for. */
address: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryAccountResponse is the response type for the Query/Account RPC method. */
{
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
account: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Params queries all parameters. */
AuthParams: {
    method: 'get'
    endpoint: {
/** '/cosmos/auth/v1beta1/params' */
axelar: `/cosmos/auth/v1beta1/params`
/** '/cosmos/auth/v1beta1/params' */
evmos: `/cosmos/auth/v1beta1/params`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
{
/** params defines the parameters of the module. */
params: {
max_memo_characters: string
tx_sig_limit: string
tx_size_cost_per_byte: string
sig_verify_cost_ed25519: string
sig_verify_cost_secp256k1: string
}
}
evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
{
/** params defines the parameters of the module. */
params: {
max_memo_characters: string
tx_sig_limit: string
tx_size_cost_per_byte: string
sig_verify_cost_ed25519: string
sig_verify_cost_secp256k1: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Returns list of `Authorization`, granted to the grantee by the granter. */
Grants: {
    method: 'get'
    endpoint: {
/** '/cosmos/authz/v1beta1/grants' */
evmos: `/cosmos/authz/v1beta1/grants`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
granter: string
grantee: string
/** Optional, msg_type_url, when set, will query only grants matching given msg type. */
msg_type_url: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
evmos: {
granter: string
grantee: string
/** Optional, msg_type_url, when set, will query only grants matching given msg type. */
msg_type_url: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
evmos: /** QueryGrantsResponse is the response type for the Query/Authorizations RPC method. */
{
/** authorizations is a list of grants granted for grantee by granter. */
grants: Array<{
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
authorization: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
expiration: string
}>
/** pagination defines an pagination for the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** GranteeGrants returns a list of `GrantAuthorization` by grantee. */
GranteeGrants: {
    method: 'get'
    endpoint: {
/** '/cosmos/authz/v1beta1/grants/grantee/{grantee}' */
evmos: `/cosmos/authz/v1beta1/grants/grantee/${string}`
}
    params: {
        path: {
evmos: {
grantee: string
}
}
    
        query: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
evmos: /** QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method. */
{
/** grants is a list of grants granted to the grantee. */
grants: Array<{
granter: string
grantee: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
authorization: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
expiration: string
}>
/** pagination defines an pagination for the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** GranterGrants returns list of `GrantAuthorization`, granted by granter. */
GranterGrants: {
    method: 'get'
    endpoint: {
/** '/cosmos/authz/v1beta1/grants/granter/{granter}' */
evmos: `/cosmos/authz/v1beta1/grants/granter/${string}`
}
    params: {
        path: {
evmos: {
granter: string
}
}
    
        query: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
evmos: /** QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method. */
{
/** grants is a list of grants granted by the granter. */
grants: Array<{
granter: string
grantee: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
authorization: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
expiration: string
}>
/** pagination defines an pagination for the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** AllBalances queries the balance of all coins for a single account. */
AllBalances: {
    method: 'get'
    endpoint: {
/** '/cosmos/bank/v1beta1/balances/{address}' */
axelar: `/cosmos/bank/v1beta1/balances/${string}`
/** '/cosmos/bank/v1beta1/balances/{address}' */
evmos: `/cosmos/bank/v1beta1/balances/${string}`
}
    params: {
        path: {
axelar: {
/** address is the address to query balances for. */
address: string
}
evmos: {
/** address is the address to query balances for. */
address: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
method. */
{
/** balances is the balances of all the coins. */
balances: Array<{
denom: string
amount: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryAllBalancesResponse is the response type for the Query/AllBalances RPC
method. */
{
/** balances is the balances of all the coins. */
balances: Array<{
denom: string
amount: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Balance queries the balance of a single coin for a single account. */
BankBalance: {
    method: 'get'
    endpoint: {
/** '/cosmos/bank/v1beta1/balances/{address}/by_denom' */
evmos: `/cosmos/bank/v1beta1/balances/${string}/by_denom`
}
    params: {
        path: {
evmos: {
/** address is the address to query balances for. */
address: string
}
}
    
        query: {
evmos: {
/** denom is the coin denom to query balances for. */
denom: string
}
}
        body: {
evmos: {
/** denom is the coin denom to query balances for. */
denom: string
}
}
    }
    response: {
        success: {
evmos: /** QueryBalanceResponse is the response type for the Query/Balance RPC method. */
{
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
balance: {
denom: string
amount: string
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** DenomsMetadata queries the client metadata for all registered coin denominations. */
DenomsMetadata: {
    method: 'get'
    endpoint: {
/** '/cosmos/bank/v1beta1/denoms_metadata' */
axelar: `/cosmos/bank/v1beta1/denoms_metadata`
/** '/cosmos/bank/v1beta1/denoms_metadata' */
evmos: `/cosmos/bank/v1beta1/denoms_metadata`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
method. */
{
/** metadata provides the client information for all the registered tokens. */
metadatas: Array<{
description: string
/** denom_units represents the list of DenomUnit's for a given coin */
denom_units: Array<{
/** denom represents the string name of the given denom unit (e.g uatom). */
denom: string
/** exponent represents power of 10 exponent that one must
raise the base_denom to in order to equal the given DenomUnit's denom
1 denom = 1^exponent base_denom
(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
exponent = 6, thus: 1 atom = 10^6 uatom). */
exponent: number
/** aliases is a list of string aliases for the given denom */
aliases: Array<string>
}>
/** base represents the base denom (should be the DenomUnit with exponent = 0). */
base: string
/** display indicates the suggested denom that should be
displayed in clients. */
display: string
/** name defines the name of the token (eg: Cosmos Atom) */
name: string
/** symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
be the same as the display.

Since: cosmos-sdk 0.43 */
symbol: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC
method. */
{
/** metadata provides the client information for all the registered tokens. */
metadatas: Array<{
description: string
/** denom_units represents the list of DenomUnit's for a given coin */
denom_units: Array<{
/** denom represents the string name of the given denom unit (e.g uatom). */
denom: string
/** exponent represents power of 10 exponent that one must
raise the base_denom to in order to equal the given DenomUnit's denom
1 denom = 1^exponent base_denom
(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
exponent = 6, thus: 1 atom = 10^6 uatom). */
exponent: number
/** aliases is a list of string aliases for the given denom */
aliases: Array<string>
}>
/** base represents the base denom (should be the DenomUnit with exponent = 0). */
base: string
/** display indicates the suggested denom that should be
displayed in clients. */
display: string
/** name defines the name of the token (eg: Cosmos Atom) */
name: string
/** symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
be the same as the display.

Since: cosmos-sdk 0.43 */
symbol: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** DenomsMetadata queries the client metadata of a given coin denomination. */
DenomMetadata: {
    method: 'get'
    endpoint: {
/** '/cosmos/bank/v1beta1/denoms_metadata/{denom}' */
axelar: `/cosmos/bank/v1beta1/denoms_metadata/${string}`
/** '/cosmos/bank/v1beta1/denoms_metadata/{denom}' */
evmos: `/cosmos/bank/v1beta1/denoms_metadata/${string}`
}
    params: {
        path: {
axelar: {
/** denom is the coin denom to query the metadata for. */
denom: string
}
evmos: {
/** denom is the coin denom to query the metadata for. */
denom: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
method. */
{
/** Metadata represents a struct that describes
a basic token. */
metadata: {
description: string
/** denom_units represents the list of DenomUnit's for a given coin */
denom_units: Array<{
/** denom represents the string name of the given denom unit (e.g uatom). */
denom: string
/** exponent represents power of 10 exponent that one must
raise the base_denom to in order to equal the given DenomUnit's denom
1 denom = 1^exponent base_denom
(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
exponent = 6, thus: 1 atom = 10^6 uatom). */
exponent: number
/** aliases is a list of string aliases for the given denom */
aliases: Array<string>
}>
/** base represents the base denom (should be the DenomUnit with exponent = 0). */
base: string
/** display indicates the suggested denom that should be
displayed in clients. */
display: string
/** name defines the name of the token (eg: Cosmos Atom) */
name: string
/** symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
be the same as the display.

Since: cosmos-sdk 0.43 */
symbol: string
}
}
evmos: /** QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC
method. */
{
/** Metadata represents a struct that describes
a basic token. */
metadata: {
description: string
/** denom_units represents the list of DenomUnit's for a given coin */
denom_units: Array<{
/** denom represents the string name of the given denom unit (e.g uatom). */
denom: string
/** exponent represents power of 10 exponent that one must
raise the base_denom to in order to equal the given DenomUnit's denom
1 denom = 1^exponent base_denom
(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with
exponent = 6, thus: 1 atom = 10^6 uatom). */
exponent: number
/** aliases is a list of string aliases for the given denom */
aliases: Array<string>
}>
/** base represents the base denom (should be the DenomUnit with exponent = 0). */
base: string
/** display indicates the suggested denom that should be
displayed in clients. */
display: string
/** name defines the name of the token (eg: Cosmos Atom) */
name: string
/** symbol is the token symbol usually shown on exchanges (eg: ATOM). This can
be the same as the display.

Since: cosmos-sdk 0.43 */
symbol: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Params queries the parameters of x/bank module. */
BankParams: {
    method: 'get'
    endpoint: {
/** '/cosmos/bank/v1beta1/params' */
axelar: `/cosmos/bank/v1beta1/params`
/** '/cosmos/bank/v1beta1/params' */
evmos: `/cosmos/bank/v1beta1/params`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryParamsResponse defines the response type for querying x/bank parameters. */
{
/** Params defines the parameters for the bank module. */
params: {
send_enabled: Array<{
denom: string
enabled: boolean
}>
default_send_enabled: boolean
}
}
evmos: /** QueryParamsResponse defines the response type for querying x/bank parameters. */
{
/** Params defines the parameters for the bank module. */
params: {
send_enabled: Array<{
denom: string
enabled: boolean
}>
default_send_enabled: boolean
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** SpendableBalances queries the spenable balance of all coins for a single
account. */
SpendableBalances: {
    method: 'get'
    endpoint: {
/** '/cosmos/bank/v1beta1/spendable_balances/{address}' */
axelar: `/cosmos/bank/v1beta1/spendable_balances/${string}`
/** '/cosmos/bank/v1beta1/spendable_balances/{address}' */
evmos: `/cosmos/bank/v1beta1/spendable_balances/${string}`
}
    params: {
        path: {
axelar: {
/** address is the address to query spendable balances for. */
address: string
}
evmos: {
/** address is the address to query spendable balances for. */
address: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QuerySpendableBalancesResponse defines the gRPC response structure for querying
an account's spendable balances. */
{
/** balances is the spendable balances of all the coins. */
balances: Array<{
denom: string
amount: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QuerySpendableBalancesResponse defines the gRPC response structure for querying
an account's spendable balances. */
{
/** balances is the spendable balances of all the coins. */
balances: Array<{
denom: string
amount: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** TotalSupply queries the total supply of all coins. */
TotalSupply: {
    method: 'get'
    endpoint: {
/** '/cosmos/bank/v1beta1/supply' */
axelar: `/cosmos/bank/v1beta1/supply`
/** '/cosmos/bank/v1beta1/supply' */
evmos: `/cosmos/bank/v1beta1/supply`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
method */
{
/** supply is the supply of the coins */
supply: Array<{
denom: string
amount: string
}>
/** pagination defines the pagination in the response.

Since: cosmos-sdk 0.43 */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC
method */
{
/** supply is the supply of the coins */
supply: Array<{
denom: string
amount: string
}>
/** pagination defines the pagination in the response.

Since: cosmos-sdk 0.43 */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** SupplyOf queries the supply of a single coin. */
SupplyOf: {
    method: 'get'
    endpoint: {
/** '/cosmos/bank/v1beta1/supply/{denom}' */
axelar: `/cosmos/bank/v1beta1/supply/${string}`
/** '/cosmos/bank/v1beta1/supply/{denom}' */
evmos: `/cosmos/bank/v1beta1/supply/${string}`
}
    params: {
        path: {
axelar: {
/** denom is the coin denom to query balances for. */
denom: string
}
evmos: {
/** denom is the coin denom to query balances for. */
denom: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method. */
{
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
amount: {
denom: string
amount: string
}
}
evmos: /** QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method. */
{
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
amount: {
denom: string
amount: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** CommunityPool queries the community pool coins. */
CommunityPool: {
    method: 'get'
    endpoint: {
/** '/cosmos/distribution/v1beta1/community_pool' */
axelar: `/cosmos/distribution/v1beta1/community_pool`
/** '/cosmos/distribution/v1beta1/community_pool' */
evmos: `/cosmos/distribution/v1beta1/community_pool`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryCommunityPoolResponse is the response type for the Query/CommunityPool
RPC method. */
{
/** pool defines community pool's coins. */
pool: Array<{
denom: string
amount: string
}>
}
evmos: /** QueryCommunityPoolResponse is the response type for the Query/CommunityPool
RPC method. */
{
/** pool defines community pool's coins. */
pool: Array<{
denom: string
amount: string
}>
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** DelegationTotalRewards queries the total rewards accrued by a each
validator. */
DelegationTotalRewards: {
    method: 'get'
    endpoint: {
/** '/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards' */
axelar: `/cosmos/distribution/v1beta1/delegators/${string}/rewards`
/** '/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards' */
evmos: `/cosmos/distribution/v1beta1/delegators/${string}/rewards`
}
    params: {
        path: {
axelar: {
/** delegator_address defines the delegator address to query for. */
delegator_address: string
}
evmos: {
/** delegator_address defines the delegator address to query for. */
delegator_address: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryDelegationTotalRewardsResponse is the response type for the
Query/DelegationTotalRewards RPC method. */
{
/** rewards defines all the rewards accrued by a delegator. */
rewards: Array<{
validator_address: string
reward: Array<{
denom: string
amount: string
}>
}>
/** total defines the sum of all the rewards. */
total: Array<{
denom: string
amount: string
}>
}
evmos: /** QueryDelegationTotalRewardsResponse is the response type for the
Query/DelegationTotalRewards RPC method. */
{
/** rewards defines all the rewards accrued by a delegator. */
rewards: Array<{
validator_address: string
reward: Array<{
denom: string
amount: string
}>
}>
/** total defines the sum of all the rewards. */
total: Array<{
denom: string
amount: string
}>
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** DelegationRewards queries the total rewards accrued by a delegation. */
DelegationRewards: {
    method: 'get'
    endpoint: {
/** '/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}' */
axelar: `/cosmos/distribution/v1beta1/delegators/${string}/rewards/${string}`
/** '/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}' */
evmos: `/cosmos/distribution/v1beta1/delegators/${string}/rewards/${string}`
}
    params: {
        path: {
axelar: {
/** delegator_address defines the delegator address to query for. */
delegator_address: string
/** validator_address defines the validator address to query for. */
validator_address: string
}
evmos: {
/** delegator_address defines the delegator address to query for. */
delegator_address: string
/** validator_address defines the validator address to query for. */
validator_address: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryDelegationRewardsResponse is the response type for the
Query/DelegationRewards RPC method. */
{
/** rewards defines the rewards accrued by a delegation. */
rewards: Array<{
denom: string
amount: string
}>
}
evmos: /** QueryDelegationRewardsResponse is the response type for the
Query/DelegationRewards RPC method. */
{
/** rewards defines the rewards accrued by a delegation. */
rewards: Array<{
denom: string
amount: string
}>
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** DelegatorValidators queries the validators of a delegator. */
DistDelegatorValidators: {
    method: 'get'
    endpoint: {
/** '/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators' */
evmos: `/cosmos/distribution/v1beta1/delegators/${string}/validators`
}
    params: {
        path: {
evmos: {
/** delegator_address defines the delegator address to query for. */
delegator_address: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: /** QueryDelegatorValidatorsResponse is the response type for the
Query/DelegatorValidators RPC method. */
{
/** validators defines the validators a delegator is delegating for. */
validators: Array<string>
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** DelegatorWithdrawAddress queries withdraw address of a delegator. */
DelegatorWithdrawAddress: {
    method: 'get'
    endpoint: {
/** '/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address' */
axelar: `/cosmos/distribution/v1beta1/delegators/${string}/withdraw_address`
/** '/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address' */
evmos: `/cosmos/distribution/v1beta1/delegators/${string}/withdraw_address`
}
    params: {
        path: {
axelar: {
/** delegator_address defines the delegator address to query for. */
delegator_address: string
}
evmos: {
/** delegator_address defines the delegator address to query for. */
delegator_address: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryDelegatorWithdrawAddressResponse is the response type for the
Query/DelegatorWithdrawAddress RPC method. */
{
/** withdraw_address defines the delegator address to query for. */
withdraw_address: string
}
evmos: /** QueryDelegatorWithdrawAddressResponse is the response type for the
Query/DelegatorWithdrawAddress RPC method. */
{
/** withdraw_address defines the delegator address to query for. */
withdraw_address: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Params queries params of the distribution module. */
DistributionParams: {
    method: 'get'
    endpoint: {
/** '/cosmos/distribution/v1beta1/params' */
axelar: `/cosmos/distribution/v1beta1/params`
/** '/cosmos/distribution/v1beta1/params' */
evmos: `/cosmos/distribution/v1beta1/params`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
{
/** params defines the parameters of the module. */
params: {
community_tax: string
base_proposer_reward: string
bonus_proposer_reward: string
withdraw_addr_enabled: boolean
}
}
evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
{
/** params defines the parameters of the module. */
params: {
community_tax: string
base_proposer_reward: string
bonus_proposer_reward: string
withdraw_addr_enabled: boolean
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** ValidatorCommission queries accumulated commission for a validator. */
ValidatorCommission: {
    method: 'get'
    endpoint: {
/** '/cosmos/distribution/v1beta1/validators/{validator_address}/commission' */
axelar: `/cosmos/distribution/v1beta1/validators/${string}/commission`
/** '/cosmos/distribution/v1beta1/validators/{validator_address}/commission' */
evmos: `/cosmos/distribution/v1beta1/validators/${string}/commission`
}
    params: {
        path: {
axelar: {
/** validator_address defines the validator address to query for. */
validator_address: string
}
evmos: {
/** validator_address defines the validator address to query for. */
validator_address: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryValidatorCommissionResponse is the response type for the
Query/ValidatorCommission RPC method */
{
/** commission defines the commision the validator received. */
commission: {
commission: Array<{
denom: string
amount: string
}>
}
}
evmos: /** QueryValidatorCommissionResponse is the response type for the
Query/ValidatorCommission RPC method */
{
/** commission defines the commision the validator received. */
commission: {
commission: Array<{
denom: string
amount: string
}>
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** ValidatorOutstandingRewards queries rewards of a validator address. */
ValidatorOutstandingRewards: {
    method: 'get'
    endpoint: {
/** '/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards' */
axelar: `/cosmos/distribution/v1beta1/validators/${string}/outstanding_rewards`
/** '/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards' */
evmos: `/cosmos/distribution/v1beta1/validators/${string}/outstanding_rewards`
}
    params: {
        path: {
axelar: {
/** validator_address defines the validator address to query for. */
validator_address: string
}
evmos: {
/** validator_address defines the validator address to query for. */
validator_address: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryValidatorOutstandingRewardsResponse is the response type for the
Query/ValidatorOutstandingRewards RPC method. */
{
/** ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
for a validator inexpensive to track, allows simple sanity checks. */
rewards: {
rewards: Array<{
denom: string
amount: string
}>
}
}
evmos: /** QueryValidatorOutstandingRewardsResponse is the response type for the
Query/ValidatorOutstandingRewards RPC method. */
{
/** ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards
for a validator inexpensive to track, allows simple sanity checks. */
rewards: {
rewards: Array<{
denom: string
amount: string
}>
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** ValidatorSlashes queries slash events of a validator. */
ValidatorSlashes: {
    method: 'get'
    endpoint: {
/** '/cosmos/distribution/v1beta1/validators/{validator_address}/slashes' */
axelar: `/cosmos/distribution/v1beta1/validators/${string}/slashes`
/** '/cosmos/distribution/v1beta1/validators/{validator_address}/slashes' */
evmos: `/cosmos/distribution/v1beta1/validators/${string}/slashes`
}
    params: {
        path: {
axelar: {
/** validator_address defines the validator address to query for. */
validator_address: string
}
evmos: {
/** validator_address defines the validator address to query for. */
validator_address: string
}
}
    
        query: {
axelar: {
/** starting_height defines the optional starting height to query the slashes. */
starting_height: number
/** starting_height defines the optional ending height to query the slashes. */
ending_height: number
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** starting_height defines the optional starting height to query the slashes. */
starting_height: number
/** starting_height defines the optional ending height to query the slashes. */
ending_height: number
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** starting_height defines the optional starting height to query the slashes. */
starting_height: number
/** starting_height defines the optional ending height to query the slashes. */
ending_height: number
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** starting_height defines the optional starting height to query the slashes. */
starting_height: number
/** starting_height defines the optional ending height to query the slashes. */
ending_height: number
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryValidatorSlashesResponse is the response type for the
Query/ValidatorSlashes RPC method. */
{
/** slashes defines the slashes the validator received. */
slashes: Array<{
validator_period: string
fraction: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryValidatorSlashesResponse is the response type for the
Query/ValidatorSlashes RPC method. */
{
/** slashes defines the slashes the validator received. */
slashes: Array<{
validator_period: string
fraction: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Allowance returns fee granted to the grantee by the granter. */
Allowance: {
    method: 'get'
    endpoint: {
/** '/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}' */
axelar: `/cosmos/feegrant/v1beta1/allowance/${string}/${string}`
/** '/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}' */
evmos: `/cosmos/feegrant/v1beta1/allowance/${string}/${string}`
}
    params: {
        path: {
axelar: {
/** granter is the address of the user granting an allowance of their funds. */
granter: string
/** grantee is the address of the user being granted an allowance of another user's funds. */
grantee: string
}
evmos: {
/** granter is the address of the user granting an allowance of their funds. */
granter: string
/** grantee is the address of the user being granted an allowance of another user's funds. */
grantee: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryAllowanceResponse is the response type for the Query/Allowance RPC method. */
{
/** Grant is stored in the KVStore to record a grant with full context */
allowance: {
/** granter is the address of the user granting an allowance of their funds. */
granter: string
/** grantee is the address of the user being granted an allowance of another user's funds. */
grantee: string
/** allowance can be any of basic and filtered fee allowance. */
allowance: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
}
evmos: /** QueryAllowanceResponse is the response type for the Query/Allowance RPC method. */
{
/** Grant is stored in the KVStore to record a grant with full context */
allowance: {
/** granter is the address of the user granting an allowance of their funds. */
granter: string
/** grantee is the address of the user being granted an allowance of another user's funds. */
grantee: string
/** allowance can be any of basic and filtered fee allowance. */
allowance: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Allowances returns all the grants for address. */
Allowances: {
    method: 'get'
    endpoint: {
/** '/cosmos/feegrant/v1beta1/allowances/{grantee}' */
axelar: `/cosmos/feegrant/v1beta1/allowances/${string}`
/** '/cosmos/feegrant/v1beta1/allowances/{grantee}' */
evmos: `/cosmos/feegrant/v1beta1/allowances/${string}`
}
    params: {
        path: {
axelar: {
grantee: string
}
evmos: {
grantee: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryAllowancesResponse is the response type for the Query/Allowances RPC method. */
{
/** allowances are allowance's granted for grantee by granter. */
allowances: Array<{
/** granter is the address of the user granting an allowance of their funds. */
granter: string
/** grantee is the address of the user being granted an allowance of another user's funds. */
grantee: string
/** allowance can be any of basic and filtered fee allowance. */
allowance: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}>
/** pagination defines an pagination for the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryAllowancesResponse is the response type for the Query/Allowances RPC method. */
{
/** allowances are allowance's granted for grantee by granter. */
allowances: Array<{
/** granter is the address of the user granting an allowance of their funds. */
granter: string
/** grantee is the address of the user being granted an allowance of another user's funds. */
grantee: string
/** allowance can be any of basic and filtered fee allowance. */
allowance: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}>
/** pagination defines an pagination for the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** AllEvidence queries all evidence. */
AllEvidence: {
    method: 'get'
    endpoint: {
/** '/cosmos/evidence/v1beta1/evidence' */
axelar: `/cosmos/evidence/v1beta1/evidence`
/** '/cosmos/evidence/v1beta1/evidence' */
evmos: `/cosmos/evidence/v1beta1/evidence`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC
method. */
{
/** evidence returns all evidences. */
evidence: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC
method. */
{
/** evidence returns all evidences. */
evidence: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Evidence queries evidence based on evidence hash. */
Evidence: {
    method: 'get'
    endpoint: {
/** '/cosmos/evidence/v1beta1/evidence/{evidence_hash}' */
axelar: `/cosmos/evidence/v1beta1/evidence/${string}`
/** '/cosmos/evidence/v1beta1/evidence/{evidence_hash}' */
evmos: `/cosmos/evidence/v1beta1/evidence/${string}`
}
    params: {
        path: {
axelar: {
/** evidence_hash defines the hash of the requested evidence. */
evidence_hash: string
}
evmos: {
/** evidence_hash defines the hash of the requested evidence. */
evidence_hash: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryEvidenceResponse is the response type for the Query/Evidence RPC method. */
{
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
evidence: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
evmos: /** QueryEvidenceResponse is the response type for the Query/Evidence RPC method. */
{
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
evidence: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Params queries all parameters of the gov module. */
GovParams: {
    method: 'get'
    endpoint: {
/** '/cosmos/gov/v1beta1/params/{params_type}' */
axelar: `/cosmos/gov/v1beta1/params/${string}`
/** '/cosmos/gov/v1beta1/params/{params_type}' */
evmos: `/cosmos/gov/v1beta1/params/${string}`
}
    params: {
        path: {
axelar: {
/** params_type defines which parameters to query for, can be one of "voting",
"tallying" or "deposit". */
params_type: string
}
evmos: {
/** params_type defines which parameters to query for, can be one of "voting",
"tallying" or "deposit". */
params_type: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
{
/** voting_params defines the parameters related to voting. */
voting_params: {
/** Length of the voting period. */
voting_period: string
}
/** deposit_params defines the parameters related to deposit. */
deposit_params: {
/** Minimum deposit for a proposal to enter voting period. */
min_deposit: Array<{
denom: string
amount: string
}>
/** Maximum period for Atom holders to deposit on a proposal. Initial value: 2
 months. */
max_deposit_period: string
}
/** tally_params defines the parameters related to tally. */
tally_params: {
/** Minimum percentage of total stake needed to vote for a result to be
 considered valid. */
quorum: string
/** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
threshold: string
/** Minimum value of Veto votes to Total votes ratio for proposal to be
 vetoed. Default value: 1/3. */
veto_threshold: string
}
}
evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
{
/** voting_params defines the parameters related to voting. */
voting_params: {
/** Length of the voting period. */
voting_period: string
}
/** deposit_params defines the parameters related to deposit. */
deposit_params: {
/** Minimum deposit for a proposal to enter voting period. */
min_deposit: Array<{
denom: string
amount: string
}>
/** Maximum period for Atom holders to deposit on a proposal. Initial value: 2
 months. */
max_deposit_period: string
}
/** tally_params defines the parameters related to tally. */
tally_params: {
/** Minimum percentage of total stake needed to vote for a result to be
 considered valid. */
quorum: string
/** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
threshold: string
/** Minimum value of Veto votes to Total votes ratio for proposal to be
 vetoed. Default value: 1/3. */
veto_threshold: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Proposals queries all proposals based on given status. */
Proposals: {
    method: 'get'
    endpoint: {
/** '/cosmos/gov/v1beta1/proposals' */
axelar: `/cosmos/gov/v1beta1/proposals`
/** '/cosmos/gov/v1beta1/proposals' */
evmos: `/cosmos/gov/v1beta1/proposals`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: {
/** proposal_status defines the status of the proposals.

 - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
 - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
period.
 - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
period.
 - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
passed.
 - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
been rejected.
 - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
failed. */
proposal_status: string
/** voter defines the voter address for the proposals. */
voter: string
/** depositor defines the deposit addresses from the proposals. */
depositor: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** proposal_status defines the status of the proposals.

 - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
 - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
period.
 - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
period.
 - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
passed.
 - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
been rejected.
 - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
failed. */
proposal_status: string
/** voter defines the voter address for the proposals. */
voter: string
/** depositor defines the deposit addresses from the proposals. */
depositor: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** proposal_status defines the status of the proposals.

 - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
 - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
period.
 - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
period.
 - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
passed.
 - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
been rejected.
 - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
failed. */
proposal_status: string
/** voter defines the voter address for the proposals. */
voter: string
/** depositor defines the deposit addresses from the proposals. */
depositor: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** proposal_status defines the status of the proposals.

 - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
 - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
period.
 - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
period.
 - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
passed.
 - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
been rejected.
 - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
failed. */
proposal_status: string
/** voter defines the voter address for the proposals. */
voter: string
/** depositor defines the deposit addresses from the proposals. */
depositor: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryProposalsResponse is the response type for the Query/Proposals RPC
method. */
{
proposals: Array<{
proposal_id: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
content: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** ProposalStatus enumerates the valid statuses of a proposal.

 - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
 - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
period.
 - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
period.
 - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
passed.
 - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
been rejected.
 - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
failed. */
status: string
/** TallyResult defines a standard tally for a governance proposal. */
final_tally_result: {
yes: string
abstain: string
no: string
no_with_veto: string
}
submit_time: string
deposit_end_time: string
total_deposit: Array<{
denom: string
amount: string
}>
voting_start_time: string
voting_end_time: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryProposalsResponse is the response type for the Query/Proposals RPC
method. */
{
proposals: Array<{
proposal_id: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
content: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** ProposalStatus enumerates the valid statuses of a proposal.

 - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
 - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
period.
 - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
period.
 - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
passed.
 - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
been rejected.
 - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
failed. */
status: string
/** TallyResult defines a standard tally for a governance proposal. */
final_tally_result: {
yes: string
abstain: string
no: string
no_with_veto: string
}
submit_time: string
deposit_end_time: string
total_deposit: Array<{
denom: string
amount: string
}>
voting_start_time: string
voting_end_time: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Proposal queries proposal details based on ProposalID. */
Proposal: {
    method: 'get'
    endpoint: {
/** '/cosmos/gov/v1beta1/proposals/{proposal_id}' */
axelar: `/cosmos/gov/v1beta1/proposals/${number}`
/** '/cosmos/gov/v1beta1/proposals/{proposal_id}' */
evmos: `/cosmos/gov/v1beta1/proposals/${number}`
}
    params: {
        path: {
axelar: {
/** proposal_id defines the unique id of the proposal. */
proposal_id: number
}
evmos: {
/** proposal_id defines the unique id of the proposal. */
proposal_id: number
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryProposalResponse is the response type for the Query/Proposal RPC method. */
{
/** Proposal defines the core field members of a governance proposal. */
proposal: {
proposal_id: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
content: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** ProposalStatus enumerates the valid statuses of a proposal.

 - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
 - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
period.
 - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
period.
 - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
passed.
 - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
been rejected.
 - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
failed. */
status: string
/** TallyResult defines a standard tally for a governance proposal. */
final_tally_result: {
yes: string
abstain: string
no: string
no_with_veto: string
}
submit_time: string
deposit_end_time: string
total_deposit: Array<{
denom: string
amount: string
}>
voting_start_time: string
voting_end_time: string
}
}
evmos: /** QueryProposalResponse is the response type for the Query/Proposal RPC method. */
{
/** Proposal defines the core field members of a governance proposal. */
proposal: {
proposal_id: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
content: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** ProposalStatus enumerates the valid statuses of a proposal.

 - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.
 - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
period.
 - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
period.
 - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
passed.
 - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
been rejected.
 - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
failed. */
status: string
/** TallyResult defines a standard tally for a governance proposal. */
final_tally_result: {
yes: string
abstain: string
no: string
no_with_veto: string
}
submit_time: string
deposit_end_time: string
total_deposit: Array<{
denom: string
amount: string
}>
voting_start_time: string
voting_end_time: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Deposits queries all deposits of a single proposal. */
Deposits: {
    method: 'get'
    endpoint: {
/** '/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits' */
axelar: `/cosmos/gov/v1beta1/proposals/${number}/deposits`
/** '/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits' */
evmos: `/cosmos/gov/v1beta1/proposals/${number}/deposits`
}
    params: {
        path: {
axelar: {
/** proposal_id defines the unique id of the proposal. */
proposal_id: number
}
evmos: {
/** proposal_id defines the unique id of the proposal. */
proposal_id: number
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryDepositsResponse is the response type for the Query/Deposits RPC method. */
{
deposits: Array<{
proposal_id: string
depositor: string
amount: Array<{
denom: string
amount: string
}>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryDepositsResponse is the response type for the Query/Deposits RPC method. */
{
deposits: Array<{
proposal_id: string
depositor: string
amount: Array<{
denom: string
amount: string
}>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Deposit queries single deposit information based proposalID, depositAddr. */
Deposit: {
    method: 'get'
    endpoint: {
/** '/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}' */
axelar: `/cosmos/gov/v1beta1/proposals/${number}/deposits/${string}`
/** '/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}' */
evmos: `/cosmos/gov/v1beta1/proposals/${number}/deposits/${string}`
}
    params: {
        path: {
axelar: {
/** proposal_id defines the unique id of the proposal. */
proposal_id: number
/** depositor defines the deposit addresses from the proposals. */
depositor: string
}
evmos: {
/** proposal_id defines the unique id of the proposal. */
proposal_id: number
/** depositor defines the deposit addresses from the proposals. */
depositor: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryDepositResponse is the response type for the Query/Deposit RPC method. */
{
/** Deposit defines an amount deposited by an account address to an active
proposal. */
deposit: {
proposal_id: string
depositor: string
amount: Array<{
denom: string
amount: string
}>
}
}
evmos: /** QueryDepositResponse is the response type for the Query/Deposit RPC method. */
{
/** Deposit defines an amount deposited by an account address to an active
proposal. */
deposit: {
proposal_id: string
depositor: string
amount: Array<{
denom: string
amount: string
}>
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** TallyResult queries the tally of a proposal vote. */
TallyResult: {
    method: 'get'
    endpoint: {
/** '/cosmos/gov/v1beta1/proposals/{proposal_id}/tally' */
axelar: `/cosmos/gov/v1beta1/proposals/${number}/tally`
/** '/cosmos/gov/v1beta1/proposals/{proposal_id}/tally' */
evmos: `/cosmos/gov/v1beta1/proposals/${number}/tally`
}
    params: {
        path: {
axelar: {
/** proposal_id defines the unique id of the proposal. */
proposal_id: number
}
evmos: {
/** proposal_id defines the unique id of the proposal. */
proposal_id: number
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryTallyResultResponse is the response type for the Query/Tally RPC method. */
{
/** TallyResult defines a standard tally for a governance proposal. */
tally: {
yes: string
abstain: string
no: string
no_with_veto: string
}
}
evmos: /** QueryTallyResultResponse is the response type for the Query/Tally RPC method. */
{
/** TallyResult defines a standard tally for a governance proposal. */
tally: {
yes: string
abstain: string
no: string
no_with_veto: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Votes queries votes of a given proposal. */
Votes: {
    method: 'get'
    endpoint: {
/** '/cosmos/gov/v1beta1/proposals/{proposal_id}/votes' */
axelar: `/cosmos/gov/v1beta1/proposals/${number}/votes`
/** '/cosmos/gov/v1beta1/proposals/{proposal_id}/votes' */
evmos: `/cosmos/gov/v1beta1/proposals/${number}/votes`
}
    params: {
        path: {
axelar: {
/** proposal_id defines the unique id of the proposal. */
proposal_id: number
}
evmos: {
/** proposal_id defines the unique id of the proposal. */
proposal_id: number
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryVotesResponse is the response type for the Query/Votes RPC method. */
{
/** votes defined the queried votes. */
votes: Array<{
proposal_id: string
voter: string
/** Deprecated: Prefer to use `options` instead. This field is set in queries
if and only if `len(options) == 1` and that option has weight 1. In all
other cases, this field will default to VOTE_OPTION_UNSPECIFIED. */
option: string
/** Since: cosmos-sdk 0.43 */
options: Array<{
/** VoteOption enumerates the valid vote options for a given governance proposal.

 - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
 - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
 - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
 - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
 - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */
option: string
weight: string
}>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryVotesResponse is the response type for the Query/Votes RPC method. */
{
/** votes defined the queried votes. */
votes: Array<{
proposal_id: string
voter: string
/** Deprecated: Prefer to use `options` instead. This field is set in queries
if and only if `len(options) == 1` and that option has weight 1. In all
other cases, this field will default to VOTE_OPTION_UNSPECIFIED. */
option: string
/** Since: cosmos-sdk 0.43 */
options: Array<{
/** VoteOption enumerates the valid vote options for a given governance proposal.

 - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
 - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
 - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
 - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
 - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */
option: string
weight: string
}>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Vote queries voted information based on proposalID, voterAddr. */
Vote: {
    method: 'get'
    endpoint: {
/** '/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}' */
axelar: `/cosmos/gov/v1beta1/proposals/${number}/votes/${string}`
/** '/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}' */
evmos: `/cosmos/gov/v1beta1/proposals/${number}/votes/${string}`
}
    params: {
        path: {
axelar: {
/** proposal_id defines the unique id of the proposal. */
proposal_id: number
/** voter defines the oter address for the proposals. */
voter: string
}
evmos: {
/** proposal_id defines the unique id of the proposal. */
proposal_id: number
/** voter defines the oter address for the proposals. */
voter: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryVoteResponse is the response type for the Query/Vote RPC method. */
{
/** Vote defines a vote on a governance proposal.
A Vote consists of a proposal ID, the voter, and the vote option. */
vote: {
proposal_id: string
voter: string
/** Deprecated: Prefer to use `options` instead. This field is set in queries
if and only if `len(options) == 1` and that option has weight 1. In all
other cases, this field will default to VOTE_OPTION_UNSPECIFIED. */
option: string
/** Since: cosmos-sdk 0.43 */
options: Array<{
/** VoteOption enumerates the valid vote options for a given governance proposal.

 - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
 - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
 - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
 - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
 - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */
option: string
weight: string
}>
}
}
evmos: /** QueryVoteResponse is the response type for the Query/Vote RPC method. */
{
/** Vote defines a vote on a governance proposal.
A Vote consists of a proposal ID, the voter, and the vote option. */
vote: {
proposal_id: string
voter: string
/** Deprecated: Prefer to use `options` instead. This field is set in queries
if and only if `len(options) == 1` and that option has weight 1. In all
other cases, this field will default to VOTE_OPTION_UNSPECIFIED. */
option: string
/** Since: cosmos-sdk 0.43 */
options: Array<{
/** VoteOption enumerates the valid vote options for a given governance proposal.

 - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.
 - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.
 - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.
 - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.
 - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */
option: string
weight: string
}>
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Params queries the parameters of slashing module */
SlashingParams: {
    method: 'get'
    endpoint: {
/** '/cosmos/slashing/v1beta1/params' */
axelar: `/cosmos/slashing/v1beta1/params`
/** '/cosmos/slashing/v1beta1/params' */
evmos: `/cosmos/slashing/v1beta1/params`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryParamsResponse is the response type for the Query/Params RPC method */
{
/** Params represents the parameters used for by the slashing module. */
params: {
signed_blocks_window: string
min_signed_per_window: string
downtime_jail_duration: string
slash_fraction_double_sign: string
slash_fraction_downtime: string
}
}
evmos: /** QueryParamsResponse is the response type for the Query/Params RPC method */
{
/** Params represents the parameters used for by the slashing module. */
params: {
signed_blocks_window: string
min_signed_per_window: string
downtime_jail_duration: string
slash_fraction_double_sign: string
slash_fraction_downtime: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** SigningInfos queries signing info of all validators */
SigningInfos: {
    method: 'get'
    endpoint: {
/** '/cosmos/slashing/v1beta1/signing_infos' */
axelar: `/cosmos/slashing/v1beta1/signing_infos`
/** '/cosmos/slashing/v1beta1/signing_infos' */
evmos: `/cosmos/slashing/v1beta1/signing_infos`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC
method */
{
/** info is the signing info of all validators */
info: Array<{
address: string
/** Height at which validator was first a candidate OR was unjailed */
start_height: string
/** Index which is incremented each time the validator was a bonded
in a block and may have signed a precommit or not. This in conjunction with the
`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`. */
index_offset: string
/** Timestamp until which the validator is jailed due to liveness downtime. */
jailed_until: string
/** Whether or not a validator has been tombstoned (killed out of validator set). It is set
once the validator commits an equivocation or for any other configured misbehiavor. */
tombstoned: boolean
/** A counter kept to avoid unnecessary array reads.
Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`. */
missed_blocks_counter: string
}>
/** PageResponse is to be embedded in gRPC response messages where the
corresponding request message has used PageRequest.

 message SomeResponse {
         repeated Bar results = 1;
         PageResponse page = 2;
 } */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC
method */
{
/** info is the signing info of all validators */
info: Array<{
address: string
/** Height at which validator was first a candidate OR was unjailed */
start_height: string
/** Index which is incremented each time the validator was a bonded
in a block and may have signed a precommit or not. This in conjunction with the
`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`. */
index_offset: string
/** Timestamp until which the validator is jailed due to liveness downtime. */
jailed_until: string
/** Whether or not a validator has been tombstoned (killed out of validator set). It is set
once the validator commits an equivocation or for any other configured misbehiavor. */
tombstoned: boolean
/** A counter kept to avoid unnecessary array reads.
Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`. */
missed_blocks_counter: string
}>
/** PageResponse is to be embedded in gRPC response messages where the
corresponding request message has used PageRequest.

 message SomeResponse {
         repeated Bar results = 1;
         PageResponse page = 2;
 } */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** SigningInfo queries the signing info of given cons address */
SigningInfo: {
    method: 'get'
    endpoint: {
/** '/cosmos/slashing/v1beta1/signing_infos/{cons_address}' */
axelar: `/cosmos/slashing/v1beta1/signing_infos/${string}`
/** '/cosmos/slashing/v1beta1/signing_infos/{cons_address}' */
evmos: `/cosmos/slashing/v1beta1/signing_infos/${string}`
}
    params: {
        path: {
axelar: {
/** cons_address is the address to query signing info of */
cons_address: string
}
evmos: {
/** cons_address is the address to query signing info of */
cons_address: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC
method */
{
/** val_signing_info is the signing info of requested val cons address */
val_signing_info: {
address: string
/** Height at which validator was first a candidate OR was unjailed */
start_height: string
/** Index which is incremented each time the validator was a bonded
in a block and may have signed a precommit or not. This in conjunction with the
`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`. */
index_offset: string
/** Timestamp until which the validator is jailed due to liveness downtime. */
jailed_until: string
/** Whether or not a validator has been tombstoned (killed out of validator set). It is set
once the validator commits an equivocation or for any other configured misbehiavor. */
tombstoned: boolean
/** A counter kept to avoid unnecessary array reads.
Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`. */
missed_blocks_counter: string
}
}
evmos: /** QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC
method */
{
/** val_signing_info is the signing info of requested val cons address */
val_signing_info: {
address: string
/** Height at which validator was first a candidate OR was unjailed */
start_height: string
/** Index which is incremented each time the validator was a bonded
in a block and may have signed a precommit or not. This in conjunction with the
`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`. */
index_offset: string
/** Timestamp until which the validator is jailed due to liveness downtime. */
jailed_until: string
/** Whether or not a validator has been tombstoned (killed out of validator set). It is set
once the validator commits an equivocation or for any other configured misbehiavor. */
tombstoned: boolean
/** A counter kept to avoid unnecessary array reads.
Note that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`. */
missed_blocks_counter: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** DelegatorDelegations queries all delegations of a given delegator address. */
DelegatorDelegations: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/delegations/{delegator_addr}' */
axelar: `/cosmos/staking/v1beta1/delegations/${string}`
/** '/cosmos/staking/v1beta1/delegations/{delegator_addr}' */
evmos: `/cosmos/staking/v1beta1/delegations/${string}`
}
    params: {
        path: {
axelar: {
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
}
evmos: {
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryDelegatorDelegationsResponse is response type for the
Query/DelegatorDelegations RPC method. */
{
/** delegation_responses defines all the delegations' info of a delegator. */
delegation_responses: Array<{
/** Delegation represents the bond with tokens held by an account. It is
owned by one delegator, and is associated with the voting power of one
validator. */
delegation: {
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_address is the bech32-encoded address of the validator. */
validator_address: string
/** shares define the delegation shares received. */
shares: string
}
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
balance: {
denom: string
amount: string
}
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryDelegatorDelegationsResponse is response type for the
Query/DelegatorDelegations RPC method. */
{
/** delegation_responses defines all the delegations' info of a delegator. */
delegation_responses: Array<{
/** Delegation represents the bond with tokens held by an account. It is
owned by one delegator, and is associated with the voting power of one
validator. */
delegation: {
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_address is the bech32-encoded address of the validator. */
validator_address: string
/** shares define the delegation shares received. */
shares: string
}
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
balance: {
denom: string
amount: string
}
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Redelegations queries redelegations of given address. */
Redelegations: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations' */
axelar: `/cosmos/staking/v1beta1/delegators/${string}/redelegations`
/** '/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations' */
evmos: `/cosmos/staking/v1beta1/delegators/${string}/redelegations`
}
    params: {
        path: {
axelar: {
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
}
evmos: {
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
}
}
    
        query: {
axelar: {
/** src_validator_addr defines the validator address to redelegate from. */
src_validator_addr: string
/** dst_validator_addr defines the validator address to redelegate to. */
dst_validator_addr: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** src_validator_addr defines the validator address to redelegate from. */
src_validator_addr: string
/** dst_validator_addr defines the validator address to redelegate to. */
dst_validator_addr: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** src_validator_addr defines the validator address to redelegate from. */
src_validator_addr: string
/** dst_validator_addr defines the validator address to redelegate to. */
dst_validator_addr: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** src_validator_addr defines the validator address to redelegate from. */
src_validator_addr: string
/** dst_validator_addr defines the validator address to redelegate to. */
dst_validator_addr: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryRedelegationsResponse is response type for the Query/Redelegations RPC
method. */
{
redelegation_responses: Array<{
/** Redelegation contains the list of a particular delegator's redelegating bonds
from a particular source validator to a particular destination validator. */
redelegation: {
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_src_address is the validator redelegation source operator address. */
validator_src_address: string
/** validator_dst_address is the validator redelegation destination operator address. */
validator_dst_address: string
/** entries are the redelegation entries. */
entries: Array<{
/** creation_height  defines the height which the redelegation took place. */
creation_height: string
/** completion_time defines the unix time for redelegation completion. */
completion_time: string
/** initial_balance defines the initial balance when redelegation started. */
initial_balance: string
/** shares_dst is the amount of destination-validator shares created by redelegation. */
shares_dst: string
}>
}
entries: Array<{
/** RedelegationEntry defines a redelegation object with relevant metadata. */
redelegation_entry: {
/** creation_height  defines the height which the redelegation took place. */
creation_height: string
/** completion_time defines the unix time for redelegation completion. */
completion_time: string
/** initial_balance defines the initial balance when redelegation started. */
initial_balance: string
/** shares_dst is the amount of destination-validator shares created by redelegation. */
shares_dst: string
}
balance: string
}>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryRedelegationsResponse is response type for the Query/Redelegations RPC
method. */
{
redelegation_responses: Array<{
/** Redelegation contains the list of a particular delegator's redelegating bonds
from a particular source validator to a particular destination validator. */
redelegation: {
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_src_address is the validator redelegation source operator address. */
validator_src_address: string
/** validator_dst_address is the validator redelegation destination operator address. */
validator_dst_address: string
/** entries are the redelegation entries. */
entries: Array<{
/** creation_height  defines the height which the redelegation took place. */
creation_height: string
/** completion_time defines the unix time for redelegation completion. */
completion_time: string
/** initial_balance defines the initial balance when redelegation started. */
initial_balance: string
/** shares_dst is the amount of destination-validator shares created by redelegation. */
shares_dst: string
}>
}
entries: Array<{
/** RedelegationEntry defines a redelegation object with relevant metadata. */
redelegation_entry: {
/** creation_height  defines the height which the redelegation took place. */
creation_height: string
/** completion_time defines the unix time for redelegation completion. */
completion_time: string
/** initial_balance defines the initial balance when redelegation started. */
initial_balance: string
/** shares_dst is the amount of destination-validator shares created by redelegation. */
shares_dst: string
}
balance: string
}>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** DelegatorUnbondingDelegations queries all unbonding delegations of a given
delegator address. */
DelegatorUnbondingDelegations: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations' */
axelar: `/cosmos/staking/v1beta1/delegators/${string}/unbonding_delegations`
/** '/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations' */
evmos: `/cosmos/staking/v1beta1/delegators/${string}/unbonding_delegations`
}
    params: {
        path: {
axelar: {
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
}
evmos: {
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryUnbondingDelegatorDelegationsResponse is response type for the
Query/UnbondingDelegatorDelegations RPC method. */
{
unbonding_responses: Array<{
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_address is the bech32-encoded address of the validator. */
validator_address: string
/** entries are the unbonding delegation entries. */
entries: Array<{
/** creation_height is the height which the unbonding took place. */
creation_height: string
/** completion_time is the unix time for unbonding completion. */
completion_time: string
/** initial_balance defines the tokens initially scheduled to receive at completion. */
initial_balance: string
/** balance defines the tokens to receive at completion. */
balance: string
}>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryUnbondingDelegatorDelegationsResponse is response type for the
Query/UnbondingDelegatorDelegations RPC method. */
{
unbonding_responses: Array<{
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_address is the bech32-encoded address of the validator. */
validator_address: string
/** entries are the unbonding delegation entries. */
entries: Array<{
/** creation_height is the height which the unbonding took place. */
creation_height: string
/** completion_time is the unix time for unbonding completion. */
completion_time: string
/** initial_balance defines the tokens initially scheduled to receive at completion. */
initial_balance: string
/** balance defines the tokens to receive at completion. */
balance: string
}>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** DelegatorValidators queries the validators of a delegator. */
DelegatorValidators: {
    method: 'get'
    endpoint: {
/** '/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators' */
axelar: `/cosmos/distribution/v1beta1/delegators/${string}/validators`
/** '/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators' */
evmos: `/cosmos/staking/v1beta1/delegators/${string}/validators`
}
    params: {
        path: {
axelar: {
/** delegator_address defines the delegator address to query for. */
delegator_address: string
}
evmos: {
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
}
}
    
        query: {
axelar: undefined
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: undefined
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryDelegatorValidatorsResponse is the response type for the
Query/DelegatorValidators RPC method. */
{
/** validators defines the validators a delegator is delegating for. */
validators: Array<string>
}
evmos: /** QueryDelegatorValidatorsResponse is response type for the
Query/DelegatorValidators RPC method. */
{
/** validators defines the the validators' info of a delegator. */
validators: Array<{
/** operator_address defines the address of the validator's operator; bech encoded in JSON. */
operator_address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
consensus_pubkey: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** jailed defined whether the validator has been jailed from bonded status or not. */
jailed: boolean
/** status is the validator status (bonded/unbonding/unbonded). */
status: string
/** tokens define the delegated tokens (incl. self-delegation). */
tokens: string
/** delegator_shares defines total shares issued to a validator's delegators. */
delegator_shares: string
/** description defines the description terms for the validator. */
description: {
/** moniker defines a human-readable name for the validator. */
moniker: string
/** identity defines an optional identity signature (ex. UPort or Keybase). */
identity: string
/** website defines an optional website link. */
website: string
/** security_contact defines an optional email for security contact. */
security_contact: string
/** details define other optional details. */
details: string
}
/** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
unbonding_height: string
/** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
unbonding_time: string
/** commission defines the commission parameters. */
commission: {
/** commission_rates defines the initial commission rates to be used for creating a validator. */
commission_rates: {
/** rate is the commission rate charged to delegators, as a fraction. */
rate: string
/** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
max_rate: string
/** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
max_change_rate: string
}
/** update_time is the last time the commission rate was changed. */
update_time: string
}
/** min_self_delegation is the validator's self declared minimum self delegation. */
min_self_delegation: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** DelegatorValidator queries validator info for given delegator validator
pair. */
DelegatorValidator: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}' */
axelar: `/cosmos/staking/v1beta1/delegators/${string}/validators/${string}`
/** '/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}' */
evmos: `/cosmos/staking/v1beta1/delegators/${string}/validators/${string}`
}
    params: {
        path: {
axelar: {
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
/** validator_addr defines the validator address to query for. */
validator_addr: string
}
evmos: {
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
/** validator_addr defines the validator address to query for. */
validator_addr: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryDelegatorValidatorResponse response type for the
Query/DelegatorValidator RPC method. */
{
/** Validator defines a validator, together with the total amount of the
Validator's bond shares and their exchange rate to coins. Slashing results in
a decrease in the exchange rate, allowing correct calculation of future
undelegations without iterating over delegators. When coins are delegated to
this validator, the validator is credited with a delegation whose number of
bond shares is based on the amount of coins delegated divided by the current
exchange rate. Voting power can be calculated as total bonded shares
multiplied by exchange rate. */
validator: {
/** operator_address defines the address of the validator's operator; bech encoded in JSON. */
operator_address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
consensus_pubkey: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** jailed defined whether the validator has been jailed from bonded status or not. */
jailed: boolean
/** status is the validator status (bonded/unbonding/unbonded). */
status: string
/** tokens define the delegated tokens (incl. self-delegation). */
tokens: string
/** delegator_shares defines total shares issued to a validator's delegators. */
delegator_shares: string
/** description defines the description terms for the validator. */
description: {
/** moniker defines a human-readable name for the validator. */
moniker: string
/** identity defines an optional identity signature (ex. UPort or Keybase). */
identity: string
/** website defines an optional website link. */
website: string
/** security_contact defines an optional email for security contact. */
security_contact: string
/** details define other optional details. */
details: string
}
/** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
unbonding_height: string
/** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
unbonding_time: string
/** commission defines the commission parameters. */
commission: {
/** commission_rates defines the initial commission rates to be used for creating a validator. */
commission_rates: {
/** rate is the commission rate charged to delegators, as a fraction. */
rate: string
/** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
max_rate: string
/** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
max_change_rate: string
}
/** update_time is the last time the commission rate was changed. */
update_time: string
}
/** min_self_delegation is the validator's self declared minimum self delegation. */
min_self_delegation: string
}
}
evmos: /** QueryDelegatorValidatorResponse response type for the
Query/DelegatorValidator RPC method. */
{
/** Validator defines a validator, together with the total amount of the
Validator's bond shares and their exchange rate to coins. Slashing results in
a decrease in the exchange rate, allowing correct calculation of future
undelegations without iterating over delegators. When coins are delegated to
this validator, the validator is credited with a delegation whose number of
bond shares is based on the amount of coins delegated divided by the current
exchange rate. Voting power can be calculated as total bonded shares
multiplied by exchange rate. */
validator: {
/** operator_address defines the address of the validator's operator; bech encoded in JSON. */
operator_address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
consensus_pubkey: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** jailed defined whether the validator has been jailed from bonded status or not. */
jailed: boolean
/** status is the validator status (bonded/unbonding/unbonded). */
status: string
/** tokens define the delegated tokens (incl. self-delegation). */
tokens: string
/** delegator_shares defines total shares issued to a validator's delegators. */
delegator_shares: string
/** description defines the description terms for the validator. */
description: {
/** moniker defines a human-readable name for the validator. */
moniker: string
/** identity defines an optional identity signature (ex. UPort or Keybase). */
identity: string
/** website defines an optional website link. */
website: string
/** security_contact defines an optional email for security contact. */
security_contact: string
/** details define other optional details. */
details: string
}
/** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
unbonding_height: string
/** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
unbonding_time: string
/** commission defines the commission parameters. */
commission: {
/** commission_rates defines the initial commission rates to be used for creating a validator. */
commission_rates: {
/** rate is the commission rate charged to delegators, as a fraction. */
rate: string
/** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
max_rate: string
/** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
max_change_rate: string
}
/** update_time is the last time the commission rate was changed. */
update_time: string
}
/** min_self_delegation is the validator's self declared minimum self delegation. */
min_self_delegation: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** HistoricalInfo queries the historical info for given height. */
HistoricalInfo: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/historical_info/{height}' */
axelar: `/cosmos/staking/v1beta1/historical_info/${number}`
/** '/cosmos/staking/v1beta1/historical_info/{height}' */
evmos: `/cosmos/staking/v1beta1/historical_info/${number}`
}
    params: {
        path: {
axelar: {
/** height defines at which height to query the historical info. */
height: number
}
evmos: {
/** height defines at which height to query the historical info. */
height: number
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC
method. */
{
/** hist defines the historical info at the given height. */
hist: {
/** Header defines the structure of a Tendermint block header. */
header: {
/** basic block info */
version: {
block: string
app: string
}
chain_id: string
height: string
time: string
/** prev block info */
last_block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
/** hashes of block data */
last_commit_hash: string
data_hash: string
/** hashes from the app output from the prev block */
validators_hash: string
next_validators_hash: string
consensus_hash: string
app_hash: string
last_results_hash: string
/** consensus info */
evidence_hash: string
proposer_address: string
}
valset: Array<{
/** operator_address defines the address of the validator's operator; bech encoded in JSON. */
operator_address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
consensus_pubkey: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** jailed defined whether the validator has been jailed from bonded status or not. */
jailed: boolean
/** status is the validator status (bonded/unbonding/unbonded). */
status: string
/** tokens define the delegated tokens (incl. self-delegation). */
tokens: string
/** delegator_shares defines total shares issued to a validator's delegators. */
delegator_shares: string
/** description defines the description terms for the validator. */
description: {
/** moniker defines a human-readable name for the validator. */
moniker: string
/** identity defines an optional identity signature (ex. UPort or Keybase). */
identity: string
/** website defines an optional website link. */
website: string
/** security_contact defines an optional email for security contact. */
security_contact: string
/** details define other optional details. */
details: string
}
/** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
unbonding_height: string
/** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
unbonding_time: string
/** commission defines the commission parameters. */
commission: {
/** commission_rates defines the initial commission rates to be used for creating a validator. */
commission_rates: {
/** rate is the commission rate charged to delegators, as a fraction. */
rate: string
/** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
max_rate: string
/** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
max_change_rate: string
}
/** update_time is the last time the commission rate was changed. */
update_time: string
}
/** min_self_delegation is the validator's self declared minimum self delegation. */
min_self_delegation: string
}>
}
}
evmos: /** QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC
method. */
{
/** hist defines the historical info at the given height. */
hist: {
/** Header defines the structure of a Tendermint block header. */
header: {
/** basic block info */
version: {
block: string
app: string
}
chain_id: string
height: string
time: string
/** prev block info */
last_block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
/** hashes of block data */
last_commit_hash: string
data_hash: string
/** hashes from the app output from the prev block */
validators_hash: string
next_validators_hash: string
consensus_hash: string
app_hash: string
last_results_hash: string
/** consensus info */
evidence_hash: string
proposer_address: string
}
valset: Array<{
/** operator_address defines the address of the validator's operator; bech encoded in JSON. */
operator_address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
consensus_pubkey: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** jailed defined whether the validator has been jailed from bonded status or not. */
jailed: boolean
/** status is the validator status (bonded/unbonding/unbonded). */
status: string
/** tokens define the delegated tokens (incl. self-delegation). */
tokens: string
/** delegator_shares defines total shares issued to a validator's delegators. */
delegator_shares: string
/** description defines the description terms for the validator. */
description: {
/** moniker defines a human-readable name for the validator. */
moniker: string
/** identity defines an optional identity signature (ex. UPort or Keybase). */
identity: string
/** website defines an optional website link. */
website: string
/** security_contact defines an optional email for security contact. */
security_contact: string
/** details define other optional details. */
details: string
}
/** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
unbonding_height: string
/** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
unbonding_time: string
/** commission defines the commission parameters. */
commission: {
/** commission_rates defines the initial commission rates to be used for creating a validator. */
commission_rates: {
/** rate is the commission rate charged to delegators, as a fraction. */
rate: string
/** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
max_rate: string
/** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
max_change_rate: string
}
/** update_time is the last time the commission rate was changed. */
update_time: string
}
/** min_self_delegation is the validator's self declared minimum self delegation. */
min_self_delegation: string
}>
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Parameters queries the staking parameters. */
StakingParams: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/params' */
axelar: `/cosmos/staking/v1beta1/params`
/** '/cosmos/staking/v1beta1/params' */
evmos: `/cosmos/staking/v1beta1/params`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryParamsResponse is response type for the Query/Params RPC method. */
{
/** params holds all the parameters of this module. */
params: {
/** unbonding_time is the time duration of unbonding. */
unbonding_time: string
/** max_validators is the maximum number of validators. */
max_validators: number
/** max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio). */
max_entries: number
/** historical_entries is the number of historical entries to persist. */
historical_entries: number
/** bond_denom defines the bondable coin denomination. */
bond_denom: string
}
}
evmos: /** QueryParamsResponse is response type for the Query/Params RPC method. */
{
/** params holds all the parameters of this module. */
params: {
/** unbonding_time is the time duration of unbonding. */
unbonding_time: string
/** max_validators is the maximum number of validators. */
max_validators: number
/** max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio). */
max_entries: number
/** historical_entries is the number of historical entries to persist. */
historical_entries: number
/** bond_denom defines the bondable coin denomination. */
bond_denom: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Pool queries a pool by its Id. */
Pool: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/pool/{id}' */
kyve: `/kyve/query/v1beta1/pool/${number}`
/** '/cosmos/staking/v1beta1/pool' */
evmos: `/cosmos/staking/v1beta1/pool`
}
    params: {
        path: {
kyve: {
/** id defines the unique ID of the pool. */
id: number
}
evmos: undefined
}
    
        query: {
kyve: undefined
evmos: undefined
}
        body: {
kyve: undefined
evmos: undefined
}
    }
    response: {
        success: {
kyve: /** QueryPoolResponse is the response type for the Query/Pool RPC method. */
{
/** pool ... */
pool: {
/** id ... */
id: string
/** data ... */
data: {
/** id ... */
id: string
/** name ... */
name: string
/** runtime ... */
runtime: string
/** logo ... */
logo: string
/** config ... */
config: string
/** start_key ... */
start_key: string
/** current_key ... */
current_key: string
/** current_summary ... */
current_summary: string
/** current_index ... */
current_index: string
/** total_bundles ... */
total_bundles: string
/** upload_interval ... */
upload_interval: string
/** operating_cost ... */
operating_cost: string
/** min_delegation ... */
min_delegation: string
/** max_bundle_size ... */
max_bundle_size: string
/** paused ... */
paused: boolean
/** funders ... */
funders: Array<{
/** address ... */
address: string
/** amount ... */
amount: string
}>
/** total_funds ... */
total_funds: string
/** protocol ... */
protocol: {
/** version ... */
version: string
/** binaries ... */
binaries: string
/** last_upgrade ... */
last_upgrade: string
}
/** upgrade_plan ... */
upgrade_plan: {
/** version ... */
version: string
/** binaries ... */
binaries: string
/** scheduled_at ... */
scheduled_at: string
/** duration ... */
duration: string
}
}
/** bundle_proposal ... */
bundle_proposal: {
/** pool_id ... */
pool_id: string
/** storage_id ... */
storage_id: string
/** uploader ... */
uploader: string
/** next_uploader ... */
next_uploader: string
/** data_size ... */
data_size: string
/** bundle_size ... */
bundle_size: string
/** to_key ... */
to_key: string
/** bundle_summary ... */
bundle_summary: string
/** data_hash ... */
data_hash: string
/** updated_at ... */
updated_at: string
/** voters_valid ... */
voters_valid: Array<string>
/** voters_invalid ... */
voters_invalid: Array<string>
/** voters_abstain ... */
voters_abstain: Array<string>
/** from_key ... */
from_key: string
}
/** stakers ... */
stakers: Array<string>
/** total_stake ... */
total_self_delegation: string
/** total_delegation ... */
total_delegation: string
/** status ... */
status: string
}
}
evmos: /** QueryPoolResponse is response type for the Query/Pool RPC method. */
{
/** pool defines the pool info. */
pool: {
not_bonded_tokens: string
bonded_tokens: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Validators queries all validators that match the given status. */
Validators: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/validators' */
axelar: `/cosmos/staking/v1beta1/validators`
/** '/cosmos/staking/v1beta1/validators' */
evmos: `/cosmos/staking/v1beta1/validators`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: {
/** status enables to query for validators matching a given status. */
status: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** status enables to query for validators matching a given status. */
status: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** status enables to query for validators matching a given status. */
status: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** status enables to query for validators matching a given status. */
status: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryValidatorsResponse is response type for the Query/Validators RPC method */
{
/** validators contains all the queried validators. */
validators: Array<{
/** operator_address defines the address of the validator's operator; bech encoded in JSON. */
operator_address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
consensus_pubkey: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** jailed defined whether the validator has been jailed from bonded status or not. */
jailed: boolean
/** status is the validator status (bonded/unbonding/unbonded). */
status: string
/** tokens define the delegated tokens (incl. self-delegation). */
tokens: string
/** delegator_shares defines total shares issued to a validator's delegators. */
delegator_shares: string
/** description defines the description terms for the validator. */
description: {
/** moniker defines a human-readable name for the validator. */
moniker: string
/** identity defines an optional identity signature (ex. UPort or Keybase). */
identity: string
/** website defines an optional website link. */
website: string
/** security_contact defines an optional email for security contact. */
security_contact: string
/** details define other optional details. */
details: string
}
/** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
unbonding_height: string
/** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
unbonding_time: string
/** commission defines the commission parameters. */
commission: {
/** commission_rates defines the initial commission rates to be used for creating a validator. */
commission_rates: {
/** rate is the commission rate charged to delegators, as a fraction. */
rate: string
/** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
max_rate: string
/** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
max_change_rate: string
}
/** update_time is the last time the commission rate was changed. */
update_time: string
}
/** min_self_delegation is the validator's self declared minimum self delegation. */
min_self_delegation: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryValidatorsResponse is response type for the Query/Validators RPC method */
{
/** validators contains all the queried validators. */
validators: Array<{
/** operator_address defines the address of the validator's operator; bech encoded in JSON. */
operator_address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
consensus_pubkey: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** jailed defined whether the validator has been jailed from bonded status or not. */
jailed: boolean
/** status is the validator status (bonded/unbonding/unbonded). */
status: string
/** tokens define the delegated tokens (incl. self-delegation). */
tokens: string
/** delegator_shares defines total shares issued to a validator's delegators. */
delegator_shares: string
/** description defines the description terms for the validator. */
description: {
/** moniker defines a human-readable name for the validator. */
moniker: string
/** identity defines an optional identity signature (ex. UPort or Keybase). */
identity: string
/** website defines an optional website link. */
website: string
/** security_contact defines an optional email for security contact. */
security_contact: string
/** details define other optional details. */
details: string
}
/** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
unbonding_height: string
/** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
unbonding_time: string
/** commission defines the commission parameters. */
commission: {
/** commission_rates defines the initial commission rates to be used for creating a validator. */
commission_rates: {
/** rate is the commission rate charged to delegators, as a fraction. */
rate: string
/** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
max_rate: string
/** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
max_change_rate: string
}
/** update_time is the last time the commission rate was changed. */
update_time: string
}
/** min_self_delegation is the validator's self declared minimum self delegation. */
min_self_delegation: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Validator queries validator info for given validator address. */
Validator: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/validators/{validator_addr}' */
axelar: `/cosmos/staking/v1beta1/validators/${string}`
/** '/cosmos/staking/v1beta1/validators/{validator_addr}' */
evmos: `/cosmos/staking/v1beta1/validators/${string}`
}
    params: {
        path: {
axelar: {
/** validator_addr defines the validator address to query for. */
validator_addr: string
}
evmos: {
/** validator_addr defines the validator address to query for. */
validator_addr: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryValidatorResponse is response type for the Query/Validator RPC method */
{
/** Validator defines a validator, together with the total amount of the
Validator's bond shares and their exchange rate to coins. Slashing results in
a decrease in the exchange rate, allowing correct calculation of future
undelegations without iterating over delegators. When coins are delegated to
this validator, the validator is credited with a delegation whose number of
bond shares is based on the amount of coins delegated divided by the current
exchange rate. Voting power can be calculated as total bonded shares
multiplied by exchange rate. */
validator: {
/** operator_address defines the address of the validator's operator; bech encoded in JSON. */
operator_address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
consensus_pubkey: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** jailed defined whether the validator has been jailed from bonded status or not. */
jailed: boolean
/** status is the validator status (bonded/unbonding/unbonded). */
status: string
/** tokens define the delegated tokens (incl. self-delegation). */
tokens: string
/** delegator_shares defines total shares issued to a validator's delegators. */
delegator_shares: string
/** description defines the description terms for the validator. */
description: {
/** moniker defines a human-readable name for the validator. */
moniker: string
/** identity defines an optional identity signature (ex. UPort or Keybase). */
identity: string
/** website defines an optional website link. */
website: string
/** security_contact defines an optional email for security contact. */
security_contact: string
/** details define other optional details. */
details: string
}
/** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
unbonding_height: string
/** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
unbonding_time: string
/** commission defines the commission parameters. */
commission: {
/** commission_rates defines the initial commission rates to be used for creating a validator. */
commission_rates: {
/** rate is the commission rate charged to delegators, as a fraction. */
rate: string
/** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
max_rate: string
/** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
max_change_rate: string
}
/** update_time is the last time the commission rate was changed. */
update_time: string
}
/** min_self_delegation is the validator's self declared minimum self delegation. */
min_self_delegation: string
}
}
evmos: /** QueryValidatorResponse is response type for the Query/Validator RPC method */
{
/** Validator defines a validator, together with the total amount of the
Validator's bond shares and their exchange rate to coins. Slashing results in
a decrease in the exchange rate, allowing correct calculation of future
undelegations without iterating over delegators. When coins are delegated to
this validator, the validator is credited with a delegation whose number of
bond shares is based on the amount of coins delegated divided by the current
exchange rate. Voting power can be calculated as total bonded shares
multiplied by exchange rate. */
validator: {
/** operator_address defines the address of the validator's operator; bech encoded in JSON. */
operator_address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
consensus_pubkey: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** jailed defined whether the validator has been jailed from bonded status or not. */
jailed: boolean
/** status is the validator status (bonded/unbonding/unbonded). */
status: string
/** tokens define the delegated tokens (incl. self-delegation). */
tokens: string
/** delegator_shares defines total shares issued to a validator's delegators. */
delegator_shares: string
/** description defines the description terms for the validator. */
description: {
/** moniker defines a human-readable name for the validator. */
moniker: string
/** identity defines an optional identity signature (ex. UPort or Keybase). */
identity: string
/** website defines an optional website link. */
website: string
/** security_contact defines an optional email for security contact. */
security_contact: string
/** details define other optional details. */
details: string
}
/** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
unbonding_height: string
/** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
unbonding_time: string
/** commission defines the commission parameters. */
commission: {
/** commission_rates defines the initial commission rates to be used for creating a validator. */
commission_rates: {
/** rate is the commission rate charged to delegators, as a fraction. */
rate: string
/** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
max_rate: string
/** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
max_change_rate: string
}
/** update_time is the last time the commission rate was changed. */
update_time: string
}
/** min_self_delegation is the validator's self declared minimum self delegation. */
min_self_delegation: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ValidatorDelegations queries delegate info for given validator. */
ValidatorDelegations: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/validators/{validator_addr}/delegations' */
axelar: `/cosmos/staking/v1beta1/validators/${string}/delegations`
/** '/cosmos/staking/v1beta1/validators/{validator_addr}/delegations' */
evmos: `/cosmos/staking/v1beta1/validators/${string}/delegations`
}
    params: {
        path: {
axelar: {
/** validator_addr defines the validator address to query for. */
validator_addr: string
}
evmos: {
/** validator_addr defines the validator address to query for. */
validator_addr: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryValidatorDelegationsResponse is response type for the
Query/ValidatorDelegations RPC method */
{
delegation_responses: Array<{
/** Delegation represents the bond with tokens held by an account. It is
owned by one delegator, and is associated with the voting power of one
validator. */
delegation: {
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_address is the bech32-encoded address of the validator. */
validator_address: string
/** shares define the delegation shares received. */
shares: string
}
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
balance: {
denom: string
amount: string
}
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryValidatorDelegationsResponse is response type for the
Query/ValidatorDelegations RPC method */
{
delegation_responses: Array<{
/** Delegation represents the bond with tokens held by an account. It is
owned by one delegator, and is associated with the voting power of one
validator. */
delegation: {
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_address is the bech32-encoded address of the validator. */
validator_address: string
/** shares define the delegation shares received. */
shares: string
}
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
balance: {
denom: string
amount: string
}
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Delegation queries delegate info for given validator delegator pair. */
Delegation: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}' */
axelar: `/cosmos/staking/v1beta1/validators/${string}/delegations/${string}`
/** '/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}' */
evmos: `/cosmos/staking/v1beta1/validators/${string}/delegations/${string}`
}
    params: {
        path: {
axelar: {
/** validator_addr defines the validator address to query for. */
validator_addr: string
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
}
evmos: {
/** validator_addr defines the validator address to query for. */
validator_addr: string
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryDelegationResponse is response type for the Query/Delegation RPC method. */
{
/** DelegationResponse is equivalent to Delegation except that it contains a
balance in addition to shares which is more suitable for client responses. */
delegation_response: {
/** Delegation represents the bond with tokens held by an account. It is
owned by one delegator, and is associated with the voting power of one
validator. */
delegation: {
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_address is the bech32-encoded address of the validator. */
validator_address: string
/** shares define the delegation shares received. */
shares: string
}
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
balance: {
denom: string
amount: string
}
}
}
evmos: /** QueryDelegationResponse is response type for the Query/Delegation RPC method. */
{
/** DelegationResponse is equivalent to Delegation except that it contains a
balance in addition to shares which is more suitable for client responses. */
delegation_response: {
/** Delegation represents the bond with tokens held by an account. It is
owned by one delegator, and is associated with the voting power of one
validator. */
delegation: {
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_address is the bech32-encoded address of the validator. */
validator_address: string
/** shares define the delegation shares received. */
shares: string
}
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
balance: {
denom: string
amount: string
}
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** UnbondingDelegation queries unbonding info for given validator delegator
pair. */
UnbondingDelegation: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation' */
axelar: `/cosmos/staking/v1beta1/validators/${string}/delegations/${string}/unbonding_delegation`
/** '/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation' */
evmos: `/cosmos/staking/v1beta1/validators/${string}/delegations/${string}/unbonding_delegation`
}
    params: {
        path: {
axelar: {
/** validator_addr defines the validator address to query for. */
validator_addr: string
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
}
evmos: {
/** validator_addr defines the validator address to query for. */
validator_addr: string
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** QueryDelegationResponse is response type for the Query/UnbondingDelegation
RPC method. */
{
/** UnbondingDelegation stores all of a single delegator's unbonding bonds
for a single validator in an time-ordered list. */
unbond: {
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_address is the bech32-encoded address of the validator. */
validator_address: string
/** entries are the unbonding delegation entries. */
entries: Array<{
/** creation_height is the height which the unbonding took place. */
creation_height: string
/** completion_time is the unix time for unbonding completion. */
completion_time: string
/** initial_balance defines the tokens initially scheduled to receive at completion. */
initial_balance: string
/** balance defines the tokens to receive at completion. */
balance: string
}>
}
}
evmos: /** QueryDelegationResponse is response type for the Query/UnbondingDelegation
RPC method. */
{
/** UnbondingDelegation stores all of a single delegator's unbonding bonds
for a single validator in an time-ordered list. */
unbond: {
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_address is the bech32-encoded address of the validator. */
validator_address: string
/** entries are the unbonding delegation entries. */
entries: Array<{
/** creation_height is the height which the unbonding took place. */
creation_height: string
/** completion_time is the unix time for unbonding completion. */
completion_time: string
/** initial_balance defines the tokens initially scheduled to receive at completion. */
initial_balance: string
/** balance defines the tokens to receive at completion. */
balance: string
}>
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ValidatorUnbondingDelegations queries unbonding delegations of a validator. */
ValidatorUnbondingDelegations: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations' */
axelar: `/cosmos/staking/v1beta1/validators/${string}/unbonding_delegations`
/** '/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations' */
evmos: `/cosmos/staking/v1beta1/validators/${string}/unbonding_delegations`
}
    params: {
        path: {
axelar: {
/** validator_addr defines the validator address to query for. */
validator_addr: string
}
evmos: {
/** validator_addr defines the validator address to query for. */
validator_addr: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryValidatorUnbondingDelegationsResponse is response type for the
Query/ValidatorUnbondingDelegations RPC method. */
{
unbonding_responses: Array<{
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_address is the bech32-encoded address of the validator. */
validator_address: string
/** entries are the unbonding delegation entries. */
entries: Array<{
/** creation_height is the height which the unbonding took place. */
creation_height: string
/** completion_time is the unix time for unbonding completion. */
completion_time: string
/** initial_balance defines the tokens initially scheduled to receive at completion. */
initial_balance: string
/** balance defines the tokens to receive at completion. */
balance: string
}>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** QueryValidatorUnbondingDelegationsResponse is response type for the
Query/ValidatorUnbondingDelegations RPC method. */
{
unbonding_responses: Array<{
/** delegator_address is the bech32-encoded address of the delegator. */
delegator_address: string
/** validator_address is the bech32-encoded address of the validator. */
validator_address: string
/** entries are the unbonding delegation entries. */
entries: Array<{
/** creation_height is the height which the unbonding took place. */
creation_height: string
/** completion_time is the unix time for unbonding completion. */
completion_time: string
/** initial_balance defines the tokens initially scheduled to receive at completion. */
initial_balance: string
/** balance defines the tokens to receive at completion. */
balance: string
}>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Simulate simulates executing a transaction for estimating gas usage. */
Simulate: {
    method: 'post'
    endpoint: {
/** '/cosmos/tx/v1beta1/simulate' */
evmos: `/cosmos/tx/v1beta1/simulate`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
'body': unknown
}
}
        body: {
evmos: {
'body': unknown
}
}
    }
    response: {
        success: {
evmos: /** SimulateResponse is the response type for the
Service.SimulateRPC method. */
{
/** gas_info is the information about gas used in the simulation. */
gas_info: {
/** GasWanted is the maximum units of work we allow this tx to perform. */
gas_wanted: string
/** GasUsed is the amount of gas actually consumed. */
gas_used: string
}
/** result is the result of the simulation. */
result: {
/** Data is any data returned from message or handler execution. It MUST be
length prefixed in order to separate data from multiple message executions. */
data: string
/** Log contains the log information from message or handler execution. */
log: string
/** Events contains a slice of Event objects that were emitted during message
or handler execution. */
events: Array<{
type: string
attributes: Array<{
key: string
value: string
index: boolean
}>
}>
}
}
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** GetTxsEvent fetches txs by event. */
GetTxsEvent: {
    method: 'get'
    endpoint: {
/** '/cosmos/tx/v1beta1/txs' */
evmos: `/cosmos/tx/v1beta1/txs`
}
    params: {
        path: {
evmos: undefined
}
    
        query: {
evmos: {
/** events is the list of transaction event type. */
events: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
/**  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.
 - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order
 - ORDER_BY_DESC: ORDER_BY_DESC defines descending order */
order_by: string
}
}
        body: {
evmos: {
/** events is the list of transaction event type. */
events: string
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
/**  - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.
 - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order
 - ORDER_BY_DESC: ORDER_BY_DESC defines descending order */
order_by: string
}
}
    }
    response: {
        success: {
evmos: unknown
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** GetBlockWithTxs fetches a block with decoded txs. */
GetBlockWithTxs: {
    method: 'get'
    endpoint: {
/** '/cosmos/tx/v1beta1/txs/block/{height}' */
evmos: `/cosmos/tx/v1beta1/txs/block/${number}`
}
    params: {
        path: {
evmos: {
/** height is the height of the block to query. */
height: number
}
}
    
        query: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
evmos: unknown
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** GetTx fetches a tx by hash. */
GetTx: {
    method: 'get'
    endpoint: {
/** '/cosmos/tx/v1beta1/txs/{hash}' */
evmos: `/cosmos/tx/v1beta1/txs/${string}`
}
    params: {
        path: {
evmos: {
/** hash is the tx hash to query, encoded as a hex string. */
hash: string
}
}
    
        query: {
evmos: undefined
}
        body: {
evmos: undefined
}
    }
    response: {
        success: {
evmos: unknown
}
        error: {
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** GetLatestBlock returns the latest block. */
GetLatestBlock: {
    method: 'get'
    endpoint: {
/** '/cosmos/base/tendermint/v1beta1/blocks/latest' */
axelar: `/cosmos/base/tendermint/v1beta1/blocks/latest`
/** '/cosmos/base/tendermint/v1beta1/blocks/latest' */
evmos: `/cosmos/base/tendermint/v1beta1/blocks/latest`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method. */
{
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
block: {
/** Header defines the structure of a Tendermint block header. */
header: {
/** basic block info */
version: {
block: string
app: string
}
chain_id: string
height: string
time: string
/** BlockID */
last_block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
/** hashes of block data */
last_commit_hash: string
data_hash: string
/** hashes from the app output from the prev block */
validators_hash: string
next_validators_hash: string
consensus_hash: string
app_hash: string
last_results_hash: string
/** consensus info */
evidence_hash: string
proposer_address: string
}
/** Data contains the set of transactions included in the block */
data: {
/** Txs that will be applied by state @ block.Height+1.
NOTE: not all txs here are valid.  We're just agreeing on the order first.
This means that block.AppHash does not include these txs. */
txs: Array<string>
}
evidence: {
evidence: Array<{
/** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
duplicate_vote_evidence: {
/** Vote represents a prevote, precommit, or commit vote from validators for
consensus. */
vote_a: {
/** SignedMsgType is a type of signed message in the consensus.

 - SIGNED_MSG_TYPE_PREVOTE: Votes
 - SIGNED_MSG_TYPE_PROPOSAL: Proposals */
type: string
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
timestamp: string
validator_address: string
validator_index: number
signature: string
}
/** Vote represents a prevote, precommit, or commit vote from validators for
consensus. */
vote_b: {
/** SignedMsgType is a type of signed message in the consensus.

 - SIGNED_MSG_TYPE_PREVOTE: Votes
 - SIGNED_MSG_TYPE_PROPOSAL: Proposals */
type: string
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
timestamp: string
validator_address: string
validator_index: number
signature: string
}
total_voting_power: string
validator_power: string
timestamp: string
}
/** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
light_client_attack_evidence: {
conflicting_block: {
signed_header: {
/** Header defines the structure of a Tendermint block header. */
header: {
/** basic block info */
version: {
block: string
app: string
}
chain_id: string
height: string
time: string
/** BlockID */
last_block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
/** hashes of block data */
last_commit_hash: string
data_hash: string
/** hashes from the app output from the prev block */
validators_hash: string
next_validators_hash: string
consensus_hash: string
app_hash: string
last_results_hash: string
/** consensus info */
evidence_hash: string
proposer_address: string
}
/** Commit contains the evidence that a block was committed by a set of validators. */
commit: {
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
signatures: Array<{
/** BlockIdFlag indicates which BlcokID the signature is for */
block_id_flag: string
validator_address: string
timestamp: string
signature: string
}>
}
}
validator_set: {
validators: Array<{
address: string
/** PublicKey defines the keys available for use with Tendermint Validators */
pub_key: {
ed25519: string
secp256k1: string
}
voting_power: string
proposer_priority: string
}>
proposer: {
address: string
/** PublicKey defines the keys available for use with Tendermint Validators */
pub_key: {
ed25519: string
secp256k1: string
}
voting_power: string
proposer_priority: string
}
total_voting_power: string
}
}
common_height: string
byzantine_validators: Array<{
address: string
/** PublicKey defines the keys available for use with Tendermint Validators */
pub_key: {
ed25519: string
secp256k1: string
}
voting_power: string
proposer_priority: string
}>
total_voting_power: string
timestamp: string
}
}>
}
/** Commit contains the evidence that a block was committed by a set of validators. */
last_commit: {
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
signatures: Array<{
/** BlockIdFlag indicates which BlcokID the signature is for */
block_id_flag: string
validator_address: string
timestamp: string
signature: string
}>
}
}
}
evmos: /** GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method. */
{
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
block: {
/** Header defines the structure of a Tendermint block header. */
header: {
/** basic block info */
version: {
block: string
app: string
}
chain_id: string
height: string
time: string
/** BlockID */
last_block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
/** hashes of block data */
last_commit_hash: string
data_hash: string
/** hashes from the app output from the prev block */
validators_hash: string
next_validators_hash: string
consensus_hash: string
app_hash: string
last_results_hash: string
/** consensus info */
evidence_hash: string
proposer_address: string
}
/** Data contains the set of transactions included in the block */
data: {
/** Txs that will be applied by state @ block.Height+1.
NOTE: not all txs here are valid.  We're just agreeing on the order first.
This means that block.AppHash does not include these txs. */
txs: Array<string>
}
evidence: {
evidence: Array<{
/** DuplicateVoteEvidence contains evidence of a validator signed two conflicting
votes. */
duplicate_vote_evidence: {
/** Vote represents a prevote, precommit, or commit vote from validators for
consensus. */
vote_a: {
/** SignedMsgType is a type of signed message in the consensus.

 - SIGNED_MSG_TYPE_PREVOTE: Votes
 - SIGNED_MSG_TYPE_PROPOSAL: Proposals */
type: string
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
timestamp: string
validator_address: string
validator_index: number
signature: string
}
/** Vote represents a prevote, precommit, or commit vote from validators for
consensus. */
vote_b: {
/** SignedMsgType is a type of signed message in the consensus.

 - SIGNED_MSG_TYPE_PREVOTE: Votes
 - SIGNED_MSG_TYPE_PROPOSAL: Proposals */
type: string
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
timestamp: string
validator_address: string
validator_index: number
signature: string
}
total_voting_power: string
validator_power: string
timestamp: string
}
/** LightClientAttackEvidence contains evidence of a set of validators attempting
to mislead a light client. */
light_client_attack_evidence: {
conflicting_block: {
signed_header: {
/** Header defines the structure of a Tendermint block header. */
header: {
/** basic block info */
version: {
block: string
app: string
}
chain_id: string
height: string
time: string
/** BlockID */
last_block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
/** hashes of block data */
last_commit_hash: string
data_hash: string
/** hashes from the app output from the prev block */
validators_hash: string
next_validators_hash: string
consensus_hash: string
app_hash: string
last_results_hash: string
/** consensus info */
evidence_hash: string
proposer_address: string
}
/** Commit contains the evidence that a block was committed by a set of
validators. */
commit: {
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
signatures: Array<{
/** BlockIdFlag indicates which BlcokID the signature is for */
block_id_flag: string
validator_address: string
timestamp: string
signature: string
}>
}
}
validator_set: {
validators: Array<{
address: string
/** PublicKey defines the keys available for use with Tendermint Validators */
pub_key: {
ed25519: string
secp256k1: string
}
voting_power: string
proposer_priority: string
}>
proposer: {
address: string
/** PublicKey defines the keys available for use with Tendermint Validators */
pub_key: {
ed25519: string
secp256k1: string
}
voting_power: string
proposer_priority: string
}
total_voting_power: string
}
}
common_height: string
byzantine_validators: Array<{
address: string
/** PublicKey defines the keys available for use with Tendermint Validators */
pub_key: {
ed25519: string
secp256k1: string
}
voting_power: string
proposer_priority: string
}>
total_voting_power: string
timestamp: string
}
}>
}
/** Commit contains the evidence that a block was committed by a set of
validators. */
last_commit: {
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
signatures: Array<{
/** BlockIdFlag indicates which BlcokID the signature is for */
block_id_flag: string
validator_address: string
timestamp: string
signature: string
}>
}
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** GetBlockByHeight queries block for given height. */
GetBlockByHeight: {
    method: 'get'
    endpoint: {
/** '/cosmos/base/tendermint/v1beta1/blocks/{height}' */
axelar: `/cosmos/base/tendermint/v1beta1/blocks/${number}`
/** '/cosmos/base/tendermint/v1beta1/blocks/{height}' */
evmos: `/cosmos/base/tendermint/v1beta1/blocks/${number}`
}
    params: {
        path: {
axelar: {
height: number
}
evmos: {
height: number
}
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method. */
{
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
block: {
/** Header defines the structure of a Tendermint block header. */
header: {
/** basic block info */
version: {
block: string
app: string
}
chain_id: string
height: string
time: string
/** BlockID */
last_block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
/** hashes of block data */
last_commit_hash: string
data_hash: string
/** hashes from the app output from the prev block */
validators_hash: string
next_validators_hash: string
consensus_hash: string
app_hash: string
last_results_hash: string
/** consensus info */
evidence_hash: string
proposer_address: string
}
/** Data contains the set of transactions included in the block */
data: {
/** Txs that will be applied by state @ block.Height+1.
NOTE: not all txs here are valid.  We're just agreeing on the order first.
This means that block.AppHash does not include these txs. */
txs: Array<string>
}
evidence: {
evidence: Array<{
/** DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes. */
duplicate_vote_evidence: {
/** Vote represents a prevote, precommit, or commit vote from validators for
consensus. */
vote_a: {
/** SignedMsgType is a type of signed message in the consensus.

 - SIGNED_MSG_TYPE_PREVOTE: Votes
 - SIGNED_MSG_TYPE_PROPOSAL: Proposals */
type: string
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
timestamp: string
validator_address: string
validator_index: number
signature: string
}
/** Vote represents a prevote, precommit, or commit vote from validators for
consensus. */
vote_b: {
/** SignedMsgType is a type of signed message in the consensus.

 - SIGNED_MSG_TYPE_PREVOTE: Votes
 - SIGNED_MSG_TYPE_PROPOSAL: Proposals */
type: string
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
timestamp: string
validator_address: string
validator_index: number
signature: string
}
total_voting_power: string
validator_power: string
timestamp: string
}
/** LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client. */
light_client_attack_evidence: {
conflicting_block: {
signed_header: {
/** Header defines the structure of a Tendermint block header. */
header: {
/** basic block info */
version: {
block: string
app: string
}
chain_id: string
height: string
time: string
/** BlockID */
last_block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
/** hashes of block data */
last_commit_hash: string
data_hash: string
/** hashes from the app output from the prev block */
validators_hash: string
next_validators_hash: string
consensus_hash: string
app_hash: string
last_results_hash: string
/** consensus info */
evidence_hash: string
proposer_address: string
}
/** Commit contains the evidence that a block was committed by a set of validators. */
commit: {
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
signatures: Array<{
/** BlockIdFlag indicates which BlcokID the signature is for */
block_id_flag: string
validator_address: string
timestamp: string
signature: string
}>
}
}
validator_set: {
validators: Array<{
address: string
/** PublicKey defines the keys available for use with Tendermint Validators */
pub_key: {
ed25519: string
secp256k1: string
}
voting_power: string
proposer_priority: string
}>
proposer: {
address: string
/** PublicKey defines the keys available for use with Tendermint Validators */
pub_key: {
ed25519: string
secp256k1: string
}
voting_power: string
proposer_priority: string
}
total_voting_power: string
}
}
common_height: string
byzantine_validators: Array<{
address: string
/** PublicKey defines the keys available for use with Tendermint Validators */
pub_key: {
ed25519: string
secp256k1: string
}
voting_power: string
proposer_priority: string
}>
total_voting_power: string
timestamp: string
}
}>
}
/** Commit contains the evidence that a block was committed by a set of validators. */
last_commit: {
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
signatures: Array<{
/** BlockIdFlag indicates which BlcokID the signature is for */
block_id_flag: string
validator_address: string
timestamp: string
signature: string
}>
}
}
}
evmos: /** GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method. */
{
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
block: {
/** Header defines the structure of a Tendermint block header. */
header: {
/** basic block info */
version: {
block: string
app: string
}
chain_id: string
height: string
time: string
/** BlockID */
last_block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
/** hashes of block data */
last_commit_hash: string
data_hash: string
/** hashes from the app output from the prev block */
validators_hash: string
next_validators_hash: string
consensus_hash: string
app_hash: string
last_results_hash: string
/** consensus info */
evidence_hash: string
proposer_address: string
}
/** Data contains the set of transactions included in the block */
data: {
/** Txs that will be applied by state @ block.Height+1.
NOTE: not all txs here are valid.  We're just agreeing on the order first.
This means that block.AppHash does not include these txs. */
txs: Array<string>
}
evidence: {
evidence: Array<{
/** DuplicateVoteEvidence contains evidence of a validator signed two conflicting
votes. */
duplicate_vote_evidence: {
/** Vote represents a prevote, precommit, or commit vote from validators for
consensus. */
vote_a: {
/** SignedMsgType is a type of signed message in the consensus.

 - SIGNED_MSG_TYPE_PREVOTE: Votes
 - SIGNED_MSG_TYPE_PROPOSAL: Proposals */
type: string
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
timestamp: string
validator_address: string
validator_index: number
signature: string
}
/** Vote represents a prevote, precommit, or commit vote from validators for
consensus. */
vote_b: {
/** SignedMsgType is a type of signed message in the consensus.

 - SIGNED_MSG_TYPE_PREVOTE: Votes
 - SIGNED_MSG_TYPE_PROPOSAL: Proposals */
type: string
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
timestamp: string
validator_address: string
validator_index: number
signature: string
}
total_voting_power: string
validator_power: string
timestamp: string
}
/** LightClientAttackEvidence contains evidence of a set of validators attempting
to mislead a light client. */
light_client_attack_evidence: {
conflicting_block: {
signed_header: {
/** Header defines the structure of a Tendermint block header. */
header: {
/** basic block info */
version: {
block: string
app: string
}
chain_id: string
height: string
time: string
/** BlockID */
last_block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
/** hashes of block data */
last_commit_hash: string
data_hash: string
/** hashes from the app output from the prev block */
validators_hash: string
next_validators_hash: string
consensus_hash: string
app_hash: string
last_results_hash: string
/** consensus info */
evidence_hash: string
proposer_address: string
}
/** Commit contains the evidence that a block was committed by a set of
validators. */
commit: {
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
signatures: Array<{
/** BlockIdFlag indicates which BlcokID the signature is for */
block_id_flag: string
validator_address: string
timestamp: string
signature: string
}>
}
}
validator_set: {
validators: Array<{
address: string
/** PublicKey defines the keys available for use with Tendermint Validators */
pub_key: {
ed25519: string
secp256k1: string
}
voting_power: string
proposer_priority: string
}>
proposer: {
address: string
/** PublicKey defines the keys available for use with Tendermint Validators */
pub_key: {
ed25519: string
secp256k1: string
}
voting_power: string
proposer_priority: string
}
total_voting_power: string
}
}
common_height: string
byzantine_validators: Array<{
address: string
/** PublicKey defines the keys available for use with Tendermint Validators */
pub_key: {
ed25519: string
secp256k1: string
}
voting_power: string
proposer_priority: string
}>
total_voting_power: string
timestamp: string
}
}>
}
/** Commit contains the evidence that a block was committed by a set of
validators. */
last_commit: {
height: string
round: number
/** BlockID */
block_id: {
hash: string
/** PartsetHeader */
part_set_header: {
total: number
hash: string
}
}
signatures: Array<{
/** BlockIdFlag indicates which BlcokID the signature is for */
block_id_flag: string
validator_address: string
timestamp: string
signature: string
}>
}
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** GetNodeInfo queries the current node info. */
GetNodeInfo: {
    method: 'get'
    endpoint: {
/** '/cosmos/base/tendermint/v1beta1/node_info' */
axelar: `/cosmos/base/tendermint/v1beta1/node_info`
/** '/cosmos/base/tendermint/v1beta1/node_info' */
evmos: `/cosmos/base/tendermint/v1beta1/node_info`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** GetNodeInfoResponse is the request type for the Query/GetNodeInfo RPC method. */
{
default_node_info: {
protocol_version: {
p2p: string
block: string
app: string
}
default_node_id: string
listen_addr: string
network: string
version: string
channels: string
moniker: string
other: {
tx_index: string
rpc_address: string
}
}
/** VersionInfo is the type for the GetNodeInfoResponse message. */
application_version: {
name: string
app_name: string
version: string
git_commit: string
build_tags: string
go_version: string
build_deps: Array<{
/** module path */
path: string
/** module version */
version: string
/** checksum */
sum: string
}>
/** Since: cosmos-sdk 0.43 */
cosmos_sdk_version: string
}
}
evmos: /** GetNodeInfoResponse is the request type for the Query/GetNodeInfo RPC method. */
{
default_node_info: {
protocol_version: {
p2p: string
block: string
app: string
}
default_node_id: string
listen_addr: string
network: string
version: string
channels: string
moniker: string
other: {
tx_index: string
rpc_address: string
}
}
/** VersionInfo is the type for the GetNodeInfoResponse message. */
application_version: {
name: string
app_name: string
version: string
git_commit: string
build_tags: string
go_version: string
build_deps: Array<{
/** module path */
path: string
/** module version */
version: string
/** checksum */
sum: string
}>
/** Since: cosmos-sdk 0.43 */
cosmos_sdk_version: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** GetSyncing queries node syncing. */
GetSyncing: {
    method: 'get'
    endpoint: {
/** '/cosmos/base/tendermint/v1beta1/syncing' */
axelar: `/cosmos/base/tendermint/v1beta1/syncing`
/** '/cosmos/base/tendermint/v1beta1/syncing' */
evmos: `/cosmos/base/tendermint/v1beta1/syncing`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: undefined
evmos: undefined
}
        body: {
axelar: undefined
evmos: undefined
}
    }
    response: {
        success: {
axelar: /** GetSyncingResponse is the response type for the Query/GetSyncing RPC method. */
{
syncing: boolean
}
evmos: /** GetSyncingResponse is the response type for the Query/GetSyncing RPC method. */
{
syncing: boolean
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** GetLatestValidatorSet queries latest validator-set. */
GetLatestValidatorSet: {
    method: 'get'
    endpoint: {
/** '/cosmos/base/tendermint/v1beta1/validatorsets/latest' */
axelar: `/cosmos/base/tendermint/v1beta1/validatorsets/latest`
/** '/cosmos/base/tendermint/v1beta1/validatorsets/latest' */
evmos: `/cosmos/base/tendermint/v1beta1/validatorsets/latest`
}
    params: {
        path: {
axelar: undefined
evmos: undefined
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method. */
{
block_height: string
validators: Array<{
address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
pub_key: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
voting_power: string
proposer_priority: string
}>
/** pagination defines an pagination for the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method. */
{
block_height: string
validators: Array<{
address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
pub_key: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
voting_power: string
proposer_priority: string
}>
/** pagination defines an pagination for the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** GetValidatorSetByHeight queries validator-set at a given height. */
GetValidatorSetByHeight: {
    method: 'get'
    endpoint: {
/** '/cosmos/base/tendermint/v1beta1/validatorsets/{height}' */
axelar: `/cosmos/base/tendermint/v1beta1/validatorsets/${number}`
/** '/cosmos/base/tendermint/v1beta1/validatorsets/{height}' */
evmos: `/cosmos/base/tendermint/v1beta1/validatorsets/${number}`
}
    params: {
        path: {
axelar: {
height: number
}
evmos: {
height: number
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
evmos: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method. */
{
block_height: string
validators: Array<{
address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
pub_key: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
voting_power: string
proposer_priority: string
}>
/** pagination defines an pagination for the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
evmos: /** GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method. */
{
block_height: string
validators: Array<{
address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
pub_key: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
voting_power: string
proposer_priority: string
}>
/** pagination defines an pagination for the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
evmos: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Parameters queries the parameters of the module. */
BundlesParams: {
    method: 'get'
    endpoint: {
/** '/kyve/bundles/v1beta1/params' */
kyve: `/kyve/bundles/v1beta1/params`
}
    params: {
        path: {
kyve: undefined
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryParamsResponse is response type for the Query/Params RPC method. */
{
/** params holds all the parameters of this module. */
params: {
/** upload_timeout ... */
upload_timeout: string
/** storage_cost ... */
storage_cost: string
/** network_fee ... */
network_fee: string
/** max_points ... */
max_points: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Parameters queries the parameters of the module. */
DelegationParams: {
    method: 'get'
    endpoint: {
/** '/kyve/delegation/v1beta1/params' */
kyve: `/kyve/delegation/v1beta1/params`
}
    params: {
        path: {
kyve: undefined
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryParamsResponse is response type for the Query/Params RPC method. */
{
/** params holds all the parameters of this module. */
params: {
/** unbonding_delegation_time ... */
unbonding_delegation_time: string
/** unbonding_delegation_time ... */
redelegation_cooldown: string
/** unbonding_delegation_time ... */
redelegation_max_amount: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Slashes ... */
Slashes: {
    method: 'get'
    endpoint: {
/** '/kyve/delegation/v1beta1/slashes' */
kyve: `/kyve/delegation/v1beta1/slashes`
}
    params: {
        path: {
kyve: undefined
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryParamsResponse is response type for the Query/Params RPC method. */
{
/** slashes ... */
slashes: Array<{
/** staker ... */
staker: string
/** k_index ... */
k_index: string
/** fraction ... */
fraction: string
}>
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Parameters queries the parameters of the module. */
FeesParams: {
    method: 'get'
    endpoint: {
/** '/kyve/fees/v1beta1/params' */
kyve: `/kyve/fees/v1beta1/params`
}
    params: {
        path: {
kyve: undefined
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryParamsResponse is response type for the Query/Params RPC method. */
{
/** params holds all the parameters of this module. */
params: {
/** min_gas_price defines the minimum gas price value for all transactions. */
min_gas_price: string
/** burn_ratio defines the ratio of transaction fees burnt. */
burn_ratio: string
/** gas_adjustments ... */
gas_adjustments: Array<{
/** type ... */
type: string
/** amount ... */
amount: string
}>
/** gas_refunds ... */
gas_refunds: Array<{
/** type ... */
type: string
/** fraction ... */
fraction: string
}>
/** min_initial_deposit_ratio ... */
min_initial_deposit_ratio: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** AccountAssets returns an overview of the sum of all balances for a given user. e.g. balance, staking, funding, etc. */
AccountAssets: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/account_assets/{address}' */
kyve: `/kyve/query/v1beta1/account_assets/${string}`
}
    params: {
        path: {
kyve: {
/** address ... */
address: string
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryAccountAssetsResponse is the response type for the Query/AccountAssets RPC method. */
{
/** balance ... */
balance: string
/** protocol_staking ... */
protocol_self_delegation: string
/** protocol_staking_unbonding */
protocol_self_delegation_unbonding: string
/** protocol_delegation ... */
protocol_delegation: string
/** protocol_delegation_unbonding */
protocol_delegation_unbonding: string
/** protocol_rewards ... */
protocol_rewards: string
/** protocol_funding ... */
protocol_funding: string
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** AccountDelegationUnbondings ... */
AccountDelegationUnbondings: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/account_delegation_unbondings/{address}' */
kyve: `/kyve/query/v1beta1/account_delegation_unbondings/${string}`
}
    params: {
        path: {
kyve: {
/** address ... */
address: string
}
}
    
        query: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
kyve: /** QueryAccountAssetsResponse is the response type for the Query/AccountAssets RPC method. */
{
/** balance ... */
unbondings: Array<{
/** amount */
amount: string
/** creation_time */
creation_time: string
/** staker */
staker: {
/** address of the staker */
address: string
/** StakerMetadata contains static information for a staker */
metadata: {
/** commission is the percentage of the rewards that will
get transferred to the staker before the remaining
rewards are split across all delegators */
commission: string
/** moniker is a human-readable name for displaying
the staker in the UI */
moniker: string
/** website is a https-link to the website of the staker */
website: string
/** logo is a link to an image file (like jpg or png) */
logo: string
/** CommissionChangeEntry shows when the old commission
of a staker will change to the new commission */
pending_commission_change: {
/** commission is the new commission that will
become active once the change-time is over */
commission: string
/** creation_date is the UNIX-timestamp (in seconds)
of when the entry was created. */
creation_date: string
}
}
/** amount the staker has delegated to himself */
self_delegation: string
/** unbonding_amount is the amount the staker is currently unbonding
from the self-delegation.
This amount can be larger than `amount` when the staker
got slashed during unbonding. However, at the end of
the unbonding period this amount is double checked with the
remaining amount. */
self_delegation_unbonding: string
/** total_delegation returns the sum of all $KYVE users
have delegated to this staker */
total_delegation: string
/** delegator_count is the total number of individual
delegator addresses for that user. */
delegator_count: string
/** pools is a list of all pools the staker is currently
participating, i.e. allowed to vote and upload data. */
pools: Array<{
/** pool contains useful information about the pool */
pool: {
/** id is the ID of the pool */
id: string
/** name of the pool */
name: string
/** runtime for the protocol nodes
like evm, bitcoin, etc. */
runtime: string
/** logo of the pool */
logo: string
/** operating_cost is the base payout for each bundle reward */
operating_cost: string
/** upload_interval is the interval bundles get created */
upload_interval: string
/** total_funds of the pool. If the pool runs
out of funds no more bundles will be produced */
total_funds: string
/** total_delegation of the pool */
total_delegation: string
/** status of the pool if pool is able
to produce bundles, etc. */
status: string
}
/** points indicates if the staker is inactive
If the staker misses a vote, a point is added.
After 5 points the staker is removed from
the stakers set. */
points: string
/** is_leaving indicates if a user has scheduled a
a PoolLeave entry. After the leave-time is over
the staker will no longer participate in that pool */
is_leaving: boolean
/** Valaddress is the address which is authorized to vote
and submit bundles. If the server gets compromised
the staker can just change the valaddress. */
valaddress: string
/** balance is the valaddress account balance and indicates
whether or not the valaccount needs additional funds to
pay for gas fees */
balance: string
}>
}
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently. It will be empty if
there are no more results. */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** AccountFundedList returns all pools the given user has funded into. */
AccountFundedList: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/account_funded_list/{address}' */
kyve: `/kyve/query/v1beta1/account_funded_list/${string}`
}
    params: {
        path: {
kyve: {
/** address ... */
address: string
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryAccountFundedListResponse is the response type for the Query/AccountFundedList RPC method. */
{
/** funded ... */
funded: Array<{
/** amount ... */
amount: string
/** BasicPool contains the necessary properties need for a pool
to be displayed in the UI */
pool: {
/** id is the ID of the pool */
id: string
/** name of the pool */
name: string
/** runtime for the protocol nodes
like evm, bitcoin, etc. */
runtime: string
/** logo of the pool */
logo: string
/** operating_cost is the base payout for each bundle reward */
operating_cost: string
/** upload_interval is the interval bundles get created */
upload_interval: string
/** total_funds of the pool. If the pool runs
out of funds no more bundles will be produced */
total_funds: string
/** total_delegation of the pool */
total_delegation: string
/** status of the pool if pool is able
to produce bundles, etc. */
status: string
}
}>
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** AccountRedelegation ... */
AccountRedelegation: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/account_redelegation/{address}' */
kyve: `/kyve/query/v1beta1/account_redelegation/${string}`
}
    params: {
        path: {
kyve: {
/** address ... */
address: string
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryAccountDelegationListRequest is the response type for the Query/AccountDelegationList RPC method. */
{
/** redelegation_cooldown_entries ... */
redelegation_cooldown_entries: Array<{
/** creation_date ... */
creation_date: string
/** finish_date ... */
finish_date: string
}>
/** availableSlots ... */
available_slots: string
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** CanPropose ... */
CanPropose: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/can_propose/{pool_id}/{staker}/{proposer}/{from_index}' */
kyve: `/kyve/query/v1beta1/can_propose/${number}/${string}/${string}/${number}`
}
    params: {
        path: {
kyve: {
/** pool_id defines the unique ID of the pool. */
pool_id: number
/** staker ... */
staker: string
/** proposer ... */
proposer: string
/** from_index ... */
from_index: number
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryCanProposeResponse is the response type for the Query/CanPropose RPC method. */
{
/** possible ... */
possible: boolean
/** reason ... */
reason: string
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** CanValidate ... */
CanValidate: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/can_validate/{pool_id}/{valaddress}' */
kyve: `/kyve/query/v1beta1/can_validate/${number}/${string}`
}
    params: {
        path: {
kyve: {
/** pool_id defines the unique ID of the pool. */
pool_id: number
/** valaddress ... */
valaddress: string
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryCanProposeResponse is the response type for the Query/CanPropose RPC method. */
{
/** possible ... */
possible: boolean
/** reason ... */
reason: string
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** CanVote checks if voter on pool can still vote for the given bundle */
CanVote: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/can_vote/{pool_id}/{staker}/{voter}/{storage_id}' */
kyve: `/kyve/query/v1beta1/can_vote/${number}/${string}/${string}/${string}`
}
    params: {
        path: {
kyve: {
/** pool_id defines the unique ID of the pool. */
pool_id: number
/** staker ... */
staker: string
/** voter ... */
voter: string
/** storage_id ... */
storage_id: string
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryCanVoteResponse is the response type for the Query/CanVote RPC method. */
{
/** possible ... */
possible: boolean
/** reason ... */
reason: string
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** CurrentVoteStatus ... */
CurrentVoteStatus: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/current_vote_status/{pool_id}' */
kyve: `/kyve/query/v1beta1/current_vote_status/${number}`
}
    params: {
        path: {
kyve: {
/** pool_id ... */
pool_id: number
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryCurrentVoteStatusResponse is the response type for the Query/Staker RPC method. */
{
/** valid ... */
valid: string
/** invalid ... */
invalid: string
/** abstain ... */
abstain: string
/** total ... */
total: string
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** FinalizedBundle ... */
FinalizedBundle: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/finalized_bundle/{pool_id}/{id}' */
kyve: `/kyve/query/v1beta1/finalized_bundle/${number}/${number}`
}
    params: {
        path: {
kyve: {
/** pool_id ... */
pool_id: number
/** id ... */
id: number
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryFinalizedBundleResponse is the response type for the Query/Staker RPC method. */
{
/** finalized_bundle ... */
finalized_bundle: {
/** pool_id ... */
pool_id: string
/** id ... */
id: string
/** storage_id ... */
storage_id: string
/** uploader ... */
uploader: string
/** from_index ... */
from_index: string
/** to_index ... */
to_index: string
/** to_key ... */
to_key: string
/** bundle_summary ... */
bundle_summary: string
/** bundle_hash ... */
data_hash: string
/** finalized_at ... */
finalized_at: string
/** from_key ... */
from_key: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Queries the bundle which contains the data given height */
FinalizedBundlesByHeight: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/finalized_bundle_by_height/{pool_id}/{height}' */
kyve: `/kyve/query/v1beta1/finalized_bundle_by_height/${number}/${number}`
}
    params: {
        path: {
kyve: {
/** pool_id ... */
pool_id: number
/** id ... */
height: number
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryFinalizedBundleResponse is the response type for the Query/Staker RPC method. */
{
/** finalized_bundle ... */
finalized_bundle: {
/** pool_id ... */
pool_id: string
/** id ... */
id: string
/** storage_id ... */
storage_id: string
/** uploader ... */
uploader: string
/** from_index ... */
from_index: string
/** to_index ... */
to_index: string
/** to_key ... */
to_key: string
/** bundle_summary ... */
bundle_summary: string
/** bundle_hash ... */
data_hash: string
/** finalized_at ... */
finalized_at: string
/** from_key ... */
from_key: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** StorageID -> single */
FinalizedBundleByStorageId: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/finalized_bundle_by_storage_id/{storage_id}' */
kyve: `/kyve/query/v1beta1/finalized_bundle_by_storage_id/${string}`
}
    params: {
        path: {
kyve: {
/** pool_id ... */
storage_id: string
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryFinalizedBundleResponse is the response type for the Query/Staker RPC method. */
{
/** finalized_bundle ... */
finalized_bundle: {
/** pool_id ... */
pool_id: string
/** id ... */
id: string
/** storage_id ... */
storage_id: string
/** uploader ... */
uploader: string
/** from_index ... */
from_index: string
/** to_index ... */
to_index: string
/** to_key ... */
to_key: string
/** bundle_summary ... */
bundle_summary: string
/** bundle_hash ... */
data_hash: string
/** finalized_at ... */
finalized_at: string
/** from_key ... */
from_key: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** FinalizedBundles ... */
FinalizedBundles: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/finalized_bundles/{pool_id}' */
kyve: `/kyve/query/v1beta1/finalized_bundles/${number}`
}
    params: {
        path: {
kyve: {
/** pool_id ... */
pool_id: number
}
}
    
        query: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
kyve: /** QueryStakersByPoolResponse is the response type for the Query/Staker RPC method. */
{
/** finalized_bundles ... */
finalized_bundles: Array<{
/** pool_id ... */
pool_id: string
/** id ... */
id: string
/** storage_id ... */
storage_id: string
/** uploader ... */
uploader: string
/** from_index ... */
from_index: string
/** to_index ... */
to_index: string
/** to_key ... */
to_key: string
/** bundle_summary ... */
bundle_summary: string
/** bundle_hash ... */
data_hash: string
/** finalized_at ... */
finalized_at: string
/** from_key ... */
from_key: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently. It will be empty if
there are no more results. */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Delegator returns delegation information for a specific delegator of a specific staker. */
Delegator: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/delegator/{staker}/{delegator}' */
kyve: `/kyve/query/v1beta1/delegator/${string}/${string}`
}
    params: {
        path: {
kyve: {
/** staker ... */
staker: string
/** delegator ... */
delegator: string
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryDelegatorResponse is the response type for the Query/Delegator RPC method. */
{
/** delegator ... */
delegator: {
/** delegator ... */
delegator: string
/** current_reward ... */
current_reward: string
/** delegation_amount ... */
delegation_amount: string
/** staker ... */
staker: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** DelegatorsByStaker returns all delegators that have delegated to the given staker
This query is paginated. */
DelegatorsByStaker: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/delegators_by_staker/{staker}' */
kyve: `/kyve/query/v1beta1/delegators_by_staker/${string}`
}
    params: {
        path: {
kyve: {
/** staker ... */
staker: string
}
}
    
        query: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
kyve: /** QueryDelegatorsByStakerResponse ... */
{
/** delegators ... */
delegators: Array<{
/** delegator ... */
delegator: string
/** current_reward ... */
current_reward: string
/** delegation_amount ... */
delegation_amount: string
/** staker ... */
staker: string
}>
/** total_delegation ... (consider metadata object) */
total_delegation: string
/** total_delegation ... */
total_delegator_count: string
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently. It will be empty if
there are no more results. */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** StakersByPoolAndDelegator returns all stakers the given delegator has delegated to.
This query is paginated. */
StakersByDelegator: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/stakers_by_delegator/{delegator}' */
kyve: `/kyve/query/v1beta1/stakers_by_delegator/${string}`
}
    params: {
        path: {
kyve: {
/** delegator ... */
delegator: string
}
}
    
        query: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
kyve: /** QueryStakersByDelegatorResponse ... */
{
/** delegator ... */
delegator: string
/** stakers ... */
stakers: Array<{
/** FullStaker aggregates information from the staker and its delegators
as well as pending queue entries into one object.
It contains almost all needed information for a convenient usage */
staker: {
/** address of the staker */
address: string
/** StakerMetadata contains static information for a staker */
metadata: {
/** commission is the percentage of the rewards that will
get transferred to the staker before the remaining
rewards are split across all delegators */
commission: string
/** moniker is a human-readable name for displaying
the staker in the UI */
moniker: string
/** website is a https-link to the website of the staker */
website: string
/** logo is a link to an image file (like jpg or png) */
logo: string
/** CommissionChangeEntry shows when the old commission
of a staker will change to the new commission */
pending_commission_change: {
/** commission is the new commission that will
become active once the change-time is over */
commission: string
/** creation_date is the UNIX-timestamp (in seconds)
of when the entry was created. */
creation_date: string
}
}
/** amount the staker has delegated to himself */
self_delegation: string
/** unbonding_amount is the amount the staker is currently unbonding
from the self-delegation.
This amount can be larger than `amount` when the staker
got slashed during unbonding. However, at the end of
the unbonding period this amount is double checked with the
remaining amount. */
self_delegation_unbonding: string
/** total_delegation returns the sum of all $KYVE users
have delegated to this staker */
total_delegation: string
/** delegator_count is the total number of individual
delegator addresses for that user. */
delegator_count: string
/** pools is a list of all pools the staker is currently
participating, i.e. allowed to vote and upload data. */
pools: Array<{
/** pool contains useful information about the pool */
pool: {
/** id is the ID of the pool */
id: string
/** name of the pool */
name: string
/** runtime for the protocol nodes
like evm, bitcoin, etc. */
runtime: string
/** logo of the pool */
logo: string
/** operating_cost is the base payout for each bundle reward */
operating_cost: string
/** upload_interval is the interval bundles get created */
upload_interval: string
/** total_funds of the pool. If the pool runs
out of funds no more bundles will be produced */
total_funds: string
/** total_delegation of the pool */
total_delegation: string
/** status of the pool if pool is able
to produce bundles, etc. */
status: string
}
/** points indicates if the staker is inactive
If the staker misses a vote, a point is added.
After 5 points the staker is removed from
the stakers set. */
points: string
/** is_leaving indicates if a user has scheduled a
a PoolLeave entry. After the leave-time is over
the staker will no longer participate in that pool */
is_leaving: boolean
/** Valaddress is the address which is authorized to vote
and submit bundles. If the server gets compromised
the staker can just change the valaddress. */
valaddress: string
/** balance is the valaddress account balance and indicates
whether or not the valaccount needs additional funds to
pay for gas fees */
balance: string
}>
}
/** current_reward ... */
current_reward: string
/** delegation_amount ... */
delegation_amount: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently. It will be empty if
there are no more results. */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Params queries a specific parameter of a module, given its subspace and
key. */
Params: {
    method: 'get'
    endpoint: {
/** '/cosmos/params/v1beta1/params' */
axelar: `/cosmos/params/v1beta1/params`
/** '/kyve/query/v1beta1/params' */
kyve: `/kyve/query/v1beta1/params`
}
    params: {
        path: {
axelar: undefined
kyve: undefined
}
    
        query: {
axelar: {
/** subspace defines the module to query the parameter for. */
subspace: string
/** key defines the key of the parameter in the subspace. */
key: string
}
kyve: undefined
}
        body: {
axelar: {
/** subspace defines the module to query the parameter for. */
subspace: string
/** key defines the key of the parameter in the subspace. */
key: string
}
kyve: undefined
}
    }
    response: {
        success: {
axelar: /** QueryParamsResponse is response type for the Query/Params RPC method. */
{
/** param defines the queried parameter. */
param: {
subspace: string
key: string
value: string
}
}
kyve: /** QueryParamsResponse ... */
{
/** bundles_params ... */
bundles_params: {
/** upload_timeout ... */
upload_timeout: string
/** storage_cost ... */
storage_cost: string
/** network_fee ... */
network_fee: string
/** max_points ... */
max_points: string
}
/** delegation_params ... */
delegation_params: {
/** unbonding_delegation_time ... */
unbonding_delegation_time: string
/** unbonding_delegation_time ... */
redelegation_cooldown: string
/** unbonding_delegation_time ... */
redelegation_max_amount: string
}
/** fees_params ... */
fees_params: {
/** min_gas_price defines the minimum gas price value for all transactions. */
min_gas_price: string
/** burn_ratio defines the ratio of transaction fees burnt. */
burn_ratio: string
/** gas_adjustments ... */
gas_adjustments: Array<{
/** type ... */
type: string
/** amount ... */
amount: string
}>
/** gas_refunds ... */
gas_refunds: Array<{
/** type ... */
type: string
/** fraction ... */
fraction: string
}>
/** min_initial_deposit_ratio ... */
min_initial_deposit_ratio: string
}
/** gov_params ... */
gov_params: {
/** Deprecated: Prefer to use `params` instead.
voting_params defines the parameters related to voting. */
voting_params: {
/** Length of the voting period. */
voting_period: string
}
/** Deprecated: Prefer to use `params` instead.
deposit_params defines the parameters related to deposit. */
deposit_params: {
/** Minimum deposit for a proposal to enter voting period. */
min_deposit: Array<{
denom: string
amount: string
}>
/** Maximum period for Atom holders to deposit on a proposal. Initial value: 2
 months. */
max_deposit_period: string
}
/** Deprecated: Prefer to use `params` instead.
tally_params defines the parameters related to tally. */
tally_params: {
/** Minimum percentage of total stake needed to vote for a result to be
 considered valid. */
quorum: string
/** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
threshold: string
/** Minimum value of Veto votes to Total votes ratio for proposal to be
 vetoed. Default value: 1/3. */
veto_threshold: string
}
/** params defines all the paramaters of x/gov module.

Since: cosmos-sdk 0.47 */
params: {
/** Minimum deposit for a proposal to enter voting period. */
min_deposit: Array<{
denom: string
amount: string
}>
/** Maximum period for Atom holders to deposit on a proposal. Initial value: 2
 months. */
max_deposit_period: string
/** Length of the voting period. */
voting_period: string
/** Minimum percentage of total stake needed to vote for a result to be
 considered valid. */
quorum: string
/** Minimum proportion of Yes votes for proposal to pass. Default value: 0.5. */
threshold: string
/** Minimum value of Veto votes to Total votes ratio for proposal to be
 vetoed. Default value: 1/3. */
veto_threshold: string
/** The ratio representing the proportion of the deposit value that must be paid at proposal submission. */
min_initial_deposit_ratio: string
}
}
/** stakers_params ... */
stakers_params: {
/** vote_slash ... */
vote_slash: string
/** upload_slash ... */
upload_slash: string
/** timeout_slash ... */
timeout_slash: string
/** unbonding_staking_time ... */
unbonding_staking_time: string
/** commission_change_time ... */
commission_change_time: string
/** commission_change_time ... */
leave_pool_time: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Pools queries for all pools. */
Pools: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/pools' */
kyve: `/kyve/query/v1beta1/pools`
}
    params: {
        path: {
kyve: undefined
}
    
        query: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
/** search ... */
search: string
/** runtime ... */
runtime: string
/** paused ... */
paused: string
}
}
        body: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
/** search ... */
search: string
/** runtime ... */
runtime: string
/** paused ... */
paused: string
}
}
    }
    response: {
        success: {
kyve: /** QueryPoolsResponse is the response type for the Query/Pools RPC method. */
{
/** pools ... */
pools: Array<{
/** id ... */
id: string
/** data ... */
data: {
/** id ... */
id: string
/** name ... */
name: string
/** runtime ... */
runtime: string
/** logo ... */
logo: string
/** config ... */
config: string
/** start_key ... */
start_key: string
/** current_key ... */
current_key: string
/** current_summary ... */
current_summary: string
/** current_index ... */
current_index: string
/** total_bundles ... */
total_bundles: string
/** upload_interval ... */
upload_interval: string
/** operating_cost ... */
operating_cost: string
/** min_delegation ... */
min_delegation: string
/** max_bundle_size ... */
max_bundle_size: string
/** paused ... */
paused: boolean
/** funders ... */
funders: Array<{
/** address ... */
address: string
/** amount ... */
amount: string
}>
/** total_funds ... */
total_funds: string
/** protocol ... */
protocol: {
/** version ... */
version: string
/** binaries ... */
binaries: string
/** last_upgrade ... */
last_upgrade: string
}
/** upgrade_plan ... */
upgrade_plan: {
/** version ... */
version: string
/** binaries ... */
binaries: string
/** scheduled_at ... */
scheduled_at: string
/** duration ... */
duration: string
}
}
/** bundle_proposal ... */
bundle_proposal: {
/** pool_id ... */
pool_id: string
/** storage_id ... */
storage_id: string
/** uploader ... */
uploader: string
/** next_uploader ... */
next_uploader: string
/** data_size ... */
data_size: string
/** bundle_size ... */
bundle_size: string
/** to_key ... */
to_key: string
/** bundle_summary ... */
bundle_summary: string
/** data_hash ... */
data_hash: string
/** updated_at ... */
updated_at: string
/** voters_valid ... */
voters_valid: Array<string>
/** voters_invalid ... */
voters_invalid: Array<string>
/** voters_abstain ... */
voters_abstain: Array<string>
/** from_key ... */
from_key: string
}
/** stakers ... */
stakers: Array<string>
/** total_stake ... */
total_self_delegation: string
/** total_delegation ... */
total_delegation: string
/** status ... */
status: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently. It will be empty if
there are no more results. */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Staker queries for all stakers. */
Staker: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/staker/{address}' */
kyve: `/kyve/query/v1beta1/staker/${string}`
}
    params: {
        path: {
kyve: {
/** address ... */
address: string
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryStakerResponse is the response type for the Query/Staker RPC method. */
{
/** FullStaker aggregates information from the staker and its delegators
as well as pending queue entries into one object.
It contains almost all needed information for a convenient usage */
staker: {
/** address of the staker */
address: string
/** StakerMetadata contains static information for a staker */
metadata: {
/** commission is the percentage of the rewards that will
get transferred to the staker before the remaining
rewards are split across all delegators */
commission: string
/** moniker is a human-readable name for displaying
the staker in the UI */
moniker: string
/** website is a https-link to the website of the staker */
website: string
/** logo is a link to an image file (like jpg or png) */
logo: string
/** CommissionChangeEntry shows when the old commission
of a staker will change to the new commission */
pending_commission_change: {
/** commission is the new commission that will
become active once the change-time is over */
commission: string
/** creation_date is the UNIX-timestamp (in seconds)
of when the entry was created. */
creation_date: string
}
}
/** amount the staker has delegated to himself */
self_delegation: string
/** unbonding_amount is the amount the staker is currently unbonding
from the self-delegation.
This amount can be larger than `amount` when the staker
got slashed during unbonding. However, at the end of
the unbonding period this amount is double checked with the
remaining amount. */
self_delegation_unbonding: string
/** total_delegation returns the sum of all $KYVE users
have delegated to this staker */
total_delegation: string
/** delegator_count is the total number of individual
delegator addresses for that user. */
delegator_count: string
/** pools is a list of all pools the staker is currently
participating, i.e. allowed to vote and upload data. */
pools: Array<{
/** pool contains useful information about the pool */
pool: {
/** id is the ID of the pool */
id: string
/** name of the pool */
name: string
/** runtime for the protocol nodes
like evm, bitcoin, etc. */
runtime: string
/** logo of the pool */
logo: string
/** operating_cost is the base payout for each bundle reward */
operating_cost: string
/** upload_interval is the interval bundles get created */
upload_interval: string
/** total_funds of the pool. If the pool runs
out of funds no more bundles will be produced */
total_funds: string
/** total_delegation of the pool */
total_delegation: string
/** status of the pool if pool is able
to produce bundles, etc. */
status: string
}
/** points indicates if the staker is inactive
If the staker misses a vote, a point is added.
After 5 points the staker is removed from
the stakers set. */
points: string
/** is_leaving indicates if a user has scheduled a
a PoolLeave entry. After the leave-time is over
the staker will no longer participate in that pool */
is_leaving: boolean
/** Valaddress is the address which is authorized to vote
and submit bundles. If the server gets compromised
the staker can just change the valaddress. */
valaddress: string
/** balance is the valaddress account balance and indicates
whether or not the valaccount needs additional funds to
pay for gas fees */
balance: string
}>
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Stakers queries for all stakers. */
Stakers: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/stakers' */
kyve: `/kyve/query/v1beta1/stakers`
}
    params: {
        path: {
kyve: undefined
}
    
        query: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
/** status looks whether a staker is participating in pools or not.

 - STAKER_STATUS_UNSPECIFIED: STAKER_STATUS_UNSPECIFIED ...
 - STAKER_STATUS_ACTIVE: STAKER_STATUS_ACTIVE ...
 - STAKER_STATUS_INACTIVE: STAKER_STATUS_INACTIVE ... */
status: string
/** search searches for moniker OR address. */
search: string
}
}
        body: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
/** status looks whether a staker is participating in pools or not.

 - STAKER_STATUS_UNSPECIFIED: STAKER_STATUS_UNSPECIFIED ...
 - STAKER_STATUS_ACTIVE: STAKER_STATUS_ACTIVE ...
 - STAKER_STATUS_INACTIVE: STAKER_STATUS_INACTIVE ... */
status: string
/** search searches for moniker OR address. */
search: string
}
}
    }
    response: {
        success: {
kyve: /** QueryStakersResponse is the response type for the Query/Stakers RPC method. */
{
/** stakers ... */
stakers: Array<{
/** address of the staker */
address: string
/** StakerMetadata contains static information for a staker */
metadata: {
/** commission is the percentage of the rewards that will
get transferred to the staker before the remaining
rewards are split across all delegators */
commission: string
/** moniker is a human-readable name for displaying
the staker in the UI */
moniker: string
/** website is a https-link to the website of the staker */
website: string
/** logo is a link to an image file (like jpg or png) */
logo: string
/** CommissionChangeEntry shows when the old commission
of a staker will change to the new commission */
pending_commission_change: {
/** commission is the new commission that will
become active once the change-time is over */
commission: string
/** creation_date is the UNIX-timestamp (in seconds)
of when the entry was created. */
creation_date: string
}
}
/** amount the staker has delegated to himself */
self_delegation: string
/** unbonding_amount is the amount the staker is currently unbonding
from the self-delegation.
This amount can be larger than `amount` when the staker
got slashed during unbonding. However, at the end of
the unbonding period this amount is double checked with the
remaining amount. */
self_delegation_unbonding: string
/** total_delegation returns the sum of all $KYVE users
have delegated to this staker */
total_delegation: string
/** delegator_count is the total number of individual
delegator addresses for that user. */
delegator_count: string
/** pools is a list of all pools the staker is currently
participating, i.e. allowed to vote and upload data. */
pools: Array<{
/** pool contains useful information about the pool */
pool: {
/** id is the ID of the pool */
id: string
/** name of the pool */
name: string
/** runtime for the protocol nodes
like evm, bitcoin, etc. */
runtime: string
/** logo of the pool */
logo: string
/** operating_cost is the base payout for each bundle reward */
operating_cost: string
/** upload_interval is the interval bundles get created */
upload_interval: string
/** total_funds of the pool. If the pool runs
out of funds no more bundles will be produced */
total_funds: string
/** total_delegation of the pool */
total_delegation: string
/** status of the pool if pool is able
to produce bundles, etc. */
status: string
}
/** points indicates if the staker is inactive
If the staker misses a vote, a point is added.
After 5 points the staker is removed from
the stakers set. */
points: string
/** is_leaving indicates if a user has scheduled a
a PoolLeave entry. After the leave-time is over
the staker will no longer participate in that pool */
is_leaving: boolean
/** Valaddress is the address which is authorized to vote
and submit bundles. If the server gets compromised
the staker can just change the valaddress. */
valaddress: string
/** balance is the valaddress account balance and indicates
whether or not the valaccount needs additional funds to
pay for gas fees */
balance: string
}>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently. It will be empty if
there are no more results. */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** StakersByPool queries for all stakers that are currently participating in the given pool */
StakersByPool: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/stakers_by_pool/{pool_id}' */
kyve: `/kyve/query/v1beta1/stakers_by_pool/${number}`
}
    params: {
        path: {
kyve: {
/** pool_id ... */
pool_id: number
}
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryStakersByPoolResponse is the response type for the Query/Staker RPC method. */
{
/** stakers ... */
stakers: Array<{
/** FullStaker aggregates information from the staker and its delegators
as well as pending queue entries into one object.
It contains almost all needed information for a convenient usage */
staker: {
/** address of the staker */
address: string
/** StakerMetadata contains static information for a staker */
metadata: {
/** commission is the percentage of the rewards that will
get transferred to the staker before the remaining
rewards are split across all delegators */
commission: string
/** moniker is a human-readable name for displaying
the staker in the UI */
moniker: string
/** website is a https-link to the website of the staker */
website: string
/** logo is a link to an image file (like jpg or png) */
logo: string
/** CommissionChangeEntry shows when the old commission
of a staker will change to the new commission */
pending_commission_change: {
/** commission is the new commission that will
become active once the change-time is over */
commission: string
/** creation_date is the UNIX-timestamp (in seconds)
of when the entry was created. */
creation_date: string
}
}
/** amount the staker has delegated to himself */
self_delegation: string
/** unbonding_amount is the amount the staker is currently unbonding
from the self-delegation.
This amount can be larger than `amount` when the staker
got slashed during unbonding. However, at the end of
the unbonding period this amount is double checked with the
remaining amount. */
self_delegation_unbonding: string
/** total_delegation returns the sum of all $KYVE users
have delegated to this staker */
total_delegation: string
/** delegator_count is the total number of individual
delegator addresses for that user. */
delegator_count: string
/** pools is a list of all pools the staker is currently
participating, i.e. allowed to vote and upload data. */
pools: Array<{
/** pool contains useful information about the pool */
pool: {
/** id is the ID of the pool */
id: string
/** name of the pool */
name: string
/** runtime for the protocol nodes
like evm, bitcoin, etc. */
runtime: string
/** logo of the pool */
logo: string
/** operating_cost is the base payout for each bundle reward */
operating_cost: string
/** upload_interval is the interval bundles get created */
upload_interval: string
/** total_funds of the pool. If the pool runs
out of funds no more bundles will be produced */
total_funds: string
/** total_delegation of the pool */
total_delegation: string
/** status of the pool if pool is able
to produce bundles, etc. */
status: string
}
/** points indicates if the staker is inactive
If the staker misses a vote, a point is added.
After 5 points the staker is removed from
the stakers set. */
points: string
/** is_leaving indicates if a user has scheduled a
a PoolLeave entry. After the leave-time is over
the staker will no longer participate in that pool */
is_leaving: boolean
/** Valaddress is the address which is authorized to vote
and submit bundles. If the server gets compromised
the staker can just change the valaddress. */
valaddress: string
/** balance is the valaddress account balance and indicates
whether or not the valaccount needs additional funds to
pay for gas fees */
balance: string
}>
}
/** valaccount ... */
valaccount: {
/** pool_id ... */
pool_id: string
/** staker ... */
staker: string
/** valaddress ... */
valaddress: string
/** points ... */
points: string
/** isLeaving ... */
is_leaving: boolean
}
}>
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** StakersByPool queries for all stakers and sorted them first by number of pools participating and
then by delegation */
StakersByPoolCount: {
    method: 'get'
    endpoint: {
/** '/kyve/query/v1beta1/stakers_by_pool_count' */
kyve: `/kyve/query/v1beta1/stakers_by_pool_count`
}
    params: {
        path: {
kyve: undefined
}
    
        query: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
kyve: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
kyve: /** QueryStakersByPoolCountResponse ... */
{
/** stakers ... */
stakers: Array<{
/** address of the staker */
address: string
/** StakerMetadata contains static information for a staker */
metadata: {
/** commission is the percentage of the rewards that will
get transferred to the staker before the remaining
rewards are split across all delegators */
commission: string
/** moniker is a human-readable name for displaying
the staker in the UI */
moniker: string
/** website is a https-link to the website of the staker */
website: string
/** logo is a link to an image file (like jpg or png) */
logo: string
/** CommissionChangeEntry shows when the old commission
of a staker will change to the new commission */
pending_commission_change: {
/** commission is the new commission that will
become active once the change-time is over */
commission: string
/** creation_date is the UNIX-timestamp (in seconds)
of when the entry was created. */
creation_date: string
}
}
/** amount the staker has delegated to himself */
self_delegation: string
/** unbonding_amount is the amount the staker is currently unbonding
from the self-delegation.
This amount can be larger than `amount` when the staker
got slashed during unbonding. However, at the end of
the unbonding period this amount is double checked with the
remaining amount. */
self_delegation_unbonding: string
/** total_delegation returns the sum of all $KYVE users
have delegated to this staker */
total_delegation: string
/** delegator_count is the total number of individual
delegator addresses for that user. */
delegator_count: string
/** pools is a list of all pools the staker is currently
participating, i.e. allowed to vote and upload data. */
pools: Array<{
/** pool contains useful information about the pool */
pool: {
/** id is the ID of the pool */
id: string
/** name of the pool */
name: string
/** runtime for the protocol nodes
like evm, bitcoin, etc. */
runtime: string
/** logo of the pool */
logo: string
/** operating_cost is the base payout for each bundle reward */
operating_cost: string
/** upload_interval is the interval bundles get created */
upload_interval: string
/** total_funds of the pool. If the pool runs
out of funds no more bundles will be produced */
total_funds: string
/** total_delegation of the pool */
total_delegation: string
/** status of the pool if pool is able
to produce bundles, etc. */
status: string
}
/** points indicates if the staker is inactive
If the staker misses a vote, a point is added.
After 5 points the staker is removed from
the stakers set. */
points: string
/** is_leaving indicates if a user has scheduled a
a PoolLeave entry. After the leave-time is over
the staker will no longer participate in that pool */
is_leaving: boolean
/** Valaddress is the address which is authorized to vote
and submit bundles. If the server gets compromised
the staker can just change the valaddress. */
valaddress: string
/** balance is the valaddress account balance and indicates
whether or not the valaccount needs additional funds to
pay for gas fees */
balance: string
}>
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently. It will be empty if
there are no more results. */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Parameters queries the parameters of the module. */
StakersParams: {
    method: 'get'
    endpoint: {
/** '/kyve/stakers/v1beta1/params' */
kyve: `/kyve/stakers/v1beta1/params`
}
    params: {
        path: {
kyve: undefined
}
    
        query: {
kyve: undefined
}
        body: {
kyve: undefined
}
    }
    response: {
        success: {
kyve: /** QueryParamsResponse is response type for the Query/Params RPC method. */
{
/** params holds all the parameters of this module. */
params: {
/** vote_slash ... */
vote_slash: string
/** upload_slash ... */
upload_slash: string
/** timeout_slash ... */
timeout_slash: string
/** unbonding_staking_time ... */
unbonding_staking_time: string
/** commission_change_time ... */
commission_change_time: string
/** commission_change_time ... */
leave_pool_time: string
}
}
}
        error: {
kyve: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** undefined */
AddCosmosBasedChain: {
    method: 'post'
    endpoint: {
/** '/axelar/axelarnet/add_cosmos_based_chain' */
axelar: `/axelar/axelarnet/add_cosmos_based_chain`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** MsgAddCosmosBasedChain represents a message to register a cosmos based chain
to nexus */
{
sender: string
/** Chain represents the properties of a registered blockchain */
chain: {
name: string
supports_foreign_assets: boolean
key_type: string
module: string
}
addr_prefix: string
native_assets: Array<{
denom: string
is_native_asset: boolean
}>
}
}
}
        body: {
axelar: {
'body': /** MsgAddCosmosBasedChain represents a message to register a cosmos based chain
to nexus */
{
sender: string
/** Chain represents the properties of a registered blockchain */
chain: {
name: string
supports_foreign_assets: boolean
key_type: string
module: string
}
addr_prefix: string
native_assets: Array<{
denom: string
is_native_asset: boolean
}>
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
AxelarnetConfirmDeposit: {
    method: 'post'
    endpoint: {
/** '/axelar/axelarnet/confirm_deposit' */
axelar: `/axelar/axelarnet/confirm_deposit`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** MsgConfirmDeposit represents a deposit confirmation message */
{
sender: string
deposit_address: string
denom: string
}
}
}
        body: {
axelar: {
'body': /** MsgConfirmDeposit represents a deposit confirmation message */
{
sender: string
deposit_address: string
denom: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
ExecutePendingTransfers: {
    method: 'post'
    endpoint: {
/** '/axelar/axelarnet/execute_pending_transfers' */
axelar: `/axelar/axelarnet/execute_pending_transfers`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** MsgExecutePendingTransfers represents a message to trigger transfer all
pending transfers */
{
sender: string
}
}
}
        body: {
axelar: {
'body': /** MsgExecutePendingTransfers represents a message to trigger transfer all
pending transfers */
{
sender: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
AxelarnetLink: {
    method: 'post'
    endpoint: {
/** '/axelar/axelarnet/link' */
axelar: `/axelar/axelarnet/link`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** MsgLink represents a message to link a cross-chain address to an Axelar
address */
{
sender: string
recipient_addr: string
recipient_chain: string
asset: string
}
}
}
        body: {
axelar: {
'body': /** MsgLink represents a message to link a cross-chain address to an Axelar
address */
{
sender: string
recipient_addr: string
recipient_chain: string
asset: string
}
}
}
    }
    response: {
        success: {
axelar: {
deposit_addr: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
RegisterAsset: {
    method: 'post'
    endpoint: {
/** '/axelar/axelarnet/register_asset' */
axelar: `/axelar/axelarnet/register_asset`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** RegisterAssetRequest represents a message to register an asset to a cosmos
based chain */
{
sender: string
chain: string
asset: {
denom: string
is_native_asset: boolean
}
}
}
}
        body: {
axelar: {
'body': /** RegisterAssetRequest represents a message to register an asset to a cosmos
based chain */
{
sender: string
chain: string
asset: {
denom: string
is_native_asset: boolean
}
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
RegisterFeeCollector: {
    method: 'post'
    endpoint: {
/** '/axelar/axelarnet/register_fee_collector' */
axelar: `/axelar/axelarnet/register_fee_collector`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** RegisterFeeCollectorRequest represents a message to register axelarnet fee
collector account */
{
sender: string
fee_collector: string
}
}
}
        body: {
axelar: {
'body': /** RegisterFeeCollectorRequest represents a message to register axelarnet fee
collector account */
{
sender: string
fee_collector: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
RegisterIBCPath: {
    method: 'post'
    endpoint: {
/** '/axelar/axelarnet/register_ibc_path' */
axelar: `/axelar/axelarnet/register_ibc_path`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** MSgRegisterIBCPath represents a message to register an IBC tracing path for
a cosmos chain */
{
sender: string
chain: string
path: string
}
}
}
        body: {
axelar: {
'body': /** MSgRegisterIBCPath represents a message to register an IBC tracing path for
a cosmos chain */
{
sender: string
chain: string
path: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
RetryIBCTransfer: {
    method: 'post'
    endpoint: {
/** '/axelar/axelarnet/retry_ibc_transfer' */
axelar: `/axelar/axelarnet/retry_ibc_transfer`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
chain: string
id: string
}
}
}
        body: {
axelar: {
'body': {
sender: string
chain: string
id: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
RouteIBCTransfers: {
    method: 'post'
    endpoint: {
/** '/axelar/axelarnet/route_ibc_transfers' */
axelar: `/axelar/axelarnet/route_ibc_transfers`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** RouteIBCTransfersRequest represents a message to route pending transfers to
cosmos based chains */
{
sender: string
}
}
}
        body: {
axelar: {
'body': /** RouteIBCTransfersRequest represents a message to route pending transfers to
cosmos based chains */
{
sender: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** PendingIBCTransferCount queries the pending ibc transfers for all chains */
PendingIBCTransferCount: {
    method: 'get'
    endpoint: {
/** '/axelar/axelarnet/v1beta1/ibc_transfer_count' */
axelar: `/axelar/axelarnet/v1beta1/ibc_transfer_count`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
transfers_by_chain: {}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
AddChain: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/add_chain' */
axelar: `/axelar/evm/add_chain`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
name: string
key_type: string
params: string
}
}
}
        body: {
axelar: {
'body': {
sender: string
name: string
key_type: string
params: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
EvmConfirmDeposit: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/confirm_deposit' */
axelar: `/axelar/evm/confirm_deposit`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** MsgConfirmDeposit represents an erc20 deposit confirmation message */
{
sender: string
chain: string
tx_id: string
amount: string
burner_address: string
}
}
}
        body: {
axelar: {
'body': /** MsgConfirmDeposit represents an erc20 deposit confirmation message */
{
sender: string
chain: string
tx_id: string
amount: string
burner_address: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
ConfirmGatewayTx: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/confirm_gateway_tx' */
axelar: `/axelar/evm/confirm_gateway_tx`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
chain: string
tx_id: string
}
}
}
        body: {
axelar: {
'body': {
sender: string
chain: string
tx_id: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
ConfirmToken: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/confirm_token' */
axelar: `/axelar/evm/confirm_token`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** MsgConfirmToken represents a token deploy confirmation message */
{
sender: string
chain: string
tx_id: string
asset: {
chain: string
name: string
}
}
}
}
        body: {
axelar: {
'body': /** MsgConfirmToken represents a token deploy confirmation message */
{
sender: string
chain: string
tx_id: string
asset: {
chain: string
name: string
}
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
ConfirmTransferKey: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/confirm_transfer_key' */
axelar: `/axelar/evm/confirm_transfer_key`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
chain: string
tx_id: string
}
}
}
        body: {
axelar: {
'body': {
sender: string
chain: string
tx_id: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
CreateBurnTokens: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/create_burn_tokens' */
axelar: `/axelar/evm/create_burn_tokens`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** CreateBurnTokensRequest represents the message to create commands to burn
tokens with AxelarGateway */
{
sender: string
chain: string
}
}
}
        body: {
axelar: {
'body': /** CreateBurnTokensRequest represents the message to create commands to burn
tokens with AxelarGateway */
{
sender: string
chain: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
CreateDeployToken: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/create_deploy_token' */
axelar: `/axelar/evm/create_deploy_token`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** CreateDeployTokenRequest represents the message to create a deploy token
command for AxelarGateway */
{
sender: string
chain: string
asset: {
chain: string
name: string
}
token_details: {
token_name: string
symbol: string
decimals: number
capacity: string
}
address: string
daily_mint_limit: string
}
}
}
        body: {
axelar: {
'body': /** CreateDeployTokenRequest represents the message to create a deploy token
command for AxelarGateway */
{
sender: string
chain: string
asset: {
chain: string
name: string
}
token_details: {
token_name: string
symbol: string
decimals: number
capacity: string
}
address: string
daily_mint_limit: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
CreatePendingTransfers: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/create_pending_transfers' */
axelar: `/axelar/evm/create_pending_transfers`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** CreatePendingTransfersRequest represents a message to trigger the creation of
commands handling all pending transfers */
{
sender: string
chain: string
}
}
}
        body: {
axelar: {
'body': /** CreatePendingTransfersRequest represents a message to trigger the creation of
commands handling all pending transfers */
{
sender: string
chain: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
CreateTransferOperatorship: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/create_transfer_operatorship' */
axelar: `/axelar/evm/create_transfer_operatorship`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
chain: string
key_id: string
}
}
}
        body: {
axelar: {
'body': {
sender: string
chain: string
key_id: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
EvmLink: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/link' */
axelar: `/axelar/evm/link`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** MsgLink represents the message that links a cross chain address to a burner
address */
{
sender: string
chain: string
recipient_addr: string
asset: string
recipient_chain: string
}
}
}
        body: {
axelar: {
'body': /** MsgLink represents the message that links a cross chain address to a burner
address */
{
sender: string
chain: string
recipient_addr: string
asset: string
recipient_chain: string
}
}
}
    }
    response: {
        success: {
axelar: {
deposit_addr: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
RetryFailedEvent: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/retry-failed-event' */
axelar: `/axelar/evm/retry-failed-event`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
chain: string
event_id: string
}
}
}
        body: {
axelar: {
'body': {
sender: string
chain: string
event_id: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
SetGateway: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/set_gateway' */
axelar: `/axelar/evm/set_gateway`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
chain: string
address: string
}
}
}
        body: {
axelar: {
'body': {
sender: string
chain: string
address: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
SignCommands: {
    method: 'post'
    endpoint: {
/** '/axelar/evm/sign_commands' */
axelar: `/axelar/evm/sign_commands`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
chain: string
}
}
}
        body: {
axelar: {
'body': {
sender: string
chain: string
}
}
}
    }
    response: {
        success: {
axelar: {
batched_commands_id: string
command_count: number
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** BatchedCommands queries the batched commands for a specified chain and
BatchedCommandsID if no BatchedCommandsID is specified, then it returns the
latest batched commands */
BatchedCommands: {
    method: 'get'
    endpoint: {
/** '/axelar/evm/v1beta1/batched_commands/{chain}/{id}' */
axelar: `/axelar/evm/v1beta1/batched_commands/${string}/${string}`
}
    params: {
        path: {
axelar: {
chain: string
/** id defines an optional id for the commandsbatch. If not specified the
latest will be returned */
id: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
id: string
data: string
status: string
key_id: string
execute_data: string
prev_batched_commands_id: string
command_ids: Array<string>
proof: {
addresses: Array<string>
weights: Array<string>
threshold: string
signatures: Array<string>
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** BurnerInfo queries the burner info for the specified address */
BurnerInfo: {
    method: 'get'
    endpoint: {
/** '/axelar/evm/v1beta1/burner_info' */
axelar: `/axelar/evm/v1beta1/burner_info`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
address: string
}
}
        body: {
axelar: {
address: string
}
}
    }
    response: {
        success: {
axelar: {
chain: string
/** BurnerInfo describes information required to burn token at an burner address
that is deposited by an user */
burner_info: {
burner_address: string
token_address: string
destination_chain: string
symbol: string
asset: string
salt: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Bytecode queries the bytecode of a specified gateway at the specified chain */
Bytecode: {
    method: 'get'
    endpoint: {
/** '/axelar/evm/v1beta1/bytecode/{chain}/{contract}' */
axelar: `/axelar/evm/v1beta1/bytecode/${string}/${string}`
}
    params: {
        path: {
axelar: {
chain: string
contract: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
bytecode: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Chains queries the available evm chains */
EvmChains: {
    method: 'get'
    endpoint: {
/** '/axelar/evm/v1beta1/chains' */
axelar: `/axelar/evm/v1beta1/chains`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
chains: Array<string>
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ConfirmationHeight queries the confirmation height for the specified chain */
ConfirmationHeight: {
    method: 'get'
    endpoint: {
/** '/axelar/evm/v1beta1/confirmation_height/{chain}' */
axelar: `/axelar/evm/v1beta1/confirmation_height/${string}`
}
    params: {
        path: {
axelar: {
chain: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
height: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** DepositState queries the state of the specified deposit */
DepositState: {
    method: 'get'
    endpoint: {
/** '/axelar/evm/v1beta1/deposit_state' */
axelar: `/axelar/evm/v1beta1/deposit_state`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
chain: string
'params.tx_id': string
'params.burner_address': string
}
}
        body: {
axelar: {
chain: string
'params.tx_id': string
'params.burner_address': string
}
}
    }
    response: {
        success: {
axelar: {
status: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ERC20Tokens queries the ERC20 tokens registered for a chain */
ERC20Tokens: {
    method: 'get'
    endpoint: {
/** '/axelar/evm/v1beta1/erc20_tokens/{chain}' */
axelar: `/axelar/evm/v1beta1/erc20_tokens/${string}`
}
    params: {
        path: {
axelar: {
chain: string
}
}
    
        query: {
axelar: {
type: string
}
}
        body: {
axelar: {
type: string
}
}
    }
    response: {
        success: {
axelar: /** ERC20TokensResponse describes the asset and symbol for all
ERC20 tokens requested for a chain */
{
tokens: Array<{
asset: string
symbol: string
}>
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Event queries an event at the specified chain */
Event: {
    method: 'get'
    endpoint: {
/** '/axelar/evm/v1beta1/event/{chain}/{event_id}' */
axelar: `/axelar/evm/v1beta1/event/${string}/${string}`
}
    params: {
        path: {
axelar: {
chain: string
event_id: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
event: {
chain: string
tx_id: string
index: string
status: string
token_sent: {
sender: string
destination_chain: string
destination_address: string
symbol: string
amount: string
}
contract_call: {
sender: string
destination_chain: string
contract_address: string
payload_hash: string
}
contract_call_with_token: {
sender: string
destination_chain: string
contract_address: string
payload_hash: string
symbol: string
amount: string
}
transfer: {
to: string
amount: string
}
token_deployed: {
symbol: string
token_address: string
}
multisig_ownership_transferred: {
pre_owners: Array<string>
prev_threshold: string
new_owners: Array<string>
new_threshold: string
}
multisig_operatorship_transferred: {
new_operators: Array<string>
new_threshold: string
new_weights: Array<string>
}
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** GatewayAddress queries the address of axelar gateway at the specified chain */
GatewayAddress: {
    method: 'get'
    endpoint: {
/** '/axelar/evm/v1beta1/gateway_address/{chain}' */
axelar: `/axelar/evm/v1beta1/gateway_address/${string}`
}
    params: {
        path: {
axelar: {
chain: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
address: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** KeyAddress queries the address of key of a chain */
KeyAddress: {
    method: 'get'
    endpoint: {
/** '/axelar/evm/v1beta1/key_address/{chain}' */
axelar: `/axelar/evm/v1beta1/key_address/${string}`
}
    params: {
        path: {
axelar: {
chain: string
}
}
    
        query: {
axelar: {
key_id: string
}
}
        body: {
axelar: {
key_id: string
}
}
    }
    response: {
        success: {
axelar: {
key_id: string
addresses: Array<{
address: string
weight: string
}>
threshold: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** PendingCommands queries the pending commands for the specified chain */
PendingCommands: {
    method: 'get'
    endpoint: {
/** '/axelar/evm/v1beta1/pending_commands/{chain}' */
axelar: `/axelar/evm/v1beta1/pending_commands/${string}`
}
    params: {
        path: {
axelar: {
chain: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
commands: Array<{
id: string
type: string
params: {}
key_id: string
max_gas_cost: number
}>
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** TokenInfo queries the token info for a registered ERC20 Token */
TokenInfo: {
    method: 'get'
    endpoint: {
/** '/axelar/evm/v1beta1/token_info/{chain}' */
axelar: `/axelar/evm/v1beta1/token_info/${string}`
}
    params: {
        path: {
axelar: {
chain: string
}
}
    
        query: {
axelar: {
asset: string
symbol: string
}
}
        body: {
axelar: {
asset: string
symbol: string
}
}
    }
    response: {
        success: {
axelar: {
asset: string
details: {
token_name: string
symbol: string
decimals: number
capacity: string
}
address: string
confirmed: boolean
is_external: boolean
burner_code_hash: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
ActivateChain: {
    method: 'post'
    endpoint: {
/** '/axelar/nexus/activate_chain' */
axelar: `/axelar/nexus/activate_chain`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** ActivateChainRequest represents a message to activate chains */
{
sender: string
chains: Array<string>
}
}
}
        body: {
axelar: {
'body': /** ActivateChainRequest represents a message to activate chains */
{
sender: string
chains: Array<string>
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
DeactivateChain: {
    method: 'post'
    endpoint: {
/** '/axelar/nexus/deactivate_chain' */
axelar: `/axelar/nexus/deactivate_chain`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** DeactivateChainRequest represents a message to deactivate chains */
{
sender: string
chains: Array<string>
}
}
}
        body: {
axelar: {
'body': /** DeactivateChainRequest represents a message to deactivate chains */
{
sender: string
chains: Array<string>
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
DeregisterChainMaintainer: {
    method: 'post'
    endpoint: {
/** '/axelar/nexus/deregister_chain_maintainer' */
axelar: `/axelar/nexus/deregister_chain_maintainer`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
chains: Array<string>
}
}
}
        body: {
axelar: {
'body': {
sender: string
chains: Array<string>
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
RegisterAssetFee: {
    method: 'post'
    endpoint: {
/** '/axelar/nexus/register_asset_fee' */
axelar: `/axelar/nexus/register_asset_fee`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': /** RegisterAssetFeeRequest represents a message to register the transfer fee
info associated to an asset on a chain */
{
sender: string
fee_info: {
chain: string
asset: string
fee_rate: string
min_fee: string
max_fee: string
}
}
}
}
        body: {
axelar: {
'body': /** RegisterAssetFeeRequest represents a message to register the transfer fee
info associated to an asset on a chain */
{
sender: string
fee_info: {
chain: string
asset: string
fee_rate: string
min_fee: string
max_fee: string
}
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** undefined */
RegisterChainMaintainer: {
    method: 'post'
    endpoint: {
/** '/axelar/nexus/register_chain_maintainer' */
axelar: `/axelar/nexus/register_chain_maintainer`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
chains: Array<string>
}
}
}
        body: {
axelar: {
'body': {
sender: string
chains: Array<string>
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Assets queries the assets registered for a chain */
Assets: {
    method: 'get'
    endpoint: {
/** '/axelar/nexus/v1beta1/assets/{chain}' */
axelar: `/axelar/nexus/v1beta1/assets/${string}`
}
    params: {
        path: {
axelar: {
chain: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
assets: Array<string>
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ChainState queries the state of a registered chain on the network */
ChainState: {
    method: 'get'
    endpoint: {
/** '/axelar/nexus/v1beta1/chain_state/{chain}' */
axelar: `/axelar/nexus/v1beta1/chain_state/${string}`
}
    params: {
        path: {
axelar: {
chain: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
/** ChainState represents the state of a registered blockchain */
state: {
/** Chain represents the properties of a registered blockchain */
chain: {
name: string
supports_foreign_assets: boolean
key_type: string
module: string
}
activated: boolean
assets: Array<{
denom: string
is_native_asset: boolean
}>
maintainer_states: Array<{
address: string
missing_votes: {
true_count_cache: {
cumulative_value: Array<string>
index: number
max_size: number
}
}
incorrect_votes: {
true_count_cache: {
cumulative_value: Array<string>
index: number
max_size: number
}
}
chain: string
}>
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Chains queries the chains registered on the network */
Chains: {
    method: 'get'
    endpoint: {
/** '/axelar/nexus/v1beta1/chains' */
axelar: `/axelar/nexus/v1beta1/chains`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
status: string
}
}
        body: {
axelar: {
status: string
}
}
    }
    response: {
        success: {
axelar: {
chains: Array<string>
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ChainsByAsset queries the chains that support an asset on the network */
ChainsByAsset: {
    method: 'get'
    endpoint: {
/** '/axelar/nexus/v1beta1/chains_by_asset/{asset}' */
axelar: `/axelar/nexus/v1beta1/chains_by_asset/${string}`
}
    params: {
        path: {
axelar: {
asset: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
chains: Array<string>
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** FeeInfo queries the fee info by chain and asset */
FeeInfo2: {
    method: 'get'
    endpoint: {
/** '/axelar/nexus/v1beta1/fee' */
axelar: `/axelar/nexus/v1beta1/fee`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
chain: string
asset: string
}
}
        body: {
axelar: {
chain: string
asset: string
}
}
    }
    response: {
        success: {
axelar: {
fee_info: {
chain: string
asset: string
fee_rate: string
min_fee: string
max_fee: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** FeeInfo queries the fee info by chain and asset */
FeeInfo: {
    method: 'get'
    endpoint: {
/** '/axelar/nexus/v1beta1/fee_info/{chain}/{asset}' */
axelar: `/axelar/nexus/v1beta1/fee_info/${string}/${string}`
}
    params: {
        path: {
axelar: {
chain: string
asset: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
fee_info: {
chain: string
asset: string
fee_rate: string
min_fee: string
max_fee: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** LatestDepositAddress queries the a deposit address by recipient */
LatestDepositAddress: {
    method: 'get'
    endpoint: {
/** '/axelar/nexus/v1beta1/latest_deposit_address/{recipient_addr}/{recipient_chain}/{deposit_chain}' */
axelar: `/axelar/nexus/v1beta1/latest_deposit_address/${string}/${string}/${string}`
}
    params: {
        path: {
axelar: {
recipient_addr: string
recipient_chain: string
deposit_chain: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
deposit_addr: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** RecipientAddress queries the recipient address for a given deposit address */
RecipientAddress: {
    method: 'get'
    endpoint: {
/** '/axelar/nexus/v1beta1/recipient_address/{deposit_chain}/{deposit_addr}' */
axelar: `/axelar/nexus/v1beta1/recipient_address/${string}/${string}`
}
    params: {
        path: {
axelar: {
deposit_chain: string
deposit_addr: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
recipient_addr: string
recipient_chain: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** TransferFee queries the transfer fee by the source, destination chain,
and amount. If amount is 0, the min fee is returned */
TransferFee2: {
    method: 'get'
    endpoint: {
/** '/axelar/nexus/v1beta1/transfer_fee' */
axelar: `/axelar/nexus/v1beta1/transfer_fee`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
source_chain: string
destination_chain: string
amount: string
}
}
        body: {
axelar: {
source_chain: string
destination_chain: string
amount: string
}
}
    }
    response: {
        success: {
axelar: {
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
fee: {
denom: string
amount: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** TransferFee queries the transfer fee by the source, destination chain,
and amount. If amount is 0, the min fee is returned */
TransferFee: {
    method: 'get'
    endpoint: {
/** '/axelar/nexus/v1beta1/transfer_fee/{source_chain}/{destination_chain}/{amount}' */
axelar: `/axelar/nexus/v1beta1/transfer_fee/${string}/${string}/${string}`
}
    params: {
        path: {
axelar: {
source_chain: string
destination_chain: string
amount: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
fee: {
denom: string
amount: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** TransfersForChain queries transfers by chain */
TransfersForChain: {
    method: 'get'
    endpoint: {
/** '/axelar/nexus/v1beta1/transfers_for_chain/{chain}/{state}' */
axelar: `/axelar/nexus/v1beta1/transfers_for_chain/${string}/${string}`
}
    params: {
        path: {
axelar: {
chain: string
state: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: {
transfers: Array<{
/** CrossChainAddress represents a generalized address on any registered chain */
recipient: {
/** Chain represents the properties of a registered blockchain */
chain: {
name: string
supports_foreign_assets: boolean
key_type: string
module: string
}
address: string
}
/** Coin defines a token with a denomination and an amount.

NOTE: The amount field is an Int which implements the custom method
signatures required by gogoproto. */
asset: {
denom: string
amount: string
}
id: string
state: string
}>
/** PageResponse is to be embedded in gRPC response messages where the
corresponding request message has used PageRequest.

 message SomeResponse {
         repeated Bar results = 1;
         PageResponse page = 2;
 } */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** DeactivateProxy defines a method for deregistering a proxy account. */
DeactivateProxy: {
    method: 'post'
    endpoint: {
/** '/axelar/snapshot/deactivate_proxy' */
axelar: `/axelar/snapshot/deactivate_proxy`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
}
}
}
        body: {
axelar: {
'body': {
sender: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** RegisterProxy defines a method for registering a proxy account that can act
in a validator account's stead. */
RegisterProxy: {
    method: 'post'
    endpoint: {
/** '/axelar/snapshot/register_proxy' */
axelar: `/axelar/snapshot/register_proxy`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
proxy_addr: string
}
}
}
        body: {
axelar: {
'body': {
sender: string
proxy_addr: string
}
}
}
    }
    response: {
        success: {
axelar: {}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** undefined */
HeartBeat: {
    method: 'post'
    endpoint: {
/** '/axelar/tss/heartbeat' */
axelar: `/axelar/tss/heartbeat`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
'body': {
sender: string
key_ids: Array<string>
}
}
}
        body: {
axelar: {
'body': {
sender: string
key_ids: Array<string>
}
}
}
    }
    response: {
        success: {
axelar: {
keygen_illegibility: number
signing_illegibility: number
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** AssignableKey returns true if there is no assigned key for the
next rotation on a given chain, and false otherwise */
AssignableKey: {
    method: 'get'
    endpoint: {
/** '/axelar/tss/v1beta1/assignable_key/{chain}/{key_role}' */
axelar: `/axelar/tss/v1beta1/assignable_key/${string}/${string}`
}
    params: {
        path: {
axelar: {
chain: string
key_role: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
assignable: boolean
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** NextKeyID returns the key ID assigned for the next rotation on a given
chain and for the given key role */
NextKeyID: {
    method: 'get'
    endpoint: {
/** '/axelar/tss/v1beta1/next_key_id/{chain}/{key_role}' */
axelar: `/axelar/tss/v1beta1/next_key_id/${string}/${string}`
}
    params: {
        path: {
axelar: {
chain: string
key_role: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
key_id: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ValidatorMultisigKeys returns the validator's multisig pubkeys
corresponding to each active key ID */
ValidatorMultisigKeys: {
    method: 'get'
    endpoint: {
/** '/axelar/tss/v1beta1/validator_multisig_keys/{address}' */
axelar: `/axelar/tss/v1beta1/validator_multisig_keys/${string}`
}
    params: {
        path: {
axelar: {
address: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: {
keys: {}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** AllowancesByGranter returns all the grants given by an address
Since v0.46 */
AllowancesByGranter: {
    method: 'get'
    endpoint: {
/** '/cosmos/feegrant/v1beta1/issued/{granter}' */
axelar: `/cosmos/feegrant/v1beta1/issued/${string}`
}
    params: {
        path: {
axelar: {
granter: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method. */
{
/** allowances that have been issued by the granter. */
allowances: Array<{
/** granter is the address of the user granting an allowance of their funds. */
granter: string
/** grantee is the address of the user being granted an allowance of another user's funds. */
grantee: string
/** allowance can be any of basic and filtered fee allowance. */
allowance: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}>
/** pagination defines an pagination for the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** AnnualProvisions current minting annual provisions value. */
AnnualProvisions: {
    method: 'get'
    endpoint: {
/** '/cosmos/mint/v1beta1/annual_provisions' */
axelar: `/cosmos/mint/v1beta1/annual_provisions`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: /** QueryAnnualProvisionsResponse is the response type for the
Query/AnnualProvisions RPC method. */
{
/** annual_provisions is the current minting annual provisions value. */
annual_provisions: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Inflation returns the current minting inflation value. */
Inflation: {
    method: 'get'
    endpoint: {
/** '/cosmos/mint/v1beta1/inflation' */
axelar: `/cosmos/mint/v1beta1/inflation`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: /** QueryInflationResponse is the response type for the Query/Inflation RPC
method. */
{
/** inflation is the current minting inflation value. */
inflation: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** Params returns the total set of minting parameters. */
MintParams: {
    method: 'get'
    endpoint: {
/** '/cosmos/mint/v1beta1/params' */
axelar: `/cosmos/mint/v1beta1/params`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
{
/** params defines the parameters of the module. */
params: {
/** type of coin to mint */
mint_denom: string
/** maximum annual change in inflation rate */
inflation_rate_change: string
/** maximum inflation rate */
inflation_max: string
/** minimum inflation rate */
inflation_min: string
/** goal of percent bonded atoms */
goal_bonded: string
/** expected blocks per year */
blocks_per_year: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
/** DelegatorValidators queries all validators info for given delegator
address. */
StakingDelegatorValidators: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators' */
axelar: `/cosmos/staking/v1beta1/delegators/${string}/validators`
}
    params: {
        path: {
axelar: {
/** delegator_addr defines the delegator address to query for. */
delegator_addr: string
}
}
    
        query: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
        body: {
axelar: {
/** key is a value returned in PageResponse.next_key to begin
querying the next page most efficiently. Only one of offset or key
should be set. */
'pagination.key': string
/** offset is a numeric offset that can be used when key is unavailable.
It is less efficient than using key. Only one of offset or key should
be set. */
'pagination.offset': number
/** limit is the total number of results to be returned in the result page.
If left empty it will default to a value to be set by each app. */
'pagination.limit': number
/** count_total is set to true  to indicate that the result set should include
a count of the total number of items available for pagination in UIs.
count_total is only respected when offset is used. It is ignored when key
is set. */
'pagination.count_total': string
/** reverse is set to true if results are to be returned in the descending order.

Since: cosmos-sdk 0.43 */
'pagination.reverse': string
}
}
    }
    response: {
        success: {
axelar: /** QueryDelegatorValidatorsResponse is response type for the
Query/DelegatorValidators RPC method. */
{
/** validators defines the the validators' info of a delegator. */
validators: Array<{
/** operator_address defines the address of the validator's operator; bech encoded in JSON. */
operator_address: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
consensus_pubkey: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
/** jailed defined whether the validator has been jailed from bonded status or not. */
jailed: boolean
/** status is the validator status (bonded/unbonding/unbonded). */
status: string
/** tokens define the delegated tokens (incl. self-delegation). */
tokens: string
/** delegator_shares defines total shares issued to a validator's delegators. */
delegator_shares: string
/** description defines the description terms for the validator. */
description: {
/** moniker defines a human-readable name for the validator. */
moniker: string
/** identity defines an optional identity signature (ex. UPort or Keybase). */
identity: string
/** website defines an optional website link. */
website: string
/** security_contact defines an optional email for security contact. */
security_contact: string
/** details define other optional details. */
details: string
}
/** unbonding_height defines, if unbonding, the height at which this validator has begun unbonding. */
unbonding_height: string
/** unbonding_time defines, if unbonding, the min time for the validator to complete unbonding. */
unbonding_time: string
/** commission defines the commission parameters. */
commission: {
/** commission_rates defines the initial commission rates to be used for creating a validator. */
commission_rates: {
/** rate is the commission rate charged to delegators, as a fraction. */
rate: string
/** max_rate defines the maximum commission rate which validator can ever charge, as a fraction. */
max_rate: string
/** max_change_rate defines the maximum daily increase of the validator commission, as a fraction. */
max_change_rate: string
}
/** update_time is the last time the commission rate was changed. */
update_time: string
}
/** min_self_delegation is the validator's self declared minimum self delegation. */
min_self_delegation: string
}>
/** pagination defines the pagination in the response. */
pagination: {
/** next_key is the key to be passed to PageRequest.key to
query the next page most efficiently */
next_key: string
/** total is total number of results available if PageRequest.count_total
was set, its value is undefined otherwise */
total: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Pool queries the pool info. */
StakingPool: {
    method: 'get'
    endpoint: {
/** '/cosmos/staking/v1beta1/pool' */
axelar: `/cosmos/staking/v1beta1/pool`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: /** QueryPoolResponse is response type for the Query/Pool RPC method. */
{
/** pool defines the pool info. */
pool: {
not_bonded_tokens: string
bonded_tokens: string
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** AppliedPlan queries a previously applied upgrade plan by its name. */
AppliedPlan: {
    method: 'get'
    endpoint: {
/** '/cosmos/upgrade/v1beta1/applied_plan/{name}' */
axelar: `/cosmos/upgrade/v1beta1/applied_plan/${string}`
}
    params: {
        path: {
axelar: {
/** name is the name of the applied plan to query for. */
name: string
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: /** QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC
method. */
{
/** height is the block height at which the plan was applied. */
height: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** CurrentPlan queries the current upgrade plan. */
CurrentPlan: {
    method: 'get'
    endpoint: {
/** '/cosmos/upgrade/v1beta1/current_plan' */
axelar: `/cosmos/upgrade/v1beta1/current_plan`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: /** QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC
method. */
{
/** plan is the current upgrade plan. */
plan: {
/** Sets the name for the upgrade. This name will be used by the upgraded
version of the software to apply any special "on-upgrade" commands during
the first BeginBlock method after the upgrade is applied. It is also used
to detect whether a software version can handle a given upgrade. If no
upgrade handler with this name has been set in the software, it will be
assumed that the software is out-of-date when the upgrade Time or Height is
reached and the software will exit. */
name: string
/** Deprecated: Time based upgrades have been deprecated. Time based upgrade logic
has been removed from the SDK.
If this field is not empty, an error will be thrown. */
time: string
/** The height at which the upgrade must be performed.
Only used if Time is not set. */
height: string
/** Any application specific upgrade info to be included on-chain
such as a git commit that validators could automatically upgrade to */
info: string
/** `Any` contains an arbitrary serialized protocol buffer message along with a
URL that describes the type of the serialized message.

Protobuf library provides support to pack/unpack Any values in the form
of utility functions or additional generated methods of the Any type.

Example 1: Pack and unpack a message in C++.

    Foo foo = ...;
    Any any;
    any.PackFrom(foo);
    ...
    if (any.UnpackTo(&foo)) {
      ...
    }

Example 2: Pack and unpack a message in Java.

    Foo foo = ...;
    Any any = Any.pack(foo);
    ...
    if (any.is(Foo.class)) {
      foo = any.unpack(Foo.class);
    }

 Example 3: Pack and unpack a message in Python.

    foo = Foo(...)
    any = Any()
    any.Pack(foo)
    ...
    if any.Is(Foo.DESCRIPTOR):
      any.Unpack(foo)
      ...

 Example 4: Pack and unpack a message in Go

     foo := &pb.Foo{...}
     any, err := anypb.New(foo)
     if err != nil {
       ...
     }
     ...
     foo := &pb.Foo{}
     if err := any.UnmarshalTo(foo); err != nil {
       ...
     }

The pack methods provided by protobuf library will by default use
'type.googleapis.com/full.type.name' as the type URL and the unpack
methods only use the fully qualified type name after the last '/'
in the type URL, for example "foo.bar.com/x/y.z" will yield type
name "y.z".


JSON
====
The JSON representation of an `Any` value uses the regular
representation of the deserialized, embedded message, with an
additional field `@type` which contains the type URL. Example:

    package google.profile;
    message Person {
      string first_name = 1;
      string last_name = 2;
    }

    {
      "@type": "type.googleapis.com/google.profile.Person",
      "firstName": <string>,
      "lastName": <string>
    }

If the embedded message type is well-known and has a custom JSON
representation, that representation will be embedded adding a field
`value` which holds the custom JSON in addition to the `@type`
field. Example (for message [google.protobuf.Duration][]):

    {
      "@type": "type.googleapis.com/google.protobuf.Duration",
      "value": "1.212s"
    } */
upgraded_client_state: {
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** ModuleVersions queries the list of module versions from state. */
ModuleVersions: {
    method: 'get'
    endpoint: {
/** '/cosmos/upgrade/v1beta1/module_versions' */
axelar: `/cosmos/upgrade/v1beta1/module_versions`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: {
/** module_name is a field to query a specific module
consensus version from state. Leaving this empty will
fetch the full list of module versions from state. */
module_name: string
}
}
        body: {
axelar: {
/** module_name is a field to query a specific module
consensus version from state. Leaving this empty will
fetch the full list of module versions from state. */
module_name: string
}
}
    }
    response: {
        success: {
axelar: /** QueryModuleVersionsResponse is the response type for the Query/ModuleVersions
RPC method.

Since: cosmos-sdk 0.43 */
{
/** module_versions is a list of module names with their consensus versions. */
module_versions: Array<{
/** name of the app module */
name: string
/** consensus version of the app module */
version: string
}>
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** UpgradedConsensusState queries the consensus state that will serve
as a trusted kernel for the next version of this chain. It will only be
stored at the last height of this chain.
UpgradedConsensusState RPC not supported with legacy querier
This rpc is deprecated now that IBC has its own replacement
(https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54) */
DeprecatedUpgradedConsensusState: {
    method: 'get'
    endpoint: {
/** '/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}' */
axelar: `/cosmos/upgrade/v1beta1/upgraded_consensus_state/${number}`
}
    params: {
        path: {
axelar: {
/** last height of the current chain must be sent in request
as this is the height under which next consensus state is stored */
last_height: number
}
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: /** QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState
RPC method. */
{
/** Since: cosmos-sdk 0.43 */
upgraded_consensus_state: string
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
/** Must be a valid serialized protocol buffer of the above specified type. */
value: string
}>
}
}
    }

}
        
/** Params queries all parameters of the ibc-transfer module. */
IBCTransferParams: {
    method: 'get'
    endpoint: {
/** '/ibc/apps/transfer/v1/params' */
axelar: `/ibc/apps/transfer/v1/params`
}
    params: {
        path: {
axelar: undefined
}
    
        query: {
axelar: undefined
}
        body: {
axelar: undefined
}
    }
    response: {
        success: {
axelar: /** QueryParamsResponse is the response type for the Query/Params RPC method. */
{
/** params defines the parameters of the module. */
params: {
/** send_enabled enables or disables all cross-chain token transfers from this
chain. */
send_enabled: boolean
/** receive_enabled enables or disables all cross-chain token transfers to this
chain. */
receive_enabled: boolean
}
}
}
        error: {
axelar: {
error: string
code: number
message: string
details: Array<{
type_url: string
value: string
}>
}
}
    }

}
        
}

/** Represent any of the available chain names. */
export type ChainName = | 'evmos' | 'axelar' | 'kyve'

/** Represent any of the available operation IDs. */
export type OperationId = keyof RestApi